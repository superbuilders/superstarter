# Inngest TypeScript Documentation

@generated: 2026-02-10
@page-count: 152


--------------------------------------------------------------------------------
title: "Model Context Protocol (MCP) Integration"
source: "https://www.inngest.com/docs/ai-dev-tools/mcp"
--------------------------------------------------------------------------------

# Model Context Protocol (MCP) Integration

The Inngest dev server includes a comprehensive Model Context Protocol (MCP) server that provides AI assistants with direct access to your Inngest functions, events, and documentation. This enables powerful AI-assisted development workflows for testing, debugging, and building Inngest applications.

## What is MCP?

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/introduction) is a standard for connecting AI assistants to external tools and data sources. The Inngest MCP integration provides AI tools like Claude Code and Cursor with:

- **Complete function visibility** - List and inspect all registered functions
- **Event triggering** - Send events to test functions and workflows
- **Real-time monitoring** - Track function execution and debug failures
- **Documentation access** - Search and read Inngest documentation offline
- **Direct function invocation** - Execute functions synchronously with immediate results

> **Callout:** The Inngest MCP server runs locally with your dev server and requires no external dependencies, API keys, or internet connection to function.

## Quick Start

### 1. Start the Inngest Dev Server

The MCP server is automatically available when you start the Inngest dev server:

```bash
npx --ignore-scripts=false inngest-cli@latest dev
```

The MCP endpoint will be available at `http://127.0.0.1:8288/mcp`

### 2. Connect Your AI Tool

```bash {{ title: "Claude Code" }}
# Add to your MCP configuration
claude mcp add --transport http inngest-dev http://127.0.0.1:8288/mcp
```

```json {{ title: "Cursor" }}
// Add to .cursor/mcp.json
{
  "mcpServers": {
    "inngest-dev": {
      "url": "http://127.0.0.1:8288/mcp"
    }
  }
}
```

```json {{ title: "Claude Desktop" }}
// Add to Claude Desktop configuration
{
  "mcpServers": {
    "inngest-dev": {
      "command": "curl",
      "args": [
        "-X", "POST",
        "http://127.0.0.1:8288/mcp",
        "-H", "Content-Type: application/json",
        "-d", "@-"
      ]
    }
  }
}
```

### 3. Start Building with AI

Once connected, you can ask your AI assistant to:

```
List all my Inngest functions and their triggers
```

```
Send a test event to trigger the user signup workflow
```

```
Monitor the function run and show me any errors
```

```
Search the docs for rate limiting examples
```

## Best Practices

### Function Testing

- **Start simple:** Test individual functions before complex workflows
- **Use descriptive events:** Clear event names help with debugging
- **Monitor execution:** Always check run status after triggering events
- **Test error scenarios:** Intentionally trigger failures to test error handling

### Debugging Workflows

- **Check step details:** Use `get_run_status` to see step-by-step execution
- **Review error context:** Error messages include stack traces and context
- **Verify data flow:** Check inputs and outputs at each step
- **Use polling for async:** Monitor long-running workflows with `poll_run_status`

### Documentation Usage

- **Search before building:** Use `grep_docs` to find relevant examples
- **Reference patterns:** Look for similar use cases in the documentation
- **Cross-reference APIs:** Use `read_doc` for complete API documentation

## Available MCP Tools

The Inngest MCP server provides 8 powerful tools organized into three categories:

### Event Management Tools

#### `send_event`

Send an event to trigger functions and get immediate feedback on which runs were created.

**Parameters:**

- `name` (string, required): Event name (e.g., 'app/user.created')
- `data` (object, optional): Event payload data
- `user` (object, optional): User context information
- `eventIdSeed` (string, optional): Seed for deterministic event IDs

**Example usage:**

```
Send a test event called 'app/user.signup' with user email 'test@example.com'
```

#### `list_functions`

Discover all registered functions with their names, IDs, and trigger information.

**Returns:** Complete function inventory with trigger details (events, crons, etc.)

#### `invoke_function`

Directly execute a function and wait for its complete result - perfect for testing specific functions.

**Parameters:**

- `functionId` (string, required): Function slug, ID, or name
- `data` (object, optional): Input data for the function
- `user` (object, optional): User context
- `timeout` (int, optional): Wait timeout in seconds (default: 30)

**Example usage:**

```
> "Invoke the 'process-payment' function with amount 100 and currency USD"
```

### Execution Monitoring Tools

#### `get_run_status`

Get detailed information about a specific function run, including step-by-step execution details.

**Parameters:**

- `runId` (string, required): The run ID from send\_event or logs

**Returns:** Complete run information including status, steps, outputs, and error details

#### `poll_run_status`

Monitor multiple function runs until completion - essential for integration testing workflows.

**Parameters:**

- `runIds` (array, required): Array of run IDs to monitor
- `timeout` (int, optional): Total polling timeout in seconds (default: 30)
- `pollInterval` (int, optional): Milliseconds between polls (default: 1000)

**Example usage:**

```
Poll these 3 runs until they complete and show me a summary
```

### Documentation Tools

#### `grep_docs`

Search through embedded Inngest documentation using pattern matching.

**Parameters:**

- `pattern` (string, required): Search pattern (regex supported)
- `limit` (int, optional): Maximum results (default: 10)

**Example usage:**

```
Search the docs for 'rate limiting' examples
```

#### `read_doc`

Read the complete content of a specific documentation file.

**Parameters:**

- `path` (string, required): Document path relative to docs directory

#### `list_docs`

Get an overview of all available documentation with category breakdown.

**Returns:** Documentation structure with counts by category and SDK

## Usage Examples

### Testing a User Signup Workflow

```typescript
// Your function
export const handleSignup = inngest.createFunction(
  { id: "handle-signup" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    const user = await step.run("create-user", async () => {
      return createUser(event.data.email);
    });
    
    await step.run("send-welcome-email", async () => {
      return sendWelcomeEmail(user.email);
    });
    
    return { success: true, userId: user.id };
  }
);
```

With MCP, you can test this workflow by asking your AI assistant:

```
Send a test signup event with email 'alice@example.com' and monitor the function execution
```

The AI will:

1. Use `send_event` to trigger the function
2. Use `poll_run_status` to monitor execution
3. Show you step-by-step progress and final results
4. Report any errors with detailed context

### Debugging Failed Functions

```
Get the status of run 01J5QH90... and explain what went wrong
```

The AI will use `get_run_status` to retrieve:

- Complete execution trace
- Step-by-step status
- Error messages and stack traces
- Function outputs and intermediate results

### Integration Testing

```
Send events to trigger the complete order processing workflow and verify all steps complete successfully
```

The AI can:

1. Send multiple coordinated events
2. Monitor all resulting function runs
3. Verify the entire workflow completes
4. Report any failures or timeouts

## Troubleshooting

### Common Issues

**MCP server not found**

- Ensure the Inngest dev server is running: `npx --ignore-scripts=false inngest-cli@latest dev`
- Verify the MCP endpoint is accessible: `curl http://127.0.0.1:8288/mcp`
- Check your MCP client configuration

**Functions not listed**

- Confirm functions are properly registered with the dev server
- Check the dev server logs for registration errors
- Verify your app is correctly synced with the dev server

**Runs not found after sending events**

- Wait a moment for event processing (500ms delay is built-in)
- Check if the event name matches your function triggers exactly
- Verify the function is actually registered and listening

**Polling timeouts**

- Increase timeout values for long-running functions
- Check function logs for hanging operations
- Verify functions are actually completing vs. hanging indefinitely

### Advanced Configuration

**Custom timeouts:**
The default polling timeout is 30 seconds. For longer-running functions:

```
Poll this run with a 60-second timeout instead of the default
```

**Event ID seeding:**
For deterministic testing, you can provide event ID seeds:

```
Send a test event with seed 'test-123' for reproducible testing
```

**Documentation search:**
Use regex patterns for advanced documentation searches:

```
Search docs for 'step\\.run.*retry' to find step retry examples
```

## Resources

## Related Concepts

- [Inngest Functions](/docs/features/inngest-functions): Learn how to create and configure functions
- [Event Triggers](/docs-markdown/features/events-triggers): Understanding event-driven architectures
- [Local Development](/docs-markdown/local-development): Setting up your development environment
- [Testing Functions](/docs-markdown/reference/testing): Comprehensive testing strategies
- [Dev Server](/docs-markdown/dev-server): Complete dev server documentation
- [Error Handling](/docs-markdown/guides/error-handling): Debugging and error recovery patterns


--------------------------------------------------------------------------------
title: "Inngest Apps"
source: "https://www.inngest.com/docs/apps"
--------------------------------------------------------------------------------

# Inngest Apps

In Inngest, apps map directly to your projects or services. When you serve your functions using our serve API handler, you are hosting a new Inngest app. With Inngest apps, your dashboard reflects your code organization better.

It's important to note that apps are synced to one environment. You can sync any number of apps to one single environment using different Inngest Clients.

The diagram below shows how each environment can have multiple apps which can have multiple functions each:

## Apps in SDK

Each [`serve()` API handler](/docs-markdown/learn/serving-inngest-functions) will generate an app in Inngest upon syncing.
The app ID is determined by the ID passed to the serve handler from the Inngest client.

For example, the code below will create an Inngest app called ‚Äúexample-app‚Äù which contains one function:

```ts {{ title: "Node.js" }}
import { Inngest } from "inngest";
import { serve } from "inngest/next"; // or your preferred framework
import { sendSignupEmail } from "./functions";

const inngest = new Inngest({ id: "example-app" });

serve({
  client: inngest,
  functions: [sendSignupEmail],
});
```

```python {{ title: "Python (Flask)" }}
import logging
import inngest
from src.flask import app
import inngest.flask

logger = logging.getLogger(f"{app.logger.name}.inngest")
logger.setLevel(logging.DEBUG)

inngest_client = inngest.Inngest(app_id="flask_example", logger=logger)

@inngest_client.create_function(
    fn_id="hello-world",
    trigger=inngest.TriggerEvent(event="say-hello"),
)
def hello(ctx: inngest.ContextSync) -> str:

inngest.flask.serve(
    app,
    inngest_client,
    [hello],
)

app.run(port=8000)
```

```python {{ title: "Python (FastAPI)" }}
import logging
import inngest
import fastapi
import inngest.fast_api

logger = logging.getLogger("uvicorn.inngest")
logger.setLevel(logging.DEBUG)

inngest_client = inngest.Inngest(app_id="fast_api_example", logger=logger)

@inngest_client.create_function(
    fn_id="hello-world",
    trigger=inngest.TriggerEvent(event="say-hello"),
)
async def hello(ctx: inngest.Context) -> str:
    return "Hello world!"

app = fastapi.FastAPI()

inngest.fast_api.serve(
    app,
    inngest_client,
    [hello],
)
```

```go {{ title: "Go (HTTP)" }}
package main

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func main() {
	client, err := inngestgo.NewClient(inngestgo.ClientOpts{
		AppID: "sandbox-go",
	})
	if err != nil {
		panic(err)
	}
	f, err := inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID:   "account-created",
			Name: "Account creation flow",
		},
		// Run on every api/account.created event.
		inngestgo.EventTrigger("api/account.created", nil),
		AccountCreated,
	)
	if err != nil {
		log.Fatal(err)
	}
	http.ListenAndServe(":8080", f.Serve())
}
```

> **Callout:** Each app ID is considered a persistent identifier. Changing your client ID will result in Inngest not recognizing the app ID during the next sync. As a result, Inngest will create a new app.

## Apps in Inngest Cloud

In the image below, you can see the apps page in Inngest Cloud. Check the [Working with Apps Guide](/docs-markdown/apps/cloud) for more information about how to sync apps in Inngest Cloud.

## Apps in Inngest Dev Server

In the image below, you can see the apps page in Inngest Dev Server. For more information on how to sync apps in Inngest Dev Server check the [Local Development Guide](/docs/local-development#connecting-apps-to-the-dev-server).

## Informing Inngest about your apps

To integrate your code hosted on another platform with Inngest, you need to inform Inngest about the location of your app and functions.

For example, imagine that your `serve()` handler is located at `/api/inngest`, and your domain is `myapp.com`. In this scenario, you will need to sync your app to inform Inngest that your apps and functions are hosted at `https://myapp.com/api/inngest`.

To ensure that your functions are up to date, you need to resync your app with Inngest whenever you deploy new function configurations to your hosted platform.

> **Callout:** Inngest uses the INNGEST\_SIGNING\_KEY to securely communicate with your application and identify the correct environment to sync your app.

## Next Steps

To continue your exploration, feel free to check out:

- How to [work with Apps in the Dev Server](/docs-markdown/local-development#connecting-apps-to-the-dev-server)
- How to [work with Apps in Inngest Cloud](/docs-markdown/apps/cloud)


--------------------------------------------------------------------------------
title: "Syncing an Inngest App"
source: "https://www.inngest.com/docs/apps/cloud"
--------------------------------------------------------------------------------

# Syncing an Inngest App

After deploying your code to a hosting platform, it is time to go to production and inform Inngest about your apps and functions. Check what [Inngest Apps](/docs-markdown/apps) are if you haven't done it yet.

## Sync a new app in Inngest Cloud

You can synchronize your app with Inngest using three methods:

- Manually;
- Automatically using an integration;
- With a curl command.

### Manually

1. Select your environment (for example, "Production") in Inngest Cloud and navigate to the Apps page. You‚Äôll find a button named ‚ÄúSync App‚Äù or ‚ÄúSync New App‚Äù, depending on whether you already have synced apps.

2) Provide the location of your app by pasting the URL of your project‚Äôs `serve()` endpoint and click on ‚ÄúSync App‚Äù.

3. Your app is now synced with Inngest. üéâ

### Automatically using an integration

### Curl command

Use the curl command to sync from your machine or automate the process within a CI/CD pipeline.

Send a PUT request to your application's serve endpoint using the following command:

```shell
curl -X PUT https://<your-app>.com/api/inngest --fail-with-body
```

> **Callout:** Before syncing with Inngest, ensure that the latest version of your code is live on your platform. This is because some platforms have rolling deploys that take seconds or minutes until the latest version of your code is live.This is especially important when setting up your own automated process.

## How and when to resync an app

To ensure that your functions are up to date, you need to resync your app with Inngest whenever you deploy new function configurations to your hosted platform.

> **Callout:** If you are syncing your app through an integration, this process is automatically handled for you.

### When to resync Vercel apps manually

We recommend using our official Vercel integration, since the syncing process is automatic.
You will want to resync a Vercel app manually if:

- There was an error in the automatic syncing process (such as a network error)
- You chose not to install the Vercel integration and synced the app manually

If you have the Vercel integration and resync the app manually, the next time you deploy code to Vercel, the app will still be automatically resynced.

> **Callout:** Vercel generates a unique URL for each deployment. Please confirm that you are using the correct URL if you choose a deployment's generated URL instead of a static domain for your app.

### How to resync manually

1. Navigate to the app you want to resync. You will find a ‚ÄúResync‚Äù button at the top-right corner of the page.

2) You will see a confirmation modal. Click on ‚ÄúResync App‚Äù.

If your app location changes, enable the "Override" switch and edit the URL before clicking on "Resync App". Please ensure that the app ID is the same, otherwise Inngest will consider it a new app white resyncing.

## Troubleshooting

Why is my app syncing to the wrong environment?

- Apps are synced to one environment. The [**`INNGEST_SIGNING_KEY`**](/docs/platform/signing-keys) ensures that your app is synced within the correct Inngest environment. Verify that you assigned your signing key to the right¬†`INNGEST_SIGNING_KEY`¬†environment variable in your hosting provider or¬†**`.env`**¬†file locally.

Why do I have duplicated apps?

- Each app ID is considered a persistent identifier. [Since the app ID is determined by the ID passed to the serve handler from the Inngest client](/docs-markdown/apps#apps-in-sdk), changing that ID will result in Inngest not recognizing the app ID during the next sync. As a result, Inngest will create a new app.

Why is my sync inside unattached syncs?

- Failures in automatic syncs may not be immediately visible. In such cases, an unattached sync (a sync without an app) containing the failure message is created.

Why don‚Äôt I see my sync in the sync list?

If you're experiencing difficulties with syncing and cannot locate your sync in the sync list, consider the following scenarios:

1. **Different App ID:**

- If you resync the app after modifying the [app ID](/docs-markdown/reference/client/create), a new app is created, not a new sync within the existing app.
- Solution: Confirm the creation of a new app when changing the app ID.

2. **Syncing Errors:**

- *Manual Syncs and Manual Resyncs:*
  - Sync failures during manual operations are immediately displayed, preventing the creation of a new sync. The image below shows an example of an error while manually syncing:
  - Solution: Review the displayed error message and address the syncing issue accordingly.
- *Automatic Syncs (such as Vercel Integration):*
  - Failures in automatic syncs may not be immediately visible. In such cases, an unattached sync (a sync without an app) containing the failure message is created.

  - Solution: Check for unattached syncs and address the issues outlined in the failure message. The image below shows the location of unattached syncs in Inngest Cloud:


--------------------------------------------------------------------------------
title: "Cloudflare Pages"
source: "https://www.inngest.com/docs/deploy/cloudflare"
--------------------------------------------------------------------------------

# Cloudflare Pages

Inngest allows you to deploy your event-driven functions to [Cloudflare Pages](https://pages.cloudflare.com/).

## Deploying to Cloudflare Pages

1. [Write your functions](/docs-markdown/functions)
2. [Serve your functions](/docs-markdown/learn/serving-inngest-functions#framework-cloudflare)
3. [Set environment variables](https://developers.cloudflare.com/pages/get-started/#environment-variables) for your deployment

- `NODE_VERSION: 16`
- `INNGEST_SIGNING_KEY: ***` - from [the Inngest dashboard](https://app.inngest.com/env/production/manage/signing-key)
- `INNGEST_EVENT_KEY: ***` - from [the Inngest dashboard](https://app.inngest.com/env/production/manage/keys)

## Syncing your app

After your code is deployed to Cloudflare Pages, you'll need to sync your app with Inngest. Learn how to [sync your app with Inngest here](/docs-markdown/apps/cloud#sync-a-new-app-in-inngest-cloud).


--------------------------------------------------------------------------------
title: "DigitalOcean"
source: "https://www.inngest.com/docs/deploy/digital-ocean"
--------------------------------------------------------------------------------

# DigitalOcean

Inngest functions can be deployed to DigitalOcean's Functions, App Platform, or Droplets.
This page covers how to configure the [Inngest Add-Ons](https://marketplace.digitalocean.com/add-ons/inngest) for your DigitalOcean App Platform projects or Droplets. To configure Inngest with DigitalOcean Functions, see the [`serve()` reference](/docs-markdown/learn/serving-inngest-functions#framework-digital-ocean-functions).

- [Configure a DigitalOcean App Platform project or Droplet with a new Inngest account](#configure-a-digitalocean-app-platform-project-or-droplet-with-a-new-inngest-account)
- [Configure a DigitalOcean App Platform project or Droplet with an existing Inngest account](#configure-a-digitalocean-app-platform-project-or-droplet-with-an-existing-inngest-account)

## Configure a DigitalOcean App Platform project or Droplet with a new Inngest account

### Prerequisites

Before starting, make sure you have:

- A DigitalOcean account with an application deployed on App Platform or on a Droplet.
- Access to SaaS Add-Ons and environment variables in your App Platform project or Droplet.

### Step 1: Add Inngest as a SaaS Add-On

From your DigitalOcean dashboard:

- Navigate to [the Inngest Add-Ons page](https://marketplace.digitalocean.com/add-ons/inngest)
- Click the "Add Inngest" button in the top-right.
- Select the region closest to your app's deployment.
- Click "Create Resource".

DigitalOcean will create an Inngest account for you.

You can now proceed to step 2 to access your Inngest application credentials.

### Step 2: Access your Inngest application credentials

Navigate to your [DigitalOcean Dashboard](https://cloud.digitalocean.com/) and click "Add-Ons" in the left sidebar.

Once the Inngest Add-On is installed, click the "View Inngest" link to access the Inngest Dashboard:

![image.png](/assets/external/digital-ocean-marketplace/digital-ocean-dashboard.png)

From the Inngest Dashboard, click the keys icon in the top-left to access the Event and Signing keys:

![image.png](/assets/external/digital-ocean-marketplace/inngest-dashboard.png)

Visit both the Event key and Signing key pages to copy their values.

### Step 3: Configure Environment Variables

Back in your DigitalOcean Dashboard, copy the Event and Signing keys into your application's environment variables as follows:

- `INNGEST_EVENT_KEY` ‚Üí copy from the Inngest Dashboard
- `INNGEST_SIGNING_KEY` ‚Üí copy from the Inngest Dashboard

### You're all set: install and configure the Inngest SDK

Your DigitalOcean application is now configured with the Inngest Add-On. You can now install the Inngest SDK in your application and follow the tutorials below based on your language and framework:

- [TypeScript quick start](/docs-markdown/getting-started/nodejs-quick-start)
- [Python quick start](/docs-markdown/getting-started/python-quick-start)
- [Go reference](https://pkg.go.dev/github.com/inngest/inngestgo)

**Note:** Once your application is configured and deployed with the Inngest SDK, go to the Inngest Dashboard to [sync your application](/docs-markdown/apps/cloud).

## Configure a DigitalOcean App Platform project or Droplet with an existing Inngest account

To configure a DigitalOcean App Platform project or Droplet with an existing Inngest account:

[Follow this guide](/docs-markdown/apps/cloud) to create and sync a new app in Inngest Cloud.


--------------------------------------------------------------------------------
title: "Netlify"
source: "https://www.inngest.com/docs/deploy/netlify"
--------------------------------------------------------------------------------

# Netlify

We provide a Netlify build plugin, [netlify-plugin-inngest](https://www.npmjs.com/package/netlify-plugin-inngest), that allows you to automatically sync any found apps whenever your site is deployed to Netlify.

## Setup

1. Install `netlify-plugin-inngest` as a dev dependency:

```sh
npm install --save-dev netlify-plugin-inngest
# or
yarn add --dev netlify-plugin-inngest
```

2. Create or edit a `netlify.toml` file at the root of your project with the following:

```toml
[[plugins]]
package = "netlify-plugin-inngest"
```

Done! ü•≥ Whenever your site is deployed, your app hosted at `/api/inngest` will be synced.

## Configuration

If you want to use a URL that isn't your "primary" Netlify domain, or your functions are served at a different path, provide either `host`, `path`, or both as inputs in the same file:

```toml
[[plugins]]
package = "netlify-plugin-inngest"

  [plugins.inputs]
    host = "https://my-specific-domain.com"
    path = "/api/inngest"
```


--------------------------------------------------------------------------------
title: "Render"
source: "https://www.inngest.com/docs/deploy/render"
--------------------------------------------------------------------------------

# Render

[Render](https://render.com) lets you easily deploy and scale full stack applications. You can deploy your Inngest functions on Render using any web framework, including [Next.js](https://docs.render.com/deploy-nextjs-app), [Express](https://docs.render.com/deploy-node-express-app), and [FastAPI](https://docs.render.com/deploy-fastapi).

Below, we'll cover how to deploy:

1. A production Inngest app
2. Preview apps for each of your Git development branches

### Before you begin

- Create a web application that serves Inngest functions.
- Test this web app locally with the [Inngest dev server](/docs-markdown/dev-server).

## Deploy a production app on Render

1. Deploy the web application that contains your Inngest functions to Render.
   - See [Render's guides](https://docs.render.com) to learn how to deploy specific frameworks, such as:
     - [Next.js](https://docs.render.com/deploy-nextjs-app)
     - [Express](https://docs.render.com/deploy-node-express-app)
     - [FastAPI](https://docs.render.com/deploy-fastapi)
2. Set the `INNGEST_SIGNING_KEY` and `INNGEST_EVENT_KEY` environment variables on your Render web app.
   - You can easily [configure environment variables](https://docs.render.com/configure-environment-variables) on a Render service through the Render dashboard.
   - You can find your production `INNGEST_SIGNING_KEY` [here](https://app.inngest.com/env/production/manage/signing-key), and your production `INNGEST_EVENT_KEY`s [here](https://app.inngest.com/env/production/manage/keys).
3. Manually sync your Render web app with Inngest.
   - See [this Inngest guide](/docs-markdown/apps/cloud) for instructions.

## Automatically sync your app with Inngest

Each time you push changes to your Inngest functions, you need to sync your web app with Inngest. For convenience, you can automate these syncs from your CI/CD or from your API.

### Automatically sync from your CI/CD

Automatically sync your app with Inngest using the [Render Deploy Action](https://github.com/marketplace/actions/render-deploy-action), combined with a ["curl command"](/docs-markdown/apps/cloud#curl-command):

```yaml
# .github/workflows/deploy.yaml
name: My Deploy

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to production
        uses: johnbeynon/render-deploy-action@v0.0.8
        with:
          service-id: ${{ secrets.MY_RENDER_SERVICE_ID }}
          api-key: ${{ secrets.MY_RENDER_API_KEY }}
          wait-for-success: true

  sync_inngest:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Register application to Inngest
       - run: |
            curl -X PUT ${{ secrets.APP_URL }}/api/inngest
```

*The above GitHub Action requires the `MY_RENDER_API_KEY`, `MY_RENDER_SERVICE_ID` and `APP_URL` to be configured on your repository.*

### Automatically sync from your app

You app can self-register as part of its startup flow **if it matches the following requirements**:

- Your application should run as a long-lived server instance (not serverless)
- Your application should be deployed as a single node (not with auto scaled replicas)

The following Express.js code snippet showcases how to achieve self-register:

```tsx {{ title: "index.ts (Express.js)" }}

// your express `app` definition stands here...

app.listen(PORT, async () => {
  console.log(`‚úÖ Server started on localhost:${PORT}
‚û°Ô∏è Inngest running at http://localhost:${PORT}/api/inngest`);

  // Attempt to self-register the app after deploy
  if (process.env.RENDER_EXTERNAL_URL) {
    console.log(
      `Attempting self-register. Functions: `,
      functions.map((f) => f.name).join(', ')
    );
    const inngestURL = new URL('/api/inngest', process.env.RENDER_EXTERNAL_URL);
    const result = await fetch(inngestURL, {
      method: 'PUT',
    });
    await sleep(2000);
    try {
      const json = await result.json();
      console.log(
        `Register attempted:`,
        inngestURL.toString(),
        result.status,
        json
      );
    } catch (err) {
      console.log(
        `Register failed:`,
        inngestURL.toString(),
        result.status,
        result.body
      );
    }
  }
});

function sleep(t: number): Promise<void> {
  return new Promise((res) => {
    return setTimeout(res, t);
  });
}
```

*[The full code is available on GitHub](https://github.com/inngest/inngest-demo-app/blob/e95247d3e3277ecd57bd9a8bb1478c36b3ee09b2/index.ts)*

## Set up preview apps on Render

### What are preview apps?

Render lets you deploy work-in-progress versions of your apps using code in a Git development branch. Specifically, you can deploy:

- [Service previews](https://docs.render.com/pull-request-previews): a temporary standalone instance of a single Render service.
- [Preview environments](https://docs.render.com/preview-environments): a disposable copy of your production environment that can include multiple services and databases.

You can use Render's service previews and preview environments together with Inngest's [branch environments](/docs-markdown/platform/environments).

### Set up Inngest in preview apps

To use Inngest in a Render service preview or preview environment, follow these steps.

One-time setup:

1. Follow Render's guides to enable either a [service preview](https://docs.render.com/pull-request-previews) or a [preview environment](https://docs.render.com/preview-environments).
2. In Inngest, create a *branch environment* `INNGEST_SIGNING_KEY` and a *branch environment* `INNGEST_EVENT_KEY`.
   - You can find your branch environment `INNGEST_SIGNING_KEY` [here](https://app.inngest.com/env/branch/manage/signing-key).
   - You can create a branch environment `INNGEST_EVENT_KEY` [here](https://app.inngest.com/env/branch/manage/keys).

Each time a preview app is deployed:

1. Set the following environment variables on the preview service:

   - `INNGEST_SIGNING_KEY` and `INNGEST_EVENT_KEY`: Use the values from your Inngest branch environment.
   - `INNGEST_ENV`: Provide any value you want. This value will be used as [the name of the branch in Inngest](/docs-markdown/platform/environments#configuring-branch-environments). As an option, you can use the value of [`RENDER_GIT_BRANCH`](https://docs.render.com/environment-variables#all-runtimes).

   You can [configure environment variables](https://docs.render.com/configure-environment-variables) on the preview service through the Render dashboard. Alternatively, you can send a `PUT` or `PATCH` request [via the Render API](https://api-docs.render.com/reference/update-env-vars-for-service).
2. Sync the app with Inngest.

   You can manually sync the app [from the branch environments section](https://app.inngest.com/env/branch/apps/sync-new) of your Inngest dashboard, or automatically sync your app using a strategy [described above](#automatically-sync-your-app-with-inngest).


--------------------------------------------------------------------------------
title: "Vercel"
source: "https://www.inngest.com/docs/deploy/vercel"
--------------------------------------------------------------------------------

# Vercel

Inngest enables you to host your functions on Vercel using their [serverless functions platform](https://vercel.com/docs-markdown/concepts/functions/serverless-functions). This allows you to deploy your Inngest functions right alongside your existing website and API functions running on Vercel.

Inngest will call your functions securely via HTTP request on-demand, whether triggered by an event or on a schedule in the case of cron jobs.

## Hosting Inngest functions on Vercel

After you've written your functions using [Next.js](/docs-markdown/learn/serving-inngest-functions?ref=docs-deploy-vercel#framework-next-js) or Vercel's [Express-like](/docs-markdown/learn/serving-inngest-functions?ref=docs-deploy-vercel#framework-express) functions within your project, you need to serve them via the `serve` handler. Using the `serve` handler, create a Vercel/Next.js function at the `/api/inngest` endpoint. Here's an example in a Next.js app:

## Choose the Next.js App Router or Pages Router:

#### nextpages

```ts
import { serve } from "inngest/next";
import { client } from "../../inngest/client";
import { firstFunction, anotherFunction } from "../../inngest/functions";

export default serve({
  client: client,
  functions: [
    firstFunction,
    anotherFunction
  ]
});
```

#### nextappdir

```ts
import { serve } from "inngest/next";
import { client } from "../../inngest/client";
import { firstFunction, anotherFunction } from "../../inngest/functions";

export const { GET, POST, PUT } = serve({
  client: client,
  functions: [
    firstFunction,
    anotherFunction
  ]
});
```

## Deploying to Vercel

Installing [Inngest's official Vercel integration](https://vercel.com/integrations/inngest) does 3 things:

1. Automatically sets the required [`INNGEST_SIGNING_KEY`](/docs-markdown/sdk/environment-variables#inngest-signing-key) environment variable to securely communicate with Inngest's API ([docs](/docs-markdown/platform/signing-keys)).
2. Automatically sets the [`INNGEST_EVENT_KEY`](/docs-markdown/sdk/environment-variables#inngest-event-key) environment variable to enable your application to send events ([docs](/docs-markdown/events/creating-an-event-key)).
3. Automatically syncs your app to Inngest every time you deploy updated code to Vercel - no need to change your existing workflow!

To enable communication between Inngest and your code, you need to either [disable Deployment Protection](https://vercel.com/docs-markdown/security/deployment-protection#configuring-deployment-protection)
or, if you're on Vercel's Pro plan, configure protection bypass:

## Bypassing Deployment Protection

If you have Vercel's [Deployment Protection feature](https://vercel.com/docs-markdown/security/deployment-protection) enabled, *by default*, Inngest may not be able to communicate with your application. This may depend on what configuration you have set:

- **"Standard protection"** or **"All deployments"** - This affects Inngest production and [branch environments](/docs-markdown/platform/environments).
- **"Only preview deployments"** - This affects [branch environments](/docs-markdown/platform/environments).

To work around this, you can either:

1. Disable deployment protection
2. Configure protection bypass (*Protection bypass may or may not be available depending on your pricing plan*)

### Configure protection bypass

To enable this, you will need to leverage Vercel's "[Protection Bypass for Automation](https://vercel.com/docs-markdown/deployment-protection/methods-to-bypass-deployment-protection/protection-bypass-automation)" feature. Here's how to set it up:

1. Enable "Protection Bypass for Automation" on your Vercel project
2. Copy your secret
3. Go to [the Vercel integration settings page in the Inngest dashboard](https://app.inngest.com/settings/integrations/vercel)
4. For each project that you would like to enable this for, add the secret in the "Deployment protection key" input. Inngest will now use this parameter to communicate with your application to bypass the deployment protection.

5) Trigger a re-deploy of your preview environment(s) (this resyncs your app to Inngest)

## Multiple apps in one single Vercel project

You can pass multiple paths by adding their path information to each Vercel project in the Vercel Integration‚Äôs settings page.

> **Callout:** You can also add paths to separate functions within the same app for bundle size issues or for running certain functions on the edge runtime for streaming.

## Manually syncing apps

While we strongly recommend our Vercel integration, you can still use Inngest by manually telling Inngest that you've deployed updated functions. You can sync your app [via the Inngest UI](/docs/apps/cloud#sync-a-new-app-in-inngest-cloud) or [via our API with a curl request](/docs-markdown/apps/cloud#curl-command).


--------------------------------------------------------------------------------
title: "Sending events"
source: "https://www.inngest.com/docs/events"
--------------------------------------------------------------------------------

# Sending events

To start, make sure you have [installed the Inngest SDK](/docs-markdown/sdk/overview).

In order to send events, you'll need to instantiate the `Inngest` client. We recommend doing this in a single file and exporting the client so you can import it anywhere in your app. In production, you'll need an event key, which [we'll cover below](#setting-an-event-key).

#### TypeScript

```ts {{ filename: 'inngest/client.ts' }}
import { Inngest } from "inngest";

export const inngest = new Inngest({ id: "acme-storefront-app" }); // Use your app's ID
```

Now with this client, you can send events from anywhere in your app. You can send a single event, or [multiple events at once](#sending-multiple-events-at-once).

```ts {{ filename: 'app/api/checkout/route.ts' }}
import { inngest } from "../inngest/client";

// This sends an event to Inngest.
await inngest.send({
  // The event name
  name: "storefront/cart.checkout.completed",
  // The event's data
  data: {
    cartId: "ed12c8bde",
    itemIds: ["9f08sdh84", "sdf098487", "0fnun498n"],
    account: {
      id: 123,
      email: "test@example.com",
    },
  },
});
```

> **Callout:** üëâ send() is an asynchronous method that returns a Promise. You should always use await or .then() to ensure that the method has finished sending the event to Inngest. Serverless functions can shut down very quickly, so skipping await may result in events failing to be sent.

#### Python

```python {{ filename: 'src/inngest/client.py' }}
import inngest

inngest_client = inngest.Inngest(app_id="acme-storefront-app")
```

Now with this client, you can send events from anywhere in your app. You can send a single event, or [multiple events at once](#sending-multiple-events-at-once).

```python {{ filename: 'src/api/checkout/route.py' }}
import inngest
from src.inngest.client import inngest_client

# This sends an event to Inngest.
await inngest_client.send(
  inngest.Event(
    name="storefront/cart.checkout.completed",
    data={
      "cartId": "ed12c8bde",
      "itemIds": ["9f08sdh84", "sdf098487", "0fnun498n"],
      "account": {
        "id": 123,
        "email": "test@example.com",
      },
    },
  )
)
```

> **Callout:** üëâ send() is meant to be called asynchronously using await. For synchronous code, use the send\_sync() method instead.

#### Go

```go {{ title: "Go" }}
import "github.com/inngest/inngestgo"

var client, err = inngestgo.NewClient(inngestgo.ClientOpts{
	AppID: "acme-storefront-app",
})
```

Now with this client, you can send events from anywhere in your app. You can send a single event, or [multiple events at once](#sending-multiple-events-at-once).

```go {{ title: "Go" }}
client.Send(context.Background(), inngestgo.Event{
	Name: "storefront/cart.checkout.completed",
	Data: map[string]any{
		"cartId":  "ed12c8bde",
		"itemIds": []string{"9f08sdh84", "sdf098487", "0fnun498n"},
		"account": map[string]any{
			"id":    123,
			"email": "test@example.com",
		},
	},
})
```

Sending this event, named `storefront/cart.checkout.completed`, to Inngest will do two things:

1. Automatically run any [functions](/docs-markdown/functions) that are triggered by this specific event, passing the event payload to the function's arguments.
2. Store the event payload in Inngest cloud. You can find this in the **Events** tab of the dashboard.

> **Callout:** üí° One event can trigger multiple functions, enabling you to consume a single event in multiple ways. This is different than traditional message queues where only one worker can consume a single message. Learn about the fan-out approach here.

## Setting an Event Key

In production, your application will need an "Event Key" to send events to Inngest. This is a secret key that is used to authenticate your application and ensure that only your application can send events to a given [environment](/docs-markdown/platform/environments) in your Inngest account.

You can learn [how to create an Event Key here](/docs-markdown/events/creating-an-event-key). Once you have a key, you can set it in one of two ways:

1. Set an `INNGEST_EVENT_KEY` environment variable with your Event Key. **This is the recommended approach.**
2. Pass the Event Key to the `Inngest` constructor as the `eventKey` option:

#### TypeScript

```ts {{ filename: 'inngest/client.ts' }}
import { Inngest } from "inngest";

// NOTE - It is not recommended to hard-code your Event Key in your code.
const inngest = new Inngest({ id: "your-app-id", eventKey: "xyz..." });
```

#### Python

```python {{ filename: 'src/inngest/client.py' }}
import inngest

# It is not recommended to hard-code your Event Key in your code.
inngest_client = inngest.Inngest(app_id="your-app-id", event_key="xyz...")
```

> **Callout:** Event keys are not required in local development with the Inngest Dev Server. You can omit them in development and your events will still be sent to the Dev Server.

## Event payload format

The event payload is a JSON object that must contain a `name` and `data` property.

Explore all events properties in the [Event payload format guide](/docs-markdown/features/events-triggers/event-format).

## Sending multiple events at once

You can also send multiple events in a single `send()` call. This enables you to send a batch of events very easily. You can send up to `512kb` in a single request which means you can send anywhere between 10 and 1000 typically sized payloads at once. This is the default and can be increased for your account.

#### TypeScript

```ts
await inngest.send([
  { name: "storefront/cart.checkout.completed", data: { ... } },
  { name: "storefront/coupon.used", data: { ... } },
  { name: "storefront/loyalty.program.joined", data: { ... } },
])
```

This is especially useful if you have an array of data in your app and you want to send an event for each item in the array:

```ts
// This function call might return 10s or 100s of items, so we can use map
// to transform the items into event payloads then pass that array to send:
const importedItems = await api.fetchAllItems();
const events = importedItems.map((item) => ({
  name: "storefront/item.imported",
  data: {
    ...item,
  }
}));
await inngest.send(events);
```

## Sending events from within functions

You can also send events from within your functions using `step.sendEvent()` to, for example, trigger other functions. Learn more about [sending events from within functions](/docs-markdown/guides/sending-events-from-functions). Within functions, `step.sendEvent()` wraps the event sending request within a `step` to ensure reliable event delivery and prevent duplicate events from being sent. We recommend using `step.sendEvent()` instead of `inngest.send()` within functions.

```ts
export default inngest.createFunction(
  { id: "user-onboarding" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    // Do something
    await step.sendEvent("send-activation-event", {
      name: "app/user.activated",
      data: { userId: event.data.userId },
    });
    // Do something else
  }
);
```

## Using Event IDs

Each event sent to Inngest is assigned a unique Event ID. These `ids` are returned from `inngest.send()` or `step.sendEvent()`. Event IDs can be used to look up the event in the Inngest dashboard or via [the REST API](https://api-docs.inngest.com/docs-markdown/inngest-api/pswkqb7u3obet-get-an-event). You can choose to log or save these Event IDs if you want to look them up later.

```ts
const { ids } = await inngest.send([
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e024befa68763f5b500" }
  },
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e08f29fb563c972b1f7" }
  },
]);
/**
 * ids = [
 *   "01HQ8PTAESBZPBDS8JTRZZYY3S",
 *   "01HQ8PTFYYKDH1CP3C6PSTBZN5"
 * ]
 */
```

#### Python

```python
await inngest_client.send([
  { name: "storefront/cart.checkout.completed", data: { ... } },
  { name: "storefront/coupon.used", data: { ... } },
  { name: "storefront/loyalty.program.joined", data: { ... } },
])
```

This is especially useful if you have an array of data in your app and you want to send an event for each item in the array:

```python
# This function call might return 10s or 100s of items, so we can use map
# to transform the items into event payloads then pass that array to send:
importedItems = await api.fetchAllItems();
events = [
  inngest.Event(name="storefront/item.imported", data=item)
  for item in importedItems
]
await inngest_client.send(events);
```

## Sending events from within functions

You can also send events from within your functions using `step.send_event()` to, for example, trigger other functions. Learn more about [sending events from within functions](/docs-markdown/guides/sending-events-from-functions). Within functions, `step.send_event()` wraps the event sending request within a `step` to ensure reliable event delivery and prevent duplicate events from being sent. We recommend using `step.send_event()` instead of `inngest.send()` within functions.

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="my_function",
    trigger=inngest.TriggerEvent(event="app/my_function"),
)
async def fn(ctx: inngest.Context) -> list[str]:
    return await ctx.step.send_event("send", inngest.Event(name="foo"))
```

## Using Event IDs

Each event sent to Inngest is assigned a unique Event ID. These `ids` are returned from `inngest.send()` or `step.sendEvent()`. Event IDs can be used to look up the event in the Inngest dashboard or via [the REST API](https://api-docs.inngest.com/docs-markdown/inngest-api/pswkqb7u3obet-get-an-event). You can choose to log or save these Event IDs if you want to look them up later.

```python
ids = await inngest_client.send(
    [
        inngest.Event(name="my_event", data={"msg": "Hello!"}),
        inngest.Event(name="my_other_event", data={"name": "Alice"}),
    ]
)
#
#  ids = [
#    "01HQ8PTAESBZPBDS8JTRZZYY3S",
#    "01HQ8PTFYYKDH1CP3C6PSTBZN5"
#  ]
# 
```

#### Go

```go
var events []any
events = append(events, inngestgo.Event{
	Name: "storefront/cart.checkout.completed",
	Data: data,
})

events = append(events, inngestgo.Event{
	Name: "storefront/coupon.used",
	Data: data,
})

events = append(events, inngestgo.Event{
	Name: "storefront/loyalty.program.joined",
	Data: data,
})

_, err = client.SendMany(ctx, events)
```

## Using Event IDs

Each event sent to Inngest is assigned a unique Event ID. These `ids` are returned from `client.SendMany()` . Event IDs can be used to look up the event in the Inngest dashboard or via [the REST API](https://api-docs.inngest.com/docs-markdown/inngest-api/pswkqb7u3obet-get-an-event). You can choose to log or save these Event IDs if you want to look them up later.

```go
var events []any
events = append(events, inngestgo.Event{
	Name: "storefront/cart.checkout.completed",
	Data: data,
})

events = append(events, inngestgo.Event{
	Name: "storefront/coupon.used",
	Data: data,
})

events = append(events, inngestgo.Event{
	Name: "storefront/loyalty.program.joined",
	Data: data,
})

_, err = client.SendMany(ctx, events)

//   ids = [
//     "01HQ8PTAESBZPBDS8JTRZZYY3S",
//     "01HQ8PTFYYKDH1CP3C6PSTBZN5",
//     "01HQ8PTAYNKDH1CP3R6PSTUKL4",
//   ]
```

## Send events via HTTP (Event API)

You can send events from any system or programming language with our API and an Inngest Event Key. The API accepts a single event payload or an array of event payloads.

To send an event to a specific [branch environment](/docs-markdown/platform/environments#branch-environments), set the `x-inngest-env` header to the name of your branch environment, for example: `x-inngest-env: feature/my-branch`.

```bash {{ title: 'cURL' }}
curl -X POST https://inn.gs/e/$INNGEST_EVENT_KEY \
  -H 'Content-Type: application/json' \
  --data '{
    "name": "user.signup",
    "data": {
      "userId": "645ea8289ad09eac29230442"
    }
  }'
```

```php
$url = "https://inn.gs/e/{$eventKey}";
$content = json_encode([
    "name" => "user.signup",
    "data" => [
      "userId" => "645ea8289ad09eac29230442",
    ],
]);

$curl = curl_init($url);
curl_setopt($curl, CURLOPT_HEADER, false);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_HTTPHEADER, ["Content-type: application/json"]);
curl_setopt($curl, CURLOPT_POST, true);
curl_setopt($curl, CURLOPT_POSTFIELDS, $content);

$json_response = curl_exec($curl);
$status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
if ($status != 200) {
    return [
        'status' => $status,
        'message' => "Error: call to URL $url failed with status $status, response $json_response, curl_error " . curl_error($curl) . ", curl_errno " . curl_errno($curl),
    ];
}

curl_close($curl);
$response = json_decode($json_response, true);
```

> **Note:** When using the dev server, use http\://localhost:8288/e/\<fake-key> as the endpoint. If self-hosting, replace with the url for your self-hosted instance.

The response will contain the `ids` of the events that were sent:

```json {{ title: 'Response' }}
{
  "ids": ["01H08W4TMBNKMEWFD0TYC532GG"],
  "status": 200
}
```

## Deduplication

Often, you may need to prevent duplicate events from being processed by Inngest. If your system could possibly send the same event more than once, you will want to ensure that it does not run functions more than once.

To prevent duplicate function runs from events, you can add an `id` parameter to the event payload. Once Inngest receives an event with an `id`, any events sent with the same `id` will be ignored, regardless of the event's payload.

#### TypeScript

```ts
await inngest.send({
  // Your deduplication id must be specific to this event payload.
  // Use something that will not be used across event types, not a generic value like cartId
  id: "cart-checkout-completed-ed12c8bde",
  name: "storefront/cart.checkout.completed",
  data: {
    cartId: "ed12c8bde",
    // ...the rest of the payload's data...
  }
});
```

#### Python

```python
await inngest_client.send(
  inngest.Event(
    name="storefront/cart.checkout.completed",
    id="cart-checkout-completed-ed12c8bde",
    data={"cartId": "ed12c8bde"},
  )
)
```

#### Go

```go {{ title: "Go" }}
_, err := client.Send(context.Background(), inngestgo.Event{
	Name: "storefront/cart.checkout.completed",
	ID:   inngestgo.StrPtr("cart-checkout-completed-ed12c8bde"),
	Data: map[string]any{
		"cartId":  "ed12c8bde",
		"itemIds": []string{"9f08sdh84", "sdf098487", "0fnun498n"},
		"account": map[string]any{
			"id":    123,
			"email": "test@example.com",
		},
	},
})
```

Learn more about this in the [handling idempotency guide](/docs-markdown/guides/handling-idempotency).

> **Callout:** üí° Deduplication prevents duplicate function runs for 24 hours from the first event.

> **Callout:** The id is global across all event types, so make sure your id isn't a value that will be shared across different event types.For example, for two events like storefront/item.imported and storefront/item.deleted, do not use the item's id (9f08sdh84) as the event deduplication id. Instead, combine the item's id with the event type to ensure it's specific to that event (e.g. item-imported-9f08sdh84).

## Further reading

- [Creating an Event Key](/docs-markdown/events/creating-an-event-key)
- [TypeScript SDK Reference: Send events](/docs-markdown/reference/events/send)
- [Python SDK Reference: Send events](/docs-markdown/reference/python/client/send)
- [Go SDK Reference: Send events](https://pkg.go.dev/github.com/inngest/inngestgo#Client)


--------------------------------------------------------------------------------
title: "Creating an Event Key"
source: "https://www.inngest.com/docs/events/creating-an-event-key"
--------------------------------------------------------------------------------

# Creating an Event Key

‚ÄúEvent Keys‚Äù are unique keys that allow applications to send (aka publish) events to Inngest. When using Event Keys with the [Inngest SDK](/docs-markdown/events), you can configure the `Inngest` client in 2 ways:

1. Setting the key as an [`INNGEST_EVENT_KEY`](/docs-markdown/sdk/environment-variables#inngest-event-key) environment variable in your application\*
2. Passing the key as an argument

```jsx
// Recommended: Set an INNGEST_EVENT_KEY environment variable for automatic configuration:
const inngest = new Inngest({ name: "Your app name" });

// Or you can pass the eventKey explicitly to the constructor:
const inngest = new Inngest({ name: "Your app name", eventKey: "xyz..." });

// With the Event Key, you're now ready to send data:
await inngest.send({ ... })
```

\* Our [Vercel integration](/docs-markdown/deploy/vercel) automatically sets the [`INNGEST_EVENT_KEY`](/docs-markdown/sdk/environment-variables#inngest-event-key) as an environment variable for you

> **Callout:** üôã Event Keys should be unique to a given environment (e.g. production, branch environments) and a specific application (your API, your mobile app, etc.). Keeping keys separated by application makes it easier to manage keys and rotate them when necessary.

> **Callout:** üîê Securing Event Keys - As Event Keys are used to send data to your Inngest environment, you should take precautions to secure your keys. Avoid storing them in source code and store the keys as secrets in your chosen platform when possible.

## Creating a new Event Key

From the Inngest Cloud dashboard, Event Keys are listed in the "Manage" tab:

1. Click on "Manage" ([direct link](https://app.inngest.com/env/production/manage/keys))
2. Click the "+ Create Event Key" button at the top right
3. Update the Event Key's name to something descriptive and click "Save changes"
4. Copy the newly created key using the ‚ÄúCopy‚Äù button:

![A newly created Event Key in the Inngest Cloud dashboard](/assets/docs-markdown/creating-an-event-key/new-event-key-2023.png)

üéâ You can now use this event key with the Inngest SDK to send events directly from any codebase. You can also:

- Rename your event key at any time using the ‚ÄúName‚Äù field so you and your team can identify it later
- Delete the event key when your key is no longer needed
- Filter events by name or IP addresses for increased control and security

> **Callout:** ‚ö†Ô∏è While it is possible to use Event Keys to send events from the browser, this practice presents risks as anyone inspecting your client side code will be able to read your key and send events to your Inngest environment. If you'd like to send events from the client, we recommend creating an API endpoint or edge function to proxy the sending of events.


--------------------------------------------------------------------------------
title: "Examples"
source: "https://www.inngest.com/docs/examples"
--------------------------------------------------------------------------------

# Examples

**'Durable Endpoints'**: [Make any API endpoint durable with automatic retries.]("/docs-markdown/examples/durable-endpoints")

**'AI Agents and RAG'**: [Use Inngest to build AI agents and RAG.]("/docs/examples/ai-agents-and-rag")

**'Email Sequence'**: [Build a dynamic drip campaign based on a user's behavior.]("/docs/examples/email-sequence")

**'Scheduling a one-off function'**: [Schedule a function to run at a specific time.]("/docs/examples/scheduling-one-off-function")

**'Fetch run status and output'**: [Get the result of a run using an Event ID.]("/docs/examples/fetch-run-status-and-output")

**'Track all function failures in Datadog'**: [Send all function failures to Datadog (or similar) for monitoring.]("/docs/examples/track-failures-in-datadog")

**'Fetch'**: [Make durable HTTP requests within an Inngest function.]("/docs-markdown/examples/fetch")

**'Realtime'**: [Use Realtime to stream updates from one to multiple Inngest functions or to implement a Human in the Loop mechanism.]("/docs/examples/realtime")

**'Setup OpenTelemetry with Inngest'**: [Forward your application's OpenTelemetry traces to Inngest Traces]("/docs/examples/open-telemetry")

## Middleware

**'Cloudflare Workers & Hono environment variables'**: [Access environment variables and other Cloudflare bindings within Inngest functions when using Workers or Hono.]("/docs/examples/middleware/cloudflare-workers-environment-variables")


--------------------------------------------------------------------------------
title: "AI Agents and RAG"
source: "https://www.inngest.com/docs/examples/ai-agents-and-rag"
--------------------------------------------------------------------------------

# AI Agents and RAG

Inngest offers tools to support the development of AI-powered applications. Whether you're building AI agents, automating tasks, or orchestrating and managing AI workflows, Inngest provides features that accommodate various needs and requirements, such as concurrency, debouncing, or throttling (see ["Related Concepts"](#related-concepts)).

## Quick Snippet

Below is an example of a RAG workflow (from this [example app](https://github.com/inngest/inngest-demo-app/)). This asynchronous Inngest function summarizes content via GPT-4 by following these steps:

- Query a vector database for relevant content.
- Retrieve a transcript from an S3 file.
- Combine the transcript and queried content to generate a summary using GPT-4.
- Save the summary to a database and sends a notification to the client.

The function uses [Inngest steps](/docs-markdown/learn/inngest-steps) to guarantee automatic retries on failure.

```typescript {{ title: "./inngest/functions.ts" }}
export const summarizeContent = inngest.createFunction(
  { name: 'Summarize content via GPT-4', id: 'summarize-content' },
  { event: 'ai/summarize.content' },
  async ({ event, step, attempt }) => {
    const results = await step.run('query-vectordb', async () => {
      return {
        matches: [
          {
            id: 'vec3',
            score: 0,
            values: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],
            text: casual.sentences(3),
          },
          {
            id: 'vec4',
            score: 0.0799999237,
            values: [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],
            text: casual.sentences(3),
          },
          {
            id: 'vec2',
            score: 0.0800000429,
            values: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],
            text: casual.sentences(3),
          },
        ],
        namespace: 'ns1',
        usage: { readUnits: 6 },
      };
    });

    const transcript = await step.run('read-s3-file', async () => {
      return casual.sentences(10);
    });

    // We can globally share throttle limited functions like this using invoke
    const completion = await step.invoke('generate-summary-via-gpt-4', {
      function: chatCompletion,
      data: {
        messages: [
          {
            role: 'system',
            content:
              'You are a helpful assistant that summaries content for product launches.',
          },
          {
            role: 'user',
            content: `Question: Summarize my content: \n${transcript}. \nInformation: ${results.matches
              .map((m) => m.text)
              .join('. ')}`,
          },
        ],
      },
    });
    // You might use the response like this:
    const summary = completion.choices[0].message.content;

    await step.run('save-to-db', async () => {
      return casual.uuid;
    });

    await step.run('websocket-push-to-client', async () => {
      return casual.uuid;
    });
    return { success: true, summaryId: casual.uuid };
  }
);
```

## App examples

Here are apps that use Inngest to power AI workflows:

## Resources

Check the resources below to learn more about working with AI using Inngest:

## Related concepts

- [Concurrency](/docs/guides/concurrency): control the number of steps executing code at any one time.
- [Debouncing](/docs-markdown/guides/debounce): delay function execution until a series of events are no longer received.
- [Prioritization](/docs-markdown/guides/priority): dynamically execute some runs ahead or behind others based on any data.
- [Rate limiting](/docs-markdown/guides/rate-limiting): limit on how many function runs can start within a time period.
- [Steps](/docs-markdown/reference/functions/step-run): individual tasks within a function that can be executed independently with a guaranteed retrial.
- [Throttling](/docs-markdown/guides/throttling): specify how many function runs can start within a time period.


--------------------------------------------------------------------------------
title: "Cleanup after function cancellation"
source: "https://www.inngest.com/docs/examples/cleanup-after-function-cancellation"
--------------------------------------------------------------------------------

# Cleanup after function cancellation

When function runs are cancelled, you may want to perform some sort of post-cancellation code. This example will use the [`inngest/function.cancelled`](/docs-markdown/reference/system-events/inngest-function-cancelled) system event.

Whether your function run is cancelled via [`cancelOn` event](/docs-markdown/features/inngest-functions/cancellation/cancel-on-events), [REST API](/docs-markdown/guides/cancel-running-functions) or [bulk cancellation](/docs-markdown/platform/manage/bulk-cancellation), this method will work the same.

## Quick snippet

Here is an Inngest function and a corresponding function that will be run whenever the original function is cancelled. This uses the function trigger's `if` parameter to filter the `inngest/function.cancelled` event to only be triggered for the original function.

```ts
const inngest = new Inngest({ id: "newsletter-app" });

// This is our "import" function that will get cancelled
export const importAllContacts = inngest.createFunction(
  {
    id: "import-all-contacts",
    cancelOn: [{ event: "contacts/import.cancelled", if: "async.data.importId == event.data.importId" }]
  },
  { event: "contacts/import.requested" },
  async ({ event, step  }) => {
    // This is a long running function
  }
)

// This function will be run only when the matching function_id has a run that is cancelled
export const cleanupCancelledImport = inngest.createFunction(
  {
    name: "Cleanup cancelled import",
    id: "cleanup-cancelled-import"
  },
  {
    event: "inngest/function.cancelled",
    // The function ID is a hyphenated slug of the App ID w/ the functions" id
    if: "event.data.function_id == 'newsletter-app-import-all-contacts'"
  },
  async ({ event, step, logger }) => {
    // This code will execute after your function is cancelled

    // The event that triggered our original function run is passed nested in our event payload
    const originalTriggeringEvent = event.data.event;
    logger.info(`Import was cancelled: ${originalTriggeringEvent.data.importId}`)
  }
);
```

An example cancellation event payload:

```json
{
  "name": "inngest/function.cancelled",
  "data": {
    "error": {
      "error": "function cancelled",
      "message": "function cancelled",
      "name": "Error"
    },
    "event": {
      "data": {
        "importId": "bdce1b1b-6e3a-43e6-84c2-2deb559cdde6"
      },
      "id": "01JDJK451Y9KFGE5TTM2FHDEDN",
      "name": "contacts/import.requested",
      "ts": 1732558407003,
      "user": {}
    },
    "events": [
      {
        "data": {
          "importId": "bdce1b1b-6e3a-43e6-84c2-2deb559cdde6"
        },
        "id": "01JDJK451Y9KFGE5TTM2FHDEDN",
        "name": "contacts/import.requested",
        "ts": 1732558407003,
        "user": {}
      }
    ],
    "function_id": "newsletter-app-import-all-contacts",
    "run_id": "01JDJKGTGDVV4DTXHY6XYB7BKK"
  },
  "id": "01JDJKH1S5P2YER8PKXPZJ1YZJ",
  "ts": 1732570023717
}
```

## More context

Check the resources below to learn more about building email sequences with Inngest.


--------------------------------------------------------------------------------
title: "Durable Endpoints"
source: "https://www.inngest.com/docs/examples/durable-endpoints"
--------------------------------------------------------------------------------

# Durable Endpoints

[Durable Endpoints](/docs-markdown/learn/durable-endpoints) let you add durability to regular HTTP handlers without separate function definitions or event triggers. You wrap your existing API route with `inngest.endpoint()` and use `step.run()` inline to get automatic retries and memoization for each step.

This is useful when you want your endpoint to orchestrate multiple operations (like booking a flight, processing a payment, and sending a confirmation) and guarantee that each step completes exactly once, even if the handler crashes or restarts partway through.

## How it differs from traditional Inngest

With the traditional approach, you define separate functions triggered by events. Durable Endpoints flip this: you keep your HTTP handlers and make them durable inline.

| Traditional Inngest              | Durable Endpoints           |
| -------------------------------- | --------------------------- |
| Define separate functions        | Inline in HTTP handlers     |
| Trigger via events               | Direct HTTP calls           |
| `inngest.createFunction()`       | `inngest.endpoint()`        |
| `{ event, step }` from context   | Import `step` directly      |
| Separate `/api/inngest` endpoint | No separate endpoint needed |

## Setting up the client

First, configure your Inngest client with the endpoint adapter for your framework:

```typescript {{ title: "Next.js" }}
import { Inngest } from "inngest";
import { endpointAdapter } from "inngest/next";

const inngest = new Inngest({
  id: "my-app",
  endpointAdapter,
});
```

```typescript {{ title: "Bun" }}
import { Inngest } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({
  id: "my-app",
  endpointAdapter,
});
```

The `endpointAdapter` tells Inngest how to interact with your framework's request/response model. Import it from `"inngest/next"` for Next.js or `"inngest/edge"` for Bun. This is the only configuration needed, no separate `/api/inngest` serve endpoint required.

## A simple durable endpoint

With the client set up, you can turn any route handler into a durable endpoint. Each `step.run()` call is memoized: if the handler is re-executed (due to a retry or crash recovery), completed steps are skipped and their previous results are reused.

```typescript {{ title: "Next.js" }}
import { step } from "inngest";
import { inngest } from "@/inngest/client";
import { NextRequest } from "next/server";

export const POST = inngest.endpoint(async (req: NextRequest) => {
  const { userId, data } = await req.json();

  // Step 1: Validate and enrich the data
  const enriched = await step.run("enrich-data", async () => {
    const user = await db.users.find(userId);
    return { ...data, account: user.accountId };
  });

  // Step 2: Process the enriched data
  const result = await step.run("process", async () => {
    return await processData(enriched);
  });

  // Step 3: Send notification
  await step.run("notify", async () => {
    await sendNotification(userId, result);
  });

  return Response.json({ success: true, result });
});
```

```typescript {{ title: "Bun" }}
import { Inngest, step } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({ id: "my-app", endpointAdapter });

Bun.serve({
  port: 3000,
  routes: {
    "/process": inngest.endpoint(async (req) => {
      const { userId, data } = await req.json();

      // Step 1: Validate and enrich the data
      const enriched = await step.run("enrich-data", async () => {
        const user = await db.users.find(userId);
        return { ...data, account: user.accountId };
      });

      // Step 2: Process the enriched data
      const result = await step.run("process", async () => {
        return await processData(enriched);
      });

      // Step 3: Send notification
      await step.run("notify", async () => {
        await sendNotification(userId, result);
      });

      return new Response(JSON.stringify({ success: true, result }));
    }),
  },
});
```

If the handler crashes after "enrich-data" completes but before "process" finishes, Inngest re-invokes the handler. The first step returns its cached result instantly, and execution picks up at the second step. No duplicate work, no lost progress.

## Multi-step orchestration with retries

Real-world workflows often involve multiple external systems that can fail independently. Durable Endpoints handle this naturally since each step retries on its own without re-running previous steps.

Let's take the following trip booking demo that searches for flights, reserves a seat, processes payment, and confirms the booking:

The Durable Endpoint implementation will look as follows:

```typescript {{ title: "Next.js" }}
import { step } from "inngest";
import { inngest } from "@/inngest/client";
import { NextRequest } from "next/server";

export const GET = inngest.endpoint(async (req: NextRequest) => {
  const url = new URL(req.url);
  const origin = url.searchParams.get("origin") || "NYC";
  const destination = url.searchParams.get("destination") || "LAX";
  const date = url.searchParams.get("date") || new Date().toISOString().split("T")[0];

  // Step 1: Search for available flights
  const availability = await step.run("search-availability", async () => {
    const flights = await searchFlights(origin, destination, date);
    return { flights };
  });

  // Step 2: Reserve the best flight
  // If the seat lock times out, Inngest automatically retries this step
  // without re-running the search
  const reservation = await step.run("reserve-flight", async () => {
    const best = availability.flights[0];
    return await reserveSeat(best.flightNumber, "14A");
  });

  // Step 3: Process payment
  const payment = await step.run("process-payment", async () => {
    return await chargeCard(reservation.price, reservation.pnr);
  });

  // Step 4: Confirm the booking
  const confirmation = await step.run("confirm-booking", async () => {
    return await confirmReservation(reservation.reservationId);
  });

  return Response.json({
    success: true,
    trip: { origin, destination, date },
    reservation,
    payment,
    confirmation,
  });
});
```

```typescript {{ title: "Bun" }}
import { Inngest, step } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({ id: "trip-booker", endpointAdapter });

Bun.serve({
  port: 3000,
  routes: {
    "/api/booking": inngest.endpoint(async (req) => {
      const url = new URL(req.url);
      const origin = url.searchParams.get("origin") || "NYC";
      const destination = url.searchParams.get("destination") || "LAX";
      const date = url.searchParams.get("date") || new Date().toISOString().split("T")[0];

      // Step 1: Search for available flights
      const availability = await step.run("search-availability", async () => {
        const flights = await searchFlights(origin, destination, date);
        return { flights };
      });

      // Step 2: Reserve the best flight
      // If the seat lock times out, Inngest automatically retries this step
      // without re-running the search
      const reservation = await step.run("reserve-flight", async () => {
        const best = availability.flights[0];
        return await reserveSeat(best.flightNumber, "14A");
      });

      // Step 3: Process payment
      const payment = await step.run("process-payment", async () => {
        return await chargeCard(reservation.price, reservation.pnr);
      });

      // Step 4: Confirm the booking
      const confirmation = await step.run("confirm-booking", async () => {
        return await confirmReservation(reservation.reservationId);
      });

      return new Response(JSON.stringify({
        success: true,
        trip: { origin, destination, date },
        reservation,
        payment,
        confirmation,
      }));
    }),
  },
});
```

Each step in this workflow is independently durable:

- If the seat reservation fails with a timeout, only that step retries. The flight search results are preserved.
- If the payment step fails, the reservation is still held and the payment retries without re-reserving.
- If the entire server crashes after payment succeeds, the handler resumes at the confirmation step.

## Running steps in parallel

When steps don't depend on each other, you can run them in parallel using `Promise.all()`. Each parallel step is still independently durable and retried.

```typescript {{ title: "Next.js" }}
import { step } from "inngest";
import { inngest } from "@/inngest/client";
import { NextRequest } from "next/server";

export const POST = inngest.endpoint(async (req: NextRequest) => {
  const { flightId, hotelId, carId } = await req.json();

  // Book flight, hotel, and car rental in parallel
  // Each step retries independently if it fails
  const [flight, hotel, car] = await Promise.all([
    step.run("book-flight", async () => {
      return await bookFlight(flightId);
    }),
    step.run("book-hotel", async () => {
      return await bookHotel(hotelId);
    }),
    step.run("book-car", async () => {
      return await bookCarRental(carId);
    }),
  ]);

  // Send a single confirmation after all bookings succeed
  await step.run("send-confirmation", async () => {
    await sendTripConfirmation({
      flight,
      hotel,
      car,
    });
  });

  return Response.json({
    success: true,
    bookings: { flight, hotel, car },
  });
});
```

```typescript {{ title: "Bun" }}
import { Inngest, step } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({ id: "my-app", endpointAdapter });

Bun.serve({
  port: 3000,
  routes: {
    "/api/book-trip": inngest.endpoint(async (req) => {
      const { flightId, hotelId, carId } = await req.json();

      // Book flight, hotel, and car rental in parallel
      // Each step retries independently if it fails
      const [flight, hotel, car] = await Promise.all([
        step.run("book-flight", async () => {
          return await bookFlight(flightId);
        }),
        step.run("book-hotel", async () => {
          return await bookHotel(hotelId);
        }),
        step.run("book-car", async () => {
          return await bookCarRental(carId);
        }),
      ]);

      // Send a single confirmation after all bookings succeed
      await step.run("send-confirmation", async () => {
        await sendTripConfirmation({
          flight,
          hotel,
          car,
        });
      });

      return new Response(JSON.stringify({
        success: true,
        bookings: { flight, hotel, car },
      }));
    }),
  },
});
```

If the hotel booking fails, it retries independently while the flight and car rental results are preserved. Once all three succeed, the confirmation step runs.

## Try it out

The Trip Booker example is a complete Next.js app that demonstrates all of these patterns with a real UI, progress tracking, and intentional failures to show retry behavior in action.

**"Explore the full Trip Booker example"**: [Clone this example locally to run it and explore the full source code.](https://github.com/inngest/inngest-js/tree/main/examples/durable-endpoints-trip-booker#readme)

**"Explore the full DeepResearch demo"**: [Explore a more advanced example with a DeepResearch interface entirely built with Durable Endpoints.](https://github.com/inngest/inngest-js/tree/main/examples/durable-endpoints-deepresearch#readme)


--------------------------------------------------------------------------------
title: "Email Sequence"
source: "https://www.inngest.com/docs/examples/email-sequence"
--------------------------------------------------------------------------------

# Email Sequence

A drip campaign is usually based on your user's behavior.

Let's say you want to create the following campaign:

- Send every user a welcome email when they join.
  - If a user received an email: wait a day and then follow-up with pro user tips meant for highly engaged users.
  - Otherwise: wait for up to three days and then send them the default trial offer, but only if the user hasn't already upgraded their plan in the meantime.

This page provides an overview on how to use Inngest to build reliable marketing campaigns, as well as all the related materials to this feature.

## Quick Snippet

Below is an example of how such a campaign would look like:

```javascript
const signupDripCampaign = inngest.createFunction(
  { id: "signup-drip-campaign" },
  { event: "app/signup.completed" },
  async ({ event, step }) => {
    const { user } = event.data;
    const { email, first_name } = user
    const welcome = "Welcome to ACME";

    const { id: emailId } = await step.run("welcome-email", async () => {
      return await sendEmail(
        email,
        welcome,
        <div>
          <h1>Welcome to ACME, {user.firstName}</h1>
        </div>
      );
    });

    // Wait up to 3 days for the user open the email and click any link in it
    const clickEvent = await step.waitForEvent("wait-for-engagement", {
      event: "resend/email.clicked",
      if: `async.data.email_id == ${emailId}`,
      timeout: "3 days",
    });

    // if the user clicked the email, send them power user tips
    if (clickEvent) {
      await step.sleep("delay-power-tips-email", "1 day");
      await step.run("send-power-user-tips", async () => {
        await sendEmail(
          email,
          "Supercharge your ACME experience",
          <h1>
            Hello {firstName}, here are tips to get the most out of ACME
          </h1>
        );
      });

      // wait one more day before sending the trial offer
      await step.sleep("delay-trial-email", "1 day");
    }

    // check that the user is not already on the pro plan
    const dbUser = db.users.byEmail(email);

    if (dbUser.plan !== "pro") {
      // send them a free trial offer
      await step.run("trial-offer-email", async () => {
        await sendEmail(
          email,
          "Free ACME Pro trial",
          <h1>
            Hello {firstName}, try our Pro features for 30 days for free
          </h1>
        );
      });
    }
  }
);
```

## Code examples

Here are apps which use Inngest to power email campaigns.

## More context

Check the resources below to learn more about building email sequences with Inngest.

## How it works

With Inngest, you define functions or workflows using its SDK right in your own codebase and serve them through an HTTP endpoint in your application. Inngest uses this endpoint to download the function definitions and to execute them.

When a specific event is triggered, Inngest takes care of reliably executing the function (or functions).

In case of failure, Inngest will retry until it succeeds or you will see the failure on the Inngest dashboard, which you can debug and then retrigger so no data is lost.

## Related concepts

- [Steps](/docs-markdown/learn/inngest-steps)
- [Fan-out jobs](/docs-markdown/guides/fan-out-jobs)
- [Delayed functions](/docs-markdown/guides/delayed-functions#delaying-jobs)
- [Scheduled functions](/docs-markdown/guides/scheduled-functions)


--------------------------------------------------------------------------------
title: "Fetch run status and output"
source: "https://www.inngest.com/docs/examples/fetch-run-status-and-output"
--------------------------------------------------------------------------------

# Fetch run status and output

Inngest provides a way to fetch the status and output of a function run using [the REST API](https://api-docs.inngest.com/docs-markdown/inngest-api/1j9i5603g5768-introduction). This is useful when:

- You want to check the status or output of a given run.
- You want to display the status of a function run in your application, for example, in a user dashboard.

This page provides a quick example of how to fetch the status and output of a function run using the Inngest API.

## Quick Snippet

Here is a basic function that processes a CSV file and returns the number of items processed:

```typescript
const processCSV = inngest.createFunction(
  { id: "process-csv-upload" },
  { event: "imports/csv.uploaded" },
  async ({ event, step }) => {
    // CSV processing logic omitted for the sake of the example
    return {
      status: "success",
      processedItems: results.length,
      failedItems: failures.length,
    }
  }
);
```

### Triggering the function

To trigger this function, you will send an event `"imports/csv.uploaded"` using `inngest.send()` with whatever payload data you need. The `inngest.send()` function returns an array of Event IDs that you will use to fetch the status and output of the function run.

```typescript
const { ids } = await inngest.send({
  name: "imports/csv.uploaded",
  data: {
    file: "http://s3.amazonaws.com/acme-uploads/user_0xp3wqz7vumcvajt/JVLO6YWS42IXEIGO.csv",
    userId: "user_0xp3wqz7vumcvajt",
  },
});
// ids = ["01HWAVEB858VPPX47Z65GR6P6R"]
```

### Fetching triggered function status and output

Using the REST API, we can use the Event ID to fetch all runs triggered by that event using the [event's runs endpoint](https://api-docs.inngest.com/docs-markdown/inngest-api/yoyeen3mu7wj0-list-event-function-runs):

```bash
https://api.inngest.com/v1/events/01HWAVEB858VPPX47Z65GR6P6R/runs
```

To query this, we can use a simple `fetch` request using our signing key to authenticate with the API. Here, we'll wrap this in a re-usable function:

```typescript
async function getRuns(eventId) {
  const response = await fetch(`https://api.inngest.com/v1/events/${eventId}/runs`, {
    headers: {
      Authorization: `Bearer ${process.env.INNGEST_SIGNING_KEY}`,
    },
  });
  const json = await response.json();
  return json.data;
}
```

We can now use the Event ID to fetch the status and output of the function run. The `getRuns` function will return an array of runs as events can trigger multiple runs via [fan-out](/docs-markdown/guides/fan-out-jobs). We'll consider that this event only triggers a single function:

```typescript
const runs = await getRuns("01HWAVEB858VPPX47Z65GR6P6R");
console.log(runs[0]);
/*
{
  run_id: '01HWAVJ8ASQ5C3FXV32JS9DV9Q',
  run_started_at: '2024-04-25T14:46:45.337Z',
  function_id: '6219fa64-9f58-41b6-95ec-a45c7172fa1e',
  function_version: 12,
  environment_id: '6219fa64-9f58-41b6-95ec-a45c7172fa1e',
  event_id: '01HWAVEB858VPPX47Z65GR6P6R',
  status: 'Completed',
  ended_at: '2024-04-25T14:46:46.896Z',
  output: {
    status: "success",
    processedItems: 98,
    failedItems: 2,
  }
}
*/
```

If we want to trigger the function then immediately await it's output in the same code, we can wrap our `getRuns` to poll until the status is `Completed`:

```typescript
async function getRunOutput(eventId) {
  let runs = await getRuns(eventId);
  while (runs[0].status !== "Completed") {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    runs = await getRuns(eventId);
    if (runs[0].status === "Failed" || runs[0].status === "Cancelled") {
      throw new Error(`Function run ${runs[0].status}`);
    }
  }
  return runs[0];
}
```

### Putting it all together

Brining this all together, we can now trigger the function and await the output:

```typescript
const { ids } = await inngest.send({
  name: "imports/csv.uploaded",
  data: {
    file: "http://s3.amazonaws.com/acme-uploads/user_0xp3wqz7vumcvajt/JVLO6YWS42IXEIGO.csv",
    userId: "user_0xp3wqz7vumcvajt",
  },
});

const run = await getRunOutput(ids[0]);
console.log(run.output);
/*
{
  status: "success",
  processedItems: 98,
  failedItems: 2,
}
*/
```

## More context

Check the resources below to learn more about working with the Inngest REST API.

## Related concepts

- [Fan-out jobs](/docs/guides/fan-out-jobs)


--------------------------------------------------------------------------------
title: "Fetch: performing API requests or fetching data&#x20;"
source: "https://www.inngest.com/docs/examples/fetch"
--------------------------------------------------------------------------------

# Fetch: performing API requests or fetching data&#x20;

The Inngest TypeScript SDK provides a `step.fetch()` API and a `fetch()` utility, enabling you to make requests to third-party APIs or fetch data in a durable way by offloading them to the Inngest Platform.

For more information on how Fetch works, see the [Fetch documentation](/docs-markdown/features/inngest-functions/steps-workflows/fetch).

## Getting started with `step.fetch()`

The `step.fetch()` API enables you to make durable HTTP requests while offloading them to the Inngest Platform, saving you compute and improving reliability:

```ts {{ title: "src/inngest/functions.ts" }}
import { inngest } from "./client";

export const retrieveTextFile = inngest.createFunction(
  { id: "retrieveTextFile" },
  { event: "textFile/retrieve" },
  async ({ step }) => {
    // The fetching of the text file is offloaded to the Inngest Platform
    const response = await step.fetch(
      "https://example-files.online-convert.com/document/txt/example.txt"
    );

    // The Inngest function run is resumed when the HTTP request is complete
    await step.run("extract-text", async () => {
      const text = await response.text();
      const exampleOccurences = text.match(/example/g);
      return exampleOccurences?.length;
    });
  }
);
```

`step.fetch()` takes the same arguments as the [native `fetch` API](https://developer.mozilla.org/en-US/docs-markdown/Web/API/Fetch_API/Using_Fetch).

**"Clone this example on GitHub"**: [Check out this complete step.fetch() example on GitHub.]("https://github.com/inngest/inngest-js/tree/main/examples/node-step-fetch/")

## Parallelize HTTP requests with `step.fetch()`

`step.fetch()` shares all the benefits of `step.run()`, including the ability to parallelize requests using `Promise.all()`:

```typescript
const processFiles = inngest.createFunction(
  { id: "process-files", concurrency: 10 },
  { event: "files/process" },
  async ({ step, event }) => {
    // All requests will be offloaded and processed in parallel while matching the concurrency limit
    const responses = await Promise.all(event.data.files.map(async (file) => {
      return step.fetch(`https://api.example.com/files/${file.id}`)
    }))

    // Your Inngest function is resumed here with the responses
    await step.run("process-file", async (file) => {
      const body = await response.json()
      // body.files
    })
  }
)
```

Note that `step.fetch()`, like all other `step` APIs, matches your function's configuration such as [concurrency](/docs-markdown/guides/concurrency) or [throttling](/docs-markdown/guides/throttling).

## Make 3rd party library HTTP requests durable with the `fetch()` utility

Inngest's `fetch()` utility can be passed as a custom fetch handler to make all the requests made by a 3rd party library durable.

For example, you can pass the `fetch()` utility to the AI SDK or the OpenAI libraries:

> **Callout:** When using the fetch() utility with the AI SDK, you need to disable the AI SDK's built-in retry mechanism and let Inngest handle retries instead.Below you can see we are using the fetch() utility with the AI SDK and disabling the AI SDK's built-in retry mechanism by setting maxRetries: 0.

```typescript {{ title: "AI SDK" }}
import { fetch as inngestFetch } from 'inngest';
import { generateText } from 'ai';
import { createAnthropic } from '@ai-sdk/anthropic';

// Pass the Inngest fetch utility to the AI SDK's model constructor:
const anthropic = createAnthropic({
  fetch: inngestFetch,
});

const weatherFunction = inngest.createFunction(
  { id: "weather-function" },
  { event: "weather/get" },
  async ({ step }) => {
    // This request is offloaded to the Inngest platform
    // and it also retries automatically if it fails!
    const response = await generateText({
      model: anthropic('claude-3-5-sonnet-20240620'),
      prompt: `What's the weather in London?`,
      maxRetries: 0,
    });
  }
)
```

```typescript {{ title: "OpenAI SDK" }}
import { fetch } from "inngest";
import OpenAI from 'openai';

const client = new OpenAI({ fetch });

// use the global fetch
const completion = await client.chat.completions.create({
  model: "gpt-3.5-turbo",
  messages: [{ role: "user", content: "Hello, world!" }],
});

const weatherFunction = inngest.createFunction(
  { id: "weather-function" },
  { event: "weather/get" },
  async ({ step }) => {
    // The OpenAI request is automatically offloaded to the Inngest Platform
    const completion = await client.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: "What's the weather in London?" }],
    });
  }
)
```


--------------------------------------------------------------------------------
title: "Cloudflare Workers environment variables and context"
source: "https://www.inngest.com/docs/examples/middleware/cloudflare-workers-environment-variables"
--------------------------------------------------------------------------------

# Cloudflare Workers environment variables and context

Cloudflare Workers does not set environment variables a global object like Node.js does with `process.env`. Workers [binds environment variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) to the worker's special `fetch` event handler thought a specific `env` argument.

This means accessing environment variables within Inngest function handlers isn't possible without explicitly passing them through from the worker event handler to the Inngest function handler.

We can accomplish this by use the [middleware](/docs-markdown/features/middleware) feature for Workers or when using [Hono](/docs-markdown/learn/serving-inngest-functions#framework-hono).

## Creating middleware

You can create middleware which extracts the `env` argument from the Workers `fetch` event handler arguments for either Workers or Hono:

1. Use `onFunctionRun`'s `reqArgs` array to get the `env` object and, optionally, cast a type.
2. Return the `env` object within the special `ctx` object of `transformInput` lifecycle method.

```ts {{ title: "Workers" }}
import { Inngest, InngestMiddleware } from 'inngest';

const bindings = new InngestMiddleware({
  name: 'Cloudflare Workers bindings',
  init({ client, fn }) {
    return {
      onFunctionRun({ ctx, fn, steps, reqArgs }) {
        return {
          transformInput({ ctx, fn, steps }) {
            // reqArgs is the array of arguments passed to the Worker's fetch event handler
            // ex. fetch(request, env, ctx)
            // We cast the argument to the global Env var that Wrangler generates:
            const env = reqArgs[1] as Env;
            return {
              ctx: {
                // Return the env object to the function handler's input args
                env,
              },
            };
          },
        };
      },
    };
  },
});

// Include the middleware when creating the Inngest client
export const inngest = new Inngest({
  id: 'my-workers-app',
  middleware: [bindings],
});
```

```ts {{ title: "Hono" }}
import { Inngest, InngestMiddleware } from 'inngest';
import { type Context } from 'hono';

type Bindings = {
  MY_VAR: string;
  DB_URL: string;
  MY_BUCKET: R2Bucket;
};

const bindings = new InngestMiddleware({
  name: 'Hono bindings',
  init({ client, fn }) {
    return {
      onFunctionRun({ ctx, fn, steps, reqArgs }) {
        return {
          transformInput({ ctx, fn, steps }) {
            // reqArgs is the array of arguments passed to a Hono handler
            // We cast the argument to the correct Hono Context type with our
            // environment variable bindings
            const [honoCtx] = reqArgs as [Context<{ Bindings: Bindings }>];
            return {
              ctx: {
                // Return the context's env object to the function handler's input args
                env: honoCtx.env,
              },
            };
          },
        };
      },
    };
  },
});

// Include the middleware when creating the Inngest client
export const inngest = new Inngest({
  id: 'my-hono-app',
  middleware: [bindings],
});
```

Within your functions, you can now access the environment variables via the `env` object argument that you returned in `transformInput` above. Here's an example function:

```ts
const myFn = inngest.createFunction(
  { id: 'my-fn' },
  { event: 'demo/event.sent' },
  // The "env" argument returned in transformInput is passed through:
  async ({ event, step, env }) => {

    // The env object will be typed as well:
    console.log(env.MY_VAR);
  }
);
```


--------------------------------------------------------------------------------
title: "Set up OpenTelemetry with Inngest&#x20;"
source: "https://www.inngest.com/docs/examples/open-telemetry"
--------------------------------------------------------------------------------

# Set up OpenTelemetry with Inngest&#x20;

Inngest's [Extended Traces](/docs-markdown/platform/monitor/traces#extended-traces) enables you to forward your application OpenTelemetry traces into
Inngest's Traces for a unified observability and debugging experience, both in the DevServer and Platform.

This guide covers how to **set up OpenTelemetry with Inngest Traces** and how to **create custom spans**.

## Set up Inngest Extended Traces with an existing OpenTelemetry client

If your application already uses an OpenTelemetry client, the Inngest `extendedTracesMiddleware()` should be configured properly to
capture your application traces while not registering the Node.js instrumentations twice.

Here's a Node.js application OpenTelemetry setup (*exporting traces via OTLP*) using Inngest Extended Traces:

```ts tracing.ts
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";

import { Inngest } from "inngest";
import { InngestSpanProcessor, extendedTracesMiddleware } from "inngest/experimental";

export const inngest = new Inngest({
  id: "nodejs-open-telemetry-example",
  name: "NodeJS Open Telemetry Example",
  // set to "off" if your OTel client has some `instrumentations` configured
  middleware: [extendedTracesMiddleware({ behaviour: "auto" })],
});

// Configure OTLP endpoint for Jaeger using the HTTP exporter
// Jaeger typically accepts OTLP HTTP on http://localhost:4318/v1/traces
// Override via OTEL_EXPORTER_OTLP_ENDPOINT or OTEL_EXPORTER_OTLP_TRACES_ENDPOINT
const traceExporter = new OTLPTraceExporter({
  url:
    process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT ||
    process.env.OTEL_EXPORTER_OTLP_ENDPOINT ||
    "http://localhost:4318/v1/traces",
});

const sdk = new NodeSDK({
  traceExporter: traceExporter,
  spanProcessors: [new InngestSpanProcessor(inngest)],
  // Set service name for Jaeger
  serviceName: "nodejs-open-telemetry-example",
});

sdk.start();

console.log("OpenTelemetry SDK started");
console.log(
  `Tracing endpoint: ${
    process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT ||
    process.env.OTEL_EXPORTER_OTLP_ENDPOINT ||
    "http://localhost:4318/v1/traces"
  }`
);
```

This setup is the most robust as it won't force you to follow a strict import order to get your OTel and Inngest Tracing to work together.
With this setup, your application OTel traces (e.g., Express API) will continue to be exported to your OTLP compatible ingestor (e.g., Jaeger) while
the Inngest Extended Traces will be forwarded to the Inngest DevServer or Platform.

> **Callout:** Which Extended Traces behaviour mode should I use?If your current OpenTelemetry setup includes some auto instrumentations (e.g., @opentelemetry/auto-instrumentations-node), set the behaviour mode to "off" to avoid duplicated traces.If you'd like to benefit from database queries and HTTP request traces in your Inngest Traces, set behaviour to "auto".

## Set up Inngest Extended Traces WITHOUT an existing OpenTelemetry client

Setting up Inngest Extended Traces without an existing OpenTelemetry client only requires adding the `extendedTracesMiddleware()`
to your Inngest client as follows:

```ts client.ts
// Create your client the same as you would normally
import { Inngest } from "inngest";
import { extendedTracesMiddleware } from "inngest/experimental";

export const inngest = new Inngest({
 id: "my-app",
 middleware: [extendedTracesMiddleware()]
});
```

This configuration will enrich your Inngest Traces with database queries and HTTP request spans.

## How to create custom spans with Inngest Extended Traces

Once Inngest Extended Traces is properly set up in your application, your Inngest workflow will receive an additional `tracer` argument:

```ts workflow.ts
import { inngest } from './client'

export const userOnboarding = inngest.createFunction(
  { id: "user-onboarding" },
  { event: "user.onboarding" },
  async ({ event, step, tracer }) => {
    //  ...
  }
);
```

The `tracer` object is an `@opentelemetry/api`'s `Tracer` instance enabling you to create custom traces as follows:

```ts workflow.ts
import { inngest } from './client'
import { sendEmail } from './emails'

export const userOnboarding = inngest.createFunction(
  { id: "user-onboarding" },
  { event: "user.onboarding" },
  async ({ event, step, tracer }) => {
    await step.run("create-user", async () => {
        // ...
    });

    await step.run("send-welcome-email", async () => {
        tracer.startActiveSpan("call-email-service", async (span) => {
        span.setAttributes({ name, email });

        await sendEmail({ name, email })

        span.end();
      });
    });
  }
);
```

Using `tracer.startActiveSpan()`, we create a custom `call-email-service` span to track the performance of the external `sendEmail()` service.

Our custom span is properly displayed within our Inngest workflow run Traces:

![The user-onboarding run displays Inngest Traces featuring the call-email-service custom span](/assets/docs-markdown/examples/open-telemetry/custom-span.png)


--------------------------------------------------------------------------------
title: "Realtime: Stream updates from Inngest functions"
source: "https://www.inngest.com/docs/examples/realtime"
--------------------------------------------------------------------------------

# Realtime: Stream updates from Inngest functions

Inngest Realtime enables you to stream updates from your functions, power live UIs, and implement bi-directional workflows such as Human-in-the-Loop. Use channels and topics to broadcast updates, stream logs, or await user input.

## Pattern: Stream updates from a single function run

Enable users to follow the progress of a long-running task by streaming updates from a dedicated channel. Here's how to trigger a function and subscribe to its updates:

```ts { title: "app/api/hello-world/route.ts" }
import crypto from "crypto";
import { inngest } from "@/inngest/client";
import { subscribe } from "@inngest/realtime";

export async function POST(req: Request) {
  const json = await req.json();
  const { prompt } = json;
  const uuid = crypto.randomUUID();

  await inngest.send({
    name: "hello-world/hello",
    data: { uuid },
  });

  const stream = await subscribe(inngest, {
    channel: `hello-world.${uuid}`,
    topics: ["logs"],
  });

  return new Response(stream.getEncodedStream(), {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
```

Your function can then publish updates to this channel:

```ts { title: "src/inngest/functions/hello-world.ts" }
import { Inngest } from "inngest";
import { realtimeMiddleware, channel, topic } from "@inngest/realtime";

const inngest = new Inngest({
  id: "my-app",
  middleware: [realtimeMiddleware()],
});

export const helloChannel = channel((uuid: string) => `hello-world.${uuid}`).addTopic(
  topic("logs").type<string>()
);

export const someTask = inngest.createFunction(
  { id: "hello-world" },
  { event: "hello-world/hello" },
  async ({ event, step, publish }) => {
    const { uuid } = event.data;
    await publish(helloChannel(uuid).logs("Hello, world!"));
  }
);
```

By creating a channel with a unique identifier, you can stream updates for a specific run to the end user.

**"Explore the full source code"**: [Clone this example locally to run it and explore the full source code.](https://github.com/inngest/inngest-js/tree/main/examples/realtime/nodejs/realtime-single-run-subscription)

## Pattern: Stream updates from multiple function runs

A Realtime channel can be used to stream updates from multiple function runs. Here, we'll define two channels: one global channel and one post-specific channel:

```ts {{ filename: "src/inngest/channels.ts" }}
import {
  channel,
  topic,
} from "@inngest/realtime";
import { z } from "zod";

export const globalChannel = channel("global").addTopic(topic("logs").type<string>());

export const postChannel = channel((postId: string) => `post:${postId}`)
  .addTopic(
    topic("updated").schema(
      z.object({
        id: z.string(),
        likes: z.number(),
      })
    )
  )
  .addTopic(
    topic("deleted").schema(
      z.object({
        id: z.string(),
        reason: z.string(),
      })
    )
  );
```

Our `likePost` function will publish updates to both channels:

```ts {{ filename: "src/inngest/functions/likePost.ts" }}
import {
  channel,
  realtimeMiddleware,
  subscribe,
  topic,
} from "@inngest/realtime";
import { EventSchemas, Inngest } from "inngest";
import { globalChannel, postChannel } from "../channels";

export const likePost = app.createFunction(
  {
    id: "post/like",
    retries: 0,
  },
  {
    event: "app/post.like",
  },
  async ({
    event: {
      data: { postId = "123" },
    },
    step,
    publish,
  }) => {
    if (!postId) {
      await publish(
        globalChannel().logs("Missing postId when trying to like post")
      );
      throw new Error("Missing postId");
    }

    await publish(globalChannel().logs(`Liking post ${postId}`));

    // Fake a post update
    const post = await step.run("Update likes", async () => {
      const fakePost = {
        id: "123",
        likes: Math.floor(Math.random() * 10000),
      };

      return publish(postChannel(fakePost.id).updated(fakePost));
    });

    return post;
  }
);
```

The `globalChannel` will be used to stream updates for all posts, and the `postChannel` will be used to stream updates for specific posts.

**"Explore the full source code"**: [Clone this example locally to run it and explore the full source code.](https://github.com/inngest/inngest-js/tree/main/examples/realtime/nodejs/realtime-across-multiple-channels)

## Human in the loop: Bi-directional workflows

Combine Realtime with `waitForEvent()` to enable workflows that require user input, such as review or approval steps. Here's how to send a message to the user and wait for their confirmation:

```ts { title: "src/inngest/functions/agentic-workflow.ts" }
import crypto from "crypto";
import { Inngest } from "inngest";
import { realtimeMiddleware, channel, topic } from "@inngest/realtime";

const inngest = new Inngest({
  id: "my-app",
  middleware: [realtimeMiddleware()],
});

export const agenticWorkflowChannel = channel("agentic-workflow").addTopic(
  topic("messages").schema(
    z.object({
      message: z.string(),
      confirmationUUid: z.string(),
    })
  )
);

export const agenticWorkflow = inngest.createFunction(
  { id: "agentic-workflow" },
  { event: "agentic-workflow/start" },
  async ({ event, step, publish }) => {
    await step.run(/* ... */);
    const confirmationUUid = await step.run("get-confirmation-uuid", async () => crypto.randomUUID());
    await publish(agenticWorkflowChannel().messages({
      message: "Confirm to proceed?",
      confirmationUUid,
    }));
    const confirmation = await step.waitForEvent("wait-for-confirmation", {
      event: "agentic-workflow/confirmation",
      timeout: "15m",
      if: `async.data.confirmationUUid == \"${confirmationUUid}\"`,
    });
    if (confirmation) {
      // continue workflow
    }
  }
);
```

The `confirmationUUid` links the published message to the reply event, ensuring the correct user response is handled.

**"Explore the full source code"**: [Clone this example locally to run it and explore the full source code.](https://github.com/inngest/inngest-js/tree/main/examples/realtime/nodejs/realtime-human-in-the-loop)

## Learn more


--------------------------------------------------------------------------------
title: "Scheduling a one-off function"
source: "https://www.inngest.com/docs/examples/scheduling-one-off-function"
--------------------------------------------------------------------------------

# Scheduling a one-off function

Inngest provides a way to delay a function run to a specific time in the future. This is useful when:

- You want to schedule work in the future based on user input.
- You want to slightly delay execution of a non-urgent function for a few seconds or minutes.

This page provides a quick example of how to delay a function run to a specific time in the future using the [event payload's](/docs-markdown/events#event-payload-format) `ts` field.

## Quick Snippet

Here is a basic function that sends a reminder to a user at a given email.

```typescript
const sendReminder = inngest.createFunction(
  { id: "send-reminder" },
  { event: "notifications/reminder.scheduled" },
  async ({ event, step }) => {
    const { user, message } = event.data;

    const { id } = await emailApi.send({
      to: user.email,
      subject: "Reminder for your upcoming event",
      body: message,
    });

    return { id }
  }
);
```

### Triggering the function with a timestamp

To trigger this function, you will send an event `"notifications/reminder.scheduled"` using `inngest.send()` with the necessary data. The `ts` field in the [event payload](/docs-markdown/events#event-payload-format) should be set to the Unix timestamp of the time you want the function to run. For example, to schedule a reminder for 5 minutes in the future:

```typescript
await inngest.send({
  name: "notifications/reminder.scheduled",
  data: {
    user: { email: "johnny.utah@fbi.gov" }
    message: "Don't forget to catch the wave at 3pm",
  },
  // Include the timestamp for 5 minutes in the future:
  ts: Date.now() + 5 * 60 * 1000,
});
```

> **Callout:** ‚ö†Ô∏è Providing a timestamp in the event only applies for starting function runs. Functions waiting for a matching event will immediately resume, regardless of the timestamp.

### Alternatives

Depending on your use case, you may want to consider using [scheduled functions (cron jobs)](/docs-markdown/guides/scheduled-functions) for scheduling periodic work or use [`step.sleepUntil()`](/docs-markdown/reference/functions/step-sleep-until) to add mid-function delays for a layer time.

## More context

Check the resources below to learn more about scheduling functions with Inngest.

## Related concepts

- [Scheduled functions (cron jobs)](/docs-markdown/guides/scheduled-functions)
- [`step.sleepUntil()`](/docs-markdown/reference/functions/step-sleep-until)


--------------------------------------------------------------------------------
title: "Track all function failures in Datadog"
source: "https://www.inngest.com/docs/examples/track-failures-in-datadog"
--------------------------------------------------------------------------------

# Track all function failures in Datadog

Your functions may fail from time to time. Inngest provides a way to handle all failed functions in a single place. This can enable you to send metrics, alerts, or events to external systems like Datadog or Sentry for all of your Inngest functions.

This page provides an example of tracking all function failures using [Datadog's Events API](https://docs.datadoghq.com/api/latest/events/) to send all failures the Datadog event stream. You could replace Datadog with whatever system you use for monitoring and alerting.

## Quick Snippet

Here is a basic function that uses the internal [`"inngest/function.failed"`](/docs-markdown/reference/system-events/inngest-function-failed) event. This event is triggered whenever any single function fails in your [Inngest environment](/docs-markdown/platform/environments).

```ts
import { client, v1 } from "@datadog/datadog-api-client";
import { inngest } from "./client";

const configuration = client.createConfiguration();
const apiInstance = new v1.EventsApi(configuration);

export default inngest.createFunction(
  {
    name: "Send failures to Datadog",
    id: "send-failed-function-events-to-datadog"
  },
  { event: "inngest/function.failed" },
  async ({ event, step }) => {
    // This is a normal Inngest function, so we can use steps as we normally do:
    await step.run("send-event-to-datadog", async () => {
      const error = event.data.error;

      // Create the Datadog event body using information about the failed function:
      const params: v1.EventsApiCreateEventRequest = {
        body: {
          title: "Inngest Function Failed",
          alert_type: "error",
          text: `The ${event.data.function_id} function failed with the error: ${error.message}`,
          tags: [
            // Add a tag with the Inngest function id:
            `inngest_function_id:${event.data.function_id}`,
          ],
        },
      };

      // Send to Datadog:
      const data = await apiInstance.createEvent(params);

      // Return the data to Inngest for viewing in function logs:
      return { message: "Event sent successfully", data };
    });
  }
);
```

An example failure event payload:

```json
{
  "name": "inngest/function.failed",
  "data": {
    "error": {
      "__serialized": true,
      "error": "invalid status code: 500",
      "message": "taylor@ok.com is already a list member. Use PUT to insert or update list members.",
      "name": "Error",
      "stack": "Error: taylor@ok.com is already a list member. Use PUT to insert or update list members.\n    at /var/task/.next/server/pages/api/inngest.js:2430:23\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async InngestFunction.runFn (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/components/InngestFunction.js:378:32)\n    at async InngestCommHandler.runStep (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/components/InngestCommHandler.js:459:25)\n    at async InngestCommHandler.handleAction (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/components/InngestCommHandler.js:359:33)\n    at async ServerTiming.wrap (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/helpers/ServerTiming.js:69:21)\n    at async ServerTiming.wrap (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/helpers/ServerTiming.js:69:21)"
    },
    "event": {
      "data": { "billingPlan": "pro" },
      "id": "01H0TPSHZTVFF6SFVTR6E25MTC",
      "name": "user.signup",
      "ts": 1684523501562,
      "user": { "external_id": "6463da8211cdbbcb191dd7da" }
    },
    "function_id": "my-gcp-cloud-functions-app-hello-inngest",
    "run_id": "01H0TPSJ576QY54R6JJ8MEX6JH"
  },
  "id": "01H0TPW7KB4KCR739TG2J3FTHT",
  "ts": 1684523589227
}
```

## More context

Check the resources below to learn more about building email sequences with Inngest.


--------------------------------------------------------------------------------
title: "Frequently Asked Questions (FAQs)"
source: "https://www.inngest.com/docs/faq"
--------------------------------------------------------------------------------

# Frequently Asked Questions (FAQs)

- [How do I run crons only in production?](#how-do-i-run-crons-only-in-production)
- [How do I stop functions from running?](#how-do-i-stop-functions-from-running)
- [What is the "Finalization" step in my trace?](#what-is-the-finalization-step-in-my-trace)
- [Why am I getting ‚ÄúEvent key not found" errors in branch environments?](#why-am-i-getting-event-key-not-found-errors-in-branch-environments)
- [How do I specify multiple serve paths for a same Vercel application on the Dashboard?](#why-am-i-getting-event-key-not-found-errors-in-branch-environments)
- [What's the recommended way to redact data from step outputs?](#what-s-the-recommended-way-to-redact-data-from-step-outputs)
- [Why am I getting a `FUNCTION_INVOCATION_TIMEOUT` error?](#why-am-i-getting-a-function-invocation-timeout-error)
- [My app's serve endpoint requires authentication. What should I
  do?](#my-app-s-serve-endpoint-requires-authentication-what-should-i-do)
- [Why am I getting a `killed` error when running the Dev Server?](#why-am-i-getting-a-killed-error-when-running-the-dev-server)
- [Why am I getting a `NON_DETERMINISTIC_FUNCTION`
  error?](#why-am-i-getting-a-non-deterministic-function-error)
- [Why am I getting an `Illegal invocation` error?](#why-am-i-getting-an-illegal-invocation-error)
- [Why is the dev server polling endpoints that don't exist?](#why-is-the-dev-server-polling-endpoints-that-don-t-exist)

## How do I run crons only in production?

There are multiple ways to achieve it:

1. Conditionally rendering depending on the environment.

```javascript
process.env.NODE_ENV === "production" ? { cron: "* * *" } : { event: "dev/manualXYZ" }
```

üí° If you render an event instead of a cron in the other environments, you can still trigger your functions manually if needed.

2. [Disable branch environments](/docs-markdown/platform/environments#disabling-branch-environments-in-vercel).

## How do I stop functions from running?

The best way to ensure a deprecated function doesn't run is to deploy without including it in your [serve handler](/docs-markdown/reference/serve). You can temporarily achieved the same result by archiving the function on our dashboard, but note that a new deployment will unarchive the function.

## What is the "Finalization" step in my trace?

The "finalization" step in a run's trace represents the execution of the code between your function's last step and the end of the function handler.

```ts {{ x: "10"}}
const myFunction = inngest.createFunction(
  { id: "handle-import" }
  { event: "integration.connected" }
  async ({ event, step }) => {
    const res = await step.run("import-data", async () => {
      // ...
    });
    // -- Finalization starts ‚¨áÔ∏è --
    const newRows = res.rows.filter((row) => row.created === true)
    return { message: `Imported ${newRows.length} rows` }
    // -- Finalization ends ‚¨ÜÔ∏è --
  },
)
```

## Why am I getting ‚ÄúEvent key not found" errors in branch environments?

Branch environments are [automatically archived](/docs-markdown/platform/environments#archiving-branch-environments) 3 days after their latest deploy.
It's possible to disable the auto archive functionality for each active environment on our [dashboard](https://app.inngest.com/env).

## How do I specify multiple serve paths for a same Vercel application on the dashboard?

You can pass multiple paths by adding their path information to each Vercel project in the [Vercel Integration‚Äôs settings](https://app.inngest.com/settings/integrations/vercel).

## What's the recommended way to redact data from step outputs?

We recommend doing [E2E encryption](/docs-markdown/reference/middleware/examples#e2-e-encryption) instead, as it's more secure and plaintext data never leaves your servers.

## Why am I getting a `FUNCTION_INVOCATION_TIMEOUT` error?

This is a Vercel error that means your function timed out within Vercel's infrastructure before it was able to respond to Inngest. More information can be found in [Vercel's docs](https://vercel.com/docs-markdown/functions/serverless-functions/runtimes#max-duration).

If you're unable to sufficiently extend the timeout within Vercel, our [streaming feature](/docs-markdown/streaming) can help.

## My app's serve endpoint requires authentication. What should I do?

Your app's [serve endpoint](/docs-markdown/learn/serving-inngest-functions) needs to be accessible by our
servers, so we can trigger your functions. For this reason, we recommend disabling authentication
for the serve endpoint.

Our servers communicate securely with your app's serve endpoint using your [signing key](/docs-markdown/learn/serving-inngest-functions#signing-key).

### Vercel

By default, Vercel enables [Deployment Protection](https://vercel.com/docs-markdown/security/deployment-protection)
for both preview and generated production URLs. This means that your app's serve endpoint will be
unreachable by our servers unless you [disable Deployment Protection](https://vercel.com/docs-markdown/security/deployment-protection#configuring-deployment-protection)
or, if you're on Vercel's Pro plan, [configure protection bypass](/docs-markdown/deploy/vercel#bypassing-deployment-protection).

## Why am I getting a `killed` error when running the Dev Server?

The Inngest CLI binary may become corrupted, particularly during updates while
being downloaded. Symptoms can also include the CLI giving no output or a
`Segmentation fault`.

Clear your npx cache by running `rm -rf ~/.npm/_npx`, or the cache of whichever
package manager you're using to run the Dev Server (for example `pnpm prune`, `yarn
cache clean`).

If the error still persists, please reach out to us on [our Discord](https://www.inngest.com/discord).

## Why am I getting a `NON_DETERMINISTIC_FUNCTION` error?

This is an error present in v2.x.x of the TypeScript SDK that can be thrown when a deployment changes a function in the middle of a run.

If you're seeing this error, we encourage you to upgrade to v3.x.x of the TypeScript SDK, which will recover and continue gracefully from this circumstance.

For more information, see the [Upgrading from v2 to v3](/docs-markdown/sdk/migration) migration guide.

## Why am I getting an `Illegal invocation` error?

When making requests to an Inngest Server, the TypeScript SDK uses
[`fetch`](https://developer.mozilla.org/en-US/docs-markdown/Web/API/Fetch_API). The
actual implementation of this varies across different runtimes, versions, and
environments. The SDK tries to account for these differences internally, but
sometimes providing a custom `fetch` function is necessary or wanted.

This error is usually indicative of providing a custom `fetch` function to
either a `new Inngest()` or `serve()` call, but not carrying over its
[binding](https://developer.mozilla.org/en-US/docs-markdown/Web/JavaScript/Reference/Global_objects/Function/bind).
This is a common JavaScript gotcha, where bound methods lose their binding when
passed into an object.

To resolve, make sure that you rebind the `fetch` function as it is passed. This
is commonly bound to `globalThis`, though your specific runtime/version/environment
may vary.

```ts
new Inngest({
  fetch: fetch.bind(globalThis),
});
```

## Why is the dev server polling endpoints that don't exist?

The dev server will automatically detect and connect to apps running on common ports and endpoints. These endpoints include `/api/inngest`, `/x/inngest`, `/.netlify/functions/inngest`, `/.redwood/functions/inngest`.

You can disable auto-discovery by passing the `--no-discovery` flag to the `dev` command:

```sh
npx --ignore-scripts=false inngest-cli@latest dev --no-discovery
```

Learn more about this in the [dev server](/docs-markdown/dev-server#auto-discovery) docs.

## Why doesn't the Dev Server do anything when I start it?

If the Dev Server command (`npx inngest-cli dev`) doesn't do anything, it might be because you've disabled npm install scripts. Try clearing your npm cache and rerunning the Dev Server command with `--ignore-scripts=false`:

```sh
$ rm -rf ~/.npm/_npx/*
$ npx --ignore-scripts=false inngest-cli dev
```


--------------------------------------------------------------------------------
title: "Events & Triggers"
source: "https://www.inngest.com/docs/features/events-triggers"
--------------------------------------------------------------------------------

# Events & Triggers

Inngest functions are triggered asynchronously by **events** coming from various sources, including:

**Your application**: [Send an event from your application‚Äôs backend with the Inngest SDK.](/docs-markdown/events)

**Cron schedule**: [Run an Inngest function periodically with a trigger using cron syntax.]('/docs/guides/scheduled-functions')

**Webhook events**: [Use Inngest as a webhook consumer for any service to trigger functions.]('/docs/platform/webhooks')

**Another Inngest function**: [Directly invoke other functions to compose more powerful functions.]('/docs/guides/invoking-functions-directly')

You can customize each of these triggers in multiple ways:

- **[Filtering event triggers](/docs/guides/writing-expressions)** - Trigger a function for a subset of matching events sent.
- **[Delaying execution](/docs-markdown/guides/delayed-functions)** - Trigger a function to run at a specific timestamp in the future.
- **[Batching events](/docs-markdown/guides/batching)** - Process multiple events in a single function for more efficient systems.
- **[Multiple triggers](/docs-markdown/guides/multiple-triggers)** - Use a single function to handle multiple event types.

## Why events?

Using Events to trigger Inngest Functions instead of direct invocations offers a lot of flexibility:

- Events can trigger multiple Inngest Functions.
- Events can be used to synchronize Inngest Function runs with [cancellation](/docs-markdown/features/inngest-functions/cancellation) and [‚Äúwait for event‚Äù step](/docs-markdown/reference/functions/step-wait-for-event).
- Events can be leveraged to trigger Functions across multiple applications.
- Similar Events can be grouped together for faster processing.

Events act as a convenient mapping between your application actions (ex, `user.signup`) and your application's code (ex, `sendWelcomeEmail()` and `importContacts()`):

### Learn more about Events

**Blog post: How event Filtering works**: [Accidentally Quadratic: Evaluating trillions of event matches in real-time]('https://www.inngest.com/blog/accidentally-quadratic-evaluating-trillions-of-event-matches-in-real-time')

**Blog post: Events in practice**: [Building an Event Driven Video Processing Workflow with Next.js, tRPC, and Inngest]('https://www.inngest.com/blog/nextjs-trpc-inngest')


--------------------------------------------------------------------------------
title: "Untitled"
source: "https://www.inngest.com/docs/features/events-triggers/event-format"
--------------------------------------------------------------------------------

## Event payload format

The event payload is a JSON object that must contain a `name` and `data` property.

### Required properties

- The `name` is the type or category of event. Event `name`s are used to [trigger functions](/docs-markdown/functions). For example, `app/user.created` or `billing/invoice.paid`. See [tips for event naming](#tips-for-event-naming) below.
- `data` contains any data you want to associate with the event. This data will be serialized to JSON. For example, if you're sending an event for a paid invoice, you might include the invoice's `id`, the `amount`, and the `customerId` in the `data` property. The `data` property can contain any nested JSON object, including objects and arrays.

### Optional properties

- `id` is a unique identifier for the event used to prevent duplicate events. Learn more about [deduplication](/docs-markdown/events#deduplication).
- `ts` is the timestamp of the event in milliseconds since the Unix epoch. If not provided, the timestamp will be set to the time the event was received by Inngest.
- `v` is the event payload version. This is useful to track changes in the event payload shape over time. For example, `"2024-01-14.1"`
- `user` is object for ease of grouping user-identifying data or attributes associated with the event. This data is encrypted at rest.
  - **NOTE** - We now recommend that developers use [encryption middleware](/docs-markdown/features/middleware/encryption-middleware) to store personally identifiable information (PII) within the `data` object. Encryption middleware also has added benefits as it supports full or partial encryption of data returned from steps as well as complete control over the encryption key.

```json {{ title: "Basic JSON event example" }}
{
  "name": "billing/invoice.paid",
  "data": {
    "customerId": "cus_NffrFeUfNV2Hib",
    "invoiceId": "in_1J5g2n2eZvKYlo2C0Z1Z2Z3Z",
    "amount": 1000,
    "metadata": {
      "accountId": "acct_1J5g2n2eZvKYlo2C0Z1Z2Z3Z",
      "accountName": "Acme.ai"
    }
  },
  "user": {
    "email": "taylor@example.com"
  }
}
```

```ts {{ title: "TypeScript Type representation" }}
// If you prefer to think in TypeScript types, here's the type representation of the event payload:
type EventPayload = {
  name: string;
  data: Record<string, any>;
  user?: Record<string, any>;
  id?: string;
  ts?: number;
  v?: string;
}
```

```py {{ title: "Pydantic Type representation" }}
import inngest
import pydantic
import typing

TEvent = typing.TypeVar("TEvent", bound="BaseEvent")

class BaseEvent(pydantic.BaseModel):
    data: pydantic.BaseModel
    id: str = ""
    name: typing.ClassVar[str]
    ts: int = 0

    @classmethod
    def from_event(cls: type[TEvent], event: inngest.Event) -> TEvent:
        return cls.model_validate(event.model_dump(mode="json"))

    def to_event(self) -> inngest.Event:
        return inngest.Event(
            name=self.name,
            data=self.data.model_dump(mode="json"),
            id=self.id,
            ts=self.ts,
        )

class InvoicePaidEventData(pydantic.BaseModel):
    customerId: str
    invoiceId: str
    amount: int
    metadata: dict

class InvoicePaidEvent(BaseEvent):
    data: InvoicePaidEventData
    name: typing.ClassVar[str] = "billing/invoice.paid"
```

### Tips for event naming

Event names are used to trigger functions. We recommend using a consistent naming convention for your events. This will make it easier to find and trigger functions in the future. Here are some tips for naming events:

- **Object-Action**: Use an Object-Action pattern as represented by noun and a verb. This is great for grouping related events on a given object, `account.created`, `account.updated`, `account.deleted`.
- **Past-tense**: Use a past-tense verb for the action. For example, `uploaded`, `paid`, `completed`, `sent`.
- **Separators**: Use dot-notation and/or underscores to separate words. For example, `user.created` or `blog_post.published`.
- **Prefixes**: Use prefixes to group related events. For example, `api/user.created`, `billing/invoice.paid`, `stripe/customer.created`. This is especially useful if you have multiple applications that send events to Inngest.

There is no right or wrong way to name events. The most important thing is to be consistent and use a naming convention that makes sense for your application.


--------------------------------------------------------------------------------
title: "Neon"
source: "https://www.inngest.com/docs/features/events-triggers/neon"
--------------------------------------------------------------------------------

# Neon

Inngest allows you to trigger functions from your Neon Postgres database updates.

## Benefits of triggering functions from database events

By decoupling function triggers from your application logic, events are initiated by database updates rather than relying on instrumentation in your code to send them. This ensures you won‚Äôt miss an event when data is manipulated within your application. This decoupling creates a clean abstraction layer between database operations and code that runs asynchronously.

Additionally, as database events are pushed into the Inngest system to enqueue new functions, this can eliminate the need for architecture patterns like the [transactional outbox pattern](https://microservices.io/patterns/data/transactional-outbox.html).

### Leveraging Inngest features with database triggers

Beyond the architectural benefit, some specific Inngest features go perfectly with database triggers:

- [**Fan-out**](/docs-markdown/guides/fan-out-jobs) - Use a single database event to trigger multiple functions to run in parallel. For example, a pg/users.inserted might trigger a welcome email function and a function that starts a trial in Stripe.
- [**Batching**](/docs-markdown/guides/batching) - Database events can be batched to process many updates more efficiently. For example, many small updates can be aggregated or efficiently perform bulk operations using third party APIs that support it, like Shopify.
- [**Flow control**](/docs-markdown/guides/flow-control) - Combine database triggers with flow control functionality like throttling, debouncing, or rate limiting for better resource management and efficiency. For example, use throttling for working with third party API rate limits or use debounce for operations that may happen frequently, helping to avoid redundant work.

## How it works

Once you connect Neon to Inngest, any changes to data in your database will automatically send new events to your Inngest account.

> **Info:** The Neon integration currently only supports a single database connection per-account to the Inngest production environment.
> No other environments are supported at this time.

## Connecting Neon to Inngest

Connecting Neon will require some configuration changes on your Postgres database and Neon project.

There are three steps to install the Neon integration in Inngest:

1. **Authorization:** by adding your postgres credentials, Inngest can access your database to proceed with the installation
2. **Enable logical replication:** change the `wal_level` configuration to `logical`
3. **Connect the Neon database to Inngest**

You will find Neon in the integrations page inside your Inngest dashboard. Click "Connect" to begin the setup process:

### 1. Authorizing Inngest

> **Callout:** Inngest doesn‚Äôt store your credentials. Make sure you don‚Äôt refresh the page when completing the steps, otherwise your credentials will be lost. If that‚Äôs the case, you will be prompt to authorize Inngest again.

Insert your postgres credentials and hit the ‚ÄúVerify‚Äù button to start the validation process:

### 2. Enable logical replication

You will need to make sure your Neon project has enabled logical replication.

Enable logical replication either automatically using the Neon dashboard:

Or follow the steps in the [Neon guide](https://neon.tech/docs/guides/logical-replication-postgres-to-neon#enable-logical-replication-in-the-source-neon-project) to locate and edit your postgresql.conf file.
Once that‚Äôs complete, go back to Inngest to ‚ÄúVerify logical replication is enabled‚Äù:

### 3. Connecting

There are two ways to connect to the Neon Database:

- Automatically
- Manually *(coming soon)*

Inngest will setup and connect to your Neon Database automatically. It will create a Postgres role for replication, grant schema access to the role, create a replication slot and create a publication.

## Local development *(coming soon)*

For information about our plans check our [public roadmap.](https://roadmap.inngest.com/roadmap)


--------------------------------------------------------------------------------
title: "Cancellation"
source: "https://www.inngest.com/docs/features/inngest-functions/cancellation"
--------------------------------------------------------------------------------

# Cancellation

Cancellation is a useful mechanism for preventing unnecessary actions based on previous actions (ex, skipping a report generation upon an account deletion) or stopping an unwanted function run composed of multiple steps (ex, deployment mistake, duplicates).

Inngest enables you to cancel running Functions via the API, Dashboard, or based on events:

**Cancel on events**: [Cancel scheduled or sleeping Functions based on incoming events.]('/docs-markdown/features/inngest-functions/cancellation/cancel-on-events')

**Bulk cancel via the Platform Dashboard**: [The quickest way to cancel the Function runs within a given time range.]('/docs/platform/manage/bulk-cancellation')

**Cancel or bulk cancel via the REST API**: [Useful to cancel a large number of Function runs within a specific range.]('/docs/guides/cancel-running-functions#bulk-cancel-via-the-rest-api')

**Replay canceled Function runs**: [Canceled Functions runs can be replayed from the Platform Dashboard]('/docs/platform/replay')

## Anatomy of a cancellation

Inngest cancellation mechanisms prevent a scheduled Function run from running or stop an ongoing Function run between some following steps (sleep or action steps).

Please note that:

- Cancelling a function that has a currently executing step will not stop the step's execution. Any actively executing steps will run to completion.
- Canceling a set of Function runs does not prevent new Function runs from being enqueued (ex, in case of loop issues). Consider using [Functions Pausing](/docs-markdown/guides/pause-functions) instead.

Consider the below Inngest Function:

```ts {{ title: "inngest/scheduleReminder.ts" }}
const scheduleReminder = inngest.createFunction(
  {
    id: "schedule-reminder",
    cancelOn: [{ event: "tasks/deleted", if: "event.data.id == async.data.id" }],
  }
  { event: "tasks/reminder.created" },
  async ({ event, step }) => {
    // Step 1
    await step.sleepUntil('sleep-until-remind-at-time', event.data.remindAt);
    // Step 2
    await step.run('send-reminder-push', async ({}) => {
      await pushNotificationService.push(event.data.userId, event.data.reminderBody)
    })
  }
  // ...
);
```

```py {{ title: "inngest/schedule_reminder.py" }}
@inngest_client.create_function(
    fn_id="schedule-reminder",
    trigger=inngest.TriggerEvent(event="tasks/reminder.created"),
    cancel=[inngest.Cancel(
                event="tasks/deleted",
                if_exp="event.data.id == async.data.id"
            )],
)
async def fn(ctx: inngest.Context) -> None:
    # Step 1
    await ctx.step.sleep_until(
        "sleep-until-remind-at-time",
         ctx.event.data["remind_at"],
    )

    # Step 2
    await ctx.step.run("send-reminder-push", send_reminder_push)

async def send_reminder_push() -> None:
    pass
```

```go {{ title: "main.go" }}
import (
	"context"

	"github.com/inngest/inngestgo"
)

func loadScheduleReminderInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID:   "schedule-reminder",
			Name: "Schedule reminder",
			Cancel: []inngestgo.ConfigCancel{
				{
					Event: "tasks/deleted",
					If:    inngestgo.StrPtr("event.data.id == async.data.id"),
				},
			},
		},
		// Run on every tasks/reminder.created event.
		inngestgo.EventTrigger("tasks/reminder.created", nil),
		ScheduleReminder,
	)
}

func ScheduleReminder(ctx context.Context, input inngestgo.Input[ScheduleReminderEvent]) (any, error) {
	// ...
	// ...
	return true, nil
}
```

Let's now look at two different cancellations triggered from the Dashboard Bulk Cancellation UI:

**We cancel the Function run before or after Step 1**

1. The Function Run gets picked up by Inngest
2. The Step 1 is processed, triggering a sleep until the following week
3. Three days after, a cancellation is received
4. The Function run is canceled (Step 2 is skipped)

**We cancel the Function run when Step 2 is running**

1. The Function Run gets picked up by Inngest
2. The Step 1 is processed, triggering a sleep until a next week
3. A week after, a cancellation is received but the Step 2 is already started
4. The Step 2 runs until completion
5. The Function run is marked as "canceled"

All canceled Function runs can be replay by using the Platform's [Functions Replay UI](/docs-markdown/platform/replay).

## Handling cancelled functions

Function runs that are cancelled may require additional work like database cleanup or purging of deletion of temporary resources. This can be done leveraging the [`inngest/function.cancelled`](/docs-markdown/reference/system-events/inngest-function-cancelled) system event.

See [this complete example](/docs-markdown/examples/cleanup-after-function-cancellation) for how to use this event within your system to cleanup after a function run is cancelled.


--------------------------------------------------------------------------------
title: "Cancel on Events"
source: "https://www.inngest.com/docs/features/inngest-functions/cancellation/cancel-on-events"
--------------------------------------------------------------------------------

# Cancel on Events

As you have learned that you can trigger functions to run using events, you can also cancel active functions by sending an event.

For our example, we'll take a reminder app where a user can schedule to be reminded of something in the future at whatever time they want. The user can also delete the reminder if they change their mind and don't want to receive the reminder anymore.

#### TypeScript

Delaying code to run for days or weeks is easy with `step.sleepUntil`, but we need a way to be able to stop the function if the user deletes the reminder while our function is "sleeping."

When defining a function, you can also specify the `cancelOn` option which allows you to list one or more events that, when sent to Inngest, will cause the sleep to be terminated and function will be marked as "Canceled."

Here is our schedule reminders function that leverages `cancelOn`:

```ts {{ title: "inngest/syncContacts.ts" }}
const scheduleReminder = inngest.createFunction(
  {
    id: "schedule-reminder",
    cancelOn: [{
      event: "tasks/reminder.deleted", // The event name that cancels this function
      // Ensure the cancellation event (async) and the triggering event (event)'s reminderId are the same:
      if: "async.data.reminderId == event.data.reminderId",
    }],
  }
  { event: "tasks/reminder.created" },
  async ({ event, step }) => {
    await step.sleepUntil('sleep-until-remind-at-time', event.data.remindAt);
    await step.run('send-reminder-push', async ({}) => {
      await pushNotificationService.push(event.data.userId, event.data.reminderBody)
    })
  }
  // ...
);
```

Let's break down how this works:

1. Whenever the function is triggered, a cancellation listener is created which waits for an `"tasks/reminder.deleted"` event to be received.
2. The `if` statement tells Inngest that both the triggering event (`"tasks/reminder.created"`) and the cancellation event (`"tasks/reminder.deleted"`) have the same exact value for `data.reminderId` in each event payload. This makes sure that an event does not cancel a different reminder.

For more information on writing events, read our guide [on writing expressions](/docs-markdown/guides/writing-expressions).

Here is an example of these two events which will be matched on the `data.reminderId` field:

```json
{
  "name": "tasks/reminder.created",
  "data": {
    "userId": "user_123",
    "reminderId": "reminder_0987654321",
    "reminderBody": "Pick up Jane from the airport"
  }
}
```

```json
{
  "name": "tasks/reminder.deleted",
  "data": {
    "userId": "user_123",
    "reminderId": "reminder_0987654321",
  }
}
```

### Tips

- You can also optionally specify a `timeout` to only enable cancellation for a period of time.
- You can configure multiple events to cancel a function, up to five.
- You can write a more complex matching statement using the `if` field.

Learn more in the full [reference](/docs-markdown/reference/typescript/functions/cancel-on).

#### Python

Delaying code to run for days or weeks is easy with `step.sleep_until`, but we need a way to be able to stop the function if the user deletes the reminder while our function is "sleeping."

When defining a function, you can also specify the `cancel` option which allows you to list one or more events that, when sent to Inngest, will cause the sleep to be terminated and function will be marked as "Canceled."

Here is our schedule reminders function that leverages `cancel`:

```py {{ title: "inngest/schedule_reminder.py" }}
@inngest_client.create_function(
    fn_id="schedule-reminder",
    trigger=inngest.TriggerEvent(event="tasks/reminder.created"),
    cancel=[inngest.Cancel(
                event="tasks/reminder.deleted", # The event name that cancels this function
                # Ensure the cancellation event (async) and the triggering event (event)'s reminderId are the same:
                if_exp="async.data.reminderId == event.data.reminderId"
            )],
)
async def fn(ctx: inngest.Context) -> None:
    # Step 1
    await ctx.step.sleep_until(
        "sleep-until-remind-at-time",
         ctx.event.data["remind_at"],
    )

    # Step 2
    await ctx.step.run("send-reminder-push", send_reminder_push)

async def send_reminder_push() -> None:
    pass
```

Let's break down how this works:

1. Whenever the function is triggered, a cancellation listener is created which waits for an `"tasks/reminder.deleted"` event to be received.
2. The `if` statement tells Inngest that both the triggering event (`"tasks/reminder.created"`) and the cancellation event (`"tasks/reminder.deleted"`) have the same exact value for `data.reminderId` in each event payload. This makes sure that an event does not cancel a different reminder.

For more information on writing events, read our guide [on writing expressions](/docs-markdown/guides/writing-expressions).

Here is an example of these two events which will be matched on the `data.reminderId` field:

```json
{
  "name": "tasks/reminder.created",
  "data": {
    "userId": "user_123",
    "reminderId": "reminder_0987654321",
    "reminderBody": "Pick up Jane from the airport"
  }
}
```

```json
{
  "name": "tasks/reminder.deleted",
  "data": {
    "userId": "user_123",
    "reminderId": "reminder_0987654321",
  }
}
```

#### Go

Delaying code to run for days or weeks is easy with `step.Sleep()`, but we need a way to be able to stop the function if the user deletes the reminder while our function is "sleeping."

When defining a function, you can also specify the `Cancel` option which allows you to list one or more events that, when sent to Inngest, will cause the sleep to be terminated and function will be marked as "Canceled."

Here is our schedule reminders function that leverages `Cancel`:

```go {{ title: "main.go" }}
import (
	"context"

	"github.com/inngest/inngestgo"
)

func loadScheduleReminderInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID:   "schedule-reminder",
			Name: "Schedule reminder",
			Cancel: []inngestgo.ConfigCancel{
				{
					Event: "tasks/deleted",
					If:    inngestgo.StrPtr("event.data.id == async.data.id"),
				},
			},
		},
		// Run on every tasks/reminder.created event.
		inngestgo.EventTrigger("tasks/reminder.created", nil),
		ScheduleReminder,
	)
}

func ScheduleReminder(ctx context.Context, input inngestgo.Input[ScheduleReminderEvent]) (any, error) {
	// ...
	// ...
	return true, nil
}
```

Let's break down how this works:

1. Whenever the function is triggered, a cancellation listener is created which waits for an `"tasks/reminder.deleted"` event to be received.
2. The `if` statement tells Inngest that both the triggering event (`"tasks/reminder.created"`) and the cancellation event (`"tasks/reminder.deleted"`) have the same exact value for `data.reminderId` in each event payload. This makes sure that an event does not cancel a different reminder.

For more information on writing events, read our guide [on writing expressions](/docs-markdown/guides/writing-expressions).

Here is an example of these two events which will be matched on the `data.reminderId` field:

```json
{
  "name": "tasks/reminder.created",
  "data": {
    "userId": "user_123",
    "reminderId": "reminder_0987654321",
    "reminderBody": "Pick up Jane from the airport"
  }
}
```

```json
{
  "name": "tasks/reminder.deleted",
  "data": {
    "userId": "user_123",
    "reminderId": "reminder_0987654321",
  }
}
```


--------------------------------------------------------------------------------
title: "Cancel on timeouts"
source: "https://www.inngest.com/docs/features/inngest-functions/cancellation/cancel-on-timeouts"
--------------------------------------------------------------------------------

# Cancel on timeouts

It's possible to force runs to cancel if they take too long to start, or if the runs execute for too long.  The `timeouts` configuration property allows you to automatically cancel functions based off of two timeout properties:

- `timeouts.start`, which controls how long a function can stay "queued" before they start
- `timeouts.finish`, which controls how long a function can execute once started

In the following examples, we'll explore how to configure the timeout property and how this works.

## `timeouts.start` - Adding timeouts to queued runs (before start)

Runs may stay in the queue waiting to start due to concurrency backlogs, throttling configurations, or other delays. You can automatically cancel these runs if they are queued for too long prior to starting.

The `timeouts.start` configuration property controls this timeout. This example forces runs to cancel if it takes over 10 seconds to successfully start the first step of a run:

#### TypeScript

```ts {{ title: "inngest/function.ts" }}
const scheduleReminder = inngest.createFunction(
  {
    id: "schedule-reminder",
    timeouts: {
      // If the run takes longer than 10s to start, cancel the run.
      start: "10s",
    },
  }
  { event: "tasks/reminder.created" },
  async ({ event, step }) => {
    await step.run('send-reminder-push', async () => {
      await pushNotificationService.push(event.data.reminder)
    })
  }
  // ...
);
```

#### Go

```go {{ title: "inngest/function.go" }}
import (
	"context"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadInngestFnWithStartTimeout(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			Name: "A function",
			Timeouts: &inngestgo.ConfigTimeouts{
				// If the run takes longer than 10s to start, cancel the run.
				Start: inngestgo.Ptr(10 * time.Second),
			},
		},
		inngestgo.EventTrigger("tasks/reminder.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			return step.Run(ctx, "send-reminder", func(ctx context.Context) (bool, error) {
				// ...
				return false, nil
			})
		},
	)
}
```

## `timeouts.finish` - Adding timeouts to executing runs

You may want to limit the overall duration of a run after the run starts executing. You can cancel functions automatically if they're executing for too long.

The `timeouts.finish` configuration property controls this timeout. This example forces runs to cancel if it takes over 30 seconds to finish, once started:

#### TypeScript

```ts {{ title: "inngest/function.ts" }}
const scheduleReminder = inngest.createFunction(
  {
    id: "schedule-reminder",
    timeouts: {
      // If the run takes longer than 10s to start, cancel the run.
      start: "10s",
      // And if the run takes longer than 30s to finish after starting, cancel the run.
      finish: "30s",
    },
  }
  { event: "tasks/reminder.created" },
  async ({ event, step }) => {
    await step.run('send-reminder-push', async () => {
      await pushNotificationService.push(event.data.reminder)
    })
  }
  // ...
);
```

#### Go

```go {{ title: "inngest/function.go" }}
import (
	"context"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadInngestFnWithStartAndFinishTimeout(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			Name: "A function",
			Timeouts: &inngestgo.ConfigTimeouts{
				// If the run takes longer than 10s to start, cancel the run.
				Start: inngestgo.Ptr(10 * time.Second),
				// And if the run takes longer than 30s to finish after starting, cancel the run.
				Finish: inngestgo.Ptr(30 * time.Second),
			},
		},
		inngestgo.EventTrigger("tasks/reminder.createad", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			return step.Run(ctx, "send-reminder", func(ctx context.Context) (bool, error) {
				// ...
				return false, nil
			})
		},
	)
}
```

## Tips

- The `timeouts.start` duration limits how long a run waits in the queue for the first step to start
- Once the first attempt of a step begins, the `timeouts.start` property no longer applies.  Instead, the `timeouts.finish` duration begins.
- Once started, the `timeouts.finish` duration limits how long a run can execute
- Both properties can be stacked to control the overall length of a function run
- Runs that are cancelled due to a timeout trigger an [`inngest/function.cancelled`](/docs-markdown/reference/system-events/inngest-function-cancelled) event

## Limitations

- Step duration is unaffected by timeouts. For example, a 5 minute timeout will not prematurely cancel a step after 5 minutes.
- Concurrency can delay timeouts. For example, if a function is configured with a 5 minute timeout but concurrency delays the function run for 10 minutes, then the run will take 10 minutes to cancel.


--------------------------------------------------------------------------------
title: "Failure handlers"
source: "https://www.inngest.com/docs/features/inngest-functions/error-retries/failure-handlers"
--------------------------------------------------------------------------------

# Failure handlers

If your function exhausts all of its retries, it will be marked as "Failed." You can handle this circumstance by either providing an [`onFailure/on_failure`](/docs-markdown/reference/functions/handling-failures) handler when defining your function, or by listening for the [`inngest/function.failed`](/docs-markdown/reference/system-events/inngest-function-failed) system event.

The first approach is function-specific, while the second covers all function failures in a given Inngest environment.

# Examples

The example below checks if a user's subscription is valid a total of six times. If you can't check the subscription after all retries, you'll unsubscribe the user:

#### TypeScript

```ts
/* Option 1: give the inngest function an `onFailure` handler. */
inngest.createFunction(
  {
    id: "update-subscription",
    retries: 5,
    onFailure: async ({ event, error }) => {
      // if the subscription check fails after all retries, unsubscribe the user
      await unsubscribeUser(event.data.userId);
    },
  },
  { event: "user/subscription.check" },
  async ({ event }) => { /* ... */ },
);
/* Option 2: Listens for the [`inngest/function.failed`](/docs-markdown/reference/functions/handling-failures#the-inngest-function-failed-event) system event to catch all failures in the inngest environment*/
inngest.createFunction(
  { id: "handle-any-fn-failure" },
  { event: "inngest/function.failed" },
  async ({ event }) => { /* ... */ },
);
```

#### Python

```python
# Option 1: give the inngest function an [`on_failure`] handler.
async def update_subscription_failed(ctx: inngest.Context):
    # if the subscription check fails after all retries, unsubscribe the user
    await unsubscribe_user(ctx.data.userId)

@inngest_client.create_function(
    fn_id="update-subscription",
    retries=5,
    on_failure=update_subscription_failed,
    trigger=TriggerEvent(event="user/subscription.check"))
async def update_subscription(ctx: Context):
    pass # ...

# Option 2: Listens for the [inngest/function.failed](/docs-markdown/reference/functions/handling-failures#the-inngest-function-failed-event)
# system event to catch all failures in the inngest environment
@inngest_client.create_function(
    fn_id="global_failure_handler",
    trigger=[
        TriggerEvent(event="inngest/function.failed"),
        #TriggerEvent(event="inngest/function.cancelled")
    ],
)
async def global_failure_handler(ctx: Context):
    pass # handle all failures, e.g. to send to sentry
```

#### Go

```go
// the Go SDK doesn't have native way to define failure handlers,
// but you can define one by create a new function that uses
// the "inngest/function.failed" event and an expression:
myFailureHandler := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
			ID:   "account-created-on-failure",
			Name: "Account creation flow: On Failure",
	},
	inngestgo.EventTrigger(
		"inngest/function.failed",
		// The full function_id is a concatenated slug of your app id and the
		// failing function's "ID"
		inngestgo.StrPtr("event.data.function_id == 'my-app-account-created'")
	),
	func(
		ctx context.Context,
		input inngestgo.Input[inngestgo.GenericEvent[functionFailedEventData, any]],
	) (any, error) {
		// Handle your failure here
		return nil, nil
	}
)

type functionFailedEventData struct {
  Error struct {
    Message string `json:"message"`
    Name string `json:"name"`
  } `json:"error"`
  FunctionID string `json:"function_id"`
  RunID string `json:"run_id"`
}

// How to determine the full function_id to use in the expression?
// 1. Get the "app id" set via "NewHandler"
h := inngestgo.NewHandler("my-app", inngestgo.HandlerOpts{})
// 2. Get the FunctionOpts's ID parameter:
f := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
			ID:   "account-created",
			Name: "Account creation flow",
	},
	inngestgo.EventTrigger("api/account.created", nil),
	AccountCreated,
)
// 3. Join them with a hyphen:
// event.data.function_id == 'my-app-account-created'
```

> **Callout:** To handle cancelled function runs, checkout out this example that uses the inngest/function.cancelled system event.


--------------------------------------------------------------------------------
title: "Inngest Errors"
source: "https://www.inngest.com/docs/features/inngest-functions/error-retries/inngest-errors"
--------------------------------------------------------------------------------

# Inngest Errors

Inngest automatically handles errors and retries for you. You can use standard errors or use included Inngest errors to control how Inngest handles errors.

## Standard errors

#### TypeScript

All `Error` objects are handled by Inngest and [retried automatically](/docs-markdown/features/inngest-functions/error-retries/retries). This includes all standard errors like `TypeError` and custom errors that extend the `Error` class. You can throw errors in the function handler or within a step.

```typescript
export default inngest.createFunction(
  { id: "import-item-data" },
  { event: "store/import.requested" },
  async ({ event }) => {

    // throwing a standard error
    if (!event.itemId) {
      throw new Error("Item ID is required");
    }

    // throwing an error within a step
    const item = await step.run('fetch-item', async () => {
      const response = await fetch(`https://api.ecommerce.com/items/${event.itemId}`);
      if (response.status === 500) {
        throw new Error("Failed to fetch item from ecommerce API");
      }
      // ...
    });
  }
);
```

#### Python

All thrown Errors are handled by Inngest and [retried automatically](/docs-markdown/features/inngest-functions/error-retries/retries). This includes all standard errors like `ValueError` and custom errors that extend the `Exception` class. You can throw errors in the function handler or within a step.

```python
@client.create_function(
    fn_id="import-item-data",
    retries=0,
    trigger=inngest.TriggerEvent(event="store/import.requested"),
)
async def fn_async(ctx: inngest.Context) -> None:

    def foo() -> None:
        raise ValueError("foo")

    # a retry will be attempted
    await ctx.step.run("foo", foo)
```

#### Go

All Errors returned by your Inngest Functions are handled by Inngest and [retried automatically](/docs-markdown/features/inngest-functions/error-retries/retries).

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/step"
)

// Register the function
inngestgo.CreateFunction(
    client,
    inngestgo.FunctionOpts{
        ID: "send-user-email",
    },
    inngestgo.EventTrigger("user/created", nil),
    func(ctx context.Context, input inngestgo.Input[UserCreatedEvent]) (any, error) {
        // Run a step which emails the user.  This automatically retries on error.
        // This returns the fully typed result of the lambda.
        result, err := step.Run(ctx, "on-user-created", func(ctx context.Context) (bool, error) {
            // Run any code inside a step.
            result, err := emails.Send(emails.Opts{})
            return result, err
        })
        if err != nil {
            // This step retried 5 times by default and permanently failed.
            return nil, err
        }

        return result, nil
    },
)
```

## Prevent any additional retries

#### TypeScript

Use `NonRetriableError` to prevent Inngest from retrying the function *or* step. This is useful when the type of error is not expected to be resolved by a retry, for example, when the error is caused by an invalid input or when the error is expected to occur again if retried.

```typescript
import { NonRetriableError } from "inngest";

export default inngest.createFunction(
  { id: "mark-store-imported" },
  { event: "store/import.completed" },
  async ({ event }) => {
    try {
      const result = await database.updateStore(
        { id: event.data.storeId },
        { imported: true }
      );
      return result.ok === true;
    } catch (err) {
      // Passing the original error via `cause` enables you to view the error in function logs
      throw new NonRetriableError("Store not found", { cause: err });
    }
  }
);
```

### Parameters

```ts
new NonRetriableError(message: string, options?: { cause?: Error }): NonRetriableError
```

- `message` (string): The error message.

* `options` (object): The original error that caused the non-retriable error.

#### Python

Use `NonRetriableError` to prevent Inngest from retrying the function *or* step. This is useful when the type of error is not expected to be resolved by a retry, for example, when the error is caused by an invalid input or when the error is expected to occur again if retried.

```python
@client.create_function(
    fn_id="import-item-data",
    retries=0,
    trigger=inngest.TriggerEvent(event="store/import.requested"),
)
async def fn_async(ctx: inngest.Context) -> None:
    def step_1() -> None:
        raise inngest.NonRetriableError("non-retriable-step-error")

    ctx.step.run("step_1", step_1)
```

#### Go

Use `inngestgo.NoRetryError` to prevent Inngest from retrying the function. This is useful when the type of error is not expected to be resolved by a retry, for example, when the error is caused by an invalid input or when the error is expected to occur again if retried.

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/step"
)

// Register the function
inngestgo.CreateFunction(
    client,
    inngestgo.FunctionOpts{
        ID: "send-user-email",
    },
    inngestgo.EventTrigger("user/created", nil),
    func(ctx context.Context, input inngestgo.Input[UserCreatedEvent]) (any, error) {
        // Run a step which emails the user.  This automatically retries on error.
        // This returns the fully typed result of the lambda.
        result, err := step.Run(ctx, "on-user-created", func(ctx context.Context) (bool, error) {
            // Run any code inside a step.
            result, err := emails.Send(emails.Opts{})
            return result, err
        })
        if err != nil {
            // This step retried 5 times by default and permanently failed.
            // we return a NoRetryError to prevent Inngest from retrying the function
            return nil, inngestgo.NoRetryError(err)
        }

        return result, nil
    },
)
```

## Retry after a specific period of time

#### TypeScript

Use `RetryAfterError` to control when Inngest should retry the function or step. This is useful when you want to delay the next retry attempt for a specific period of time, for example, to more gracefully handle a race condition or backing off after hitting an API rate limit.

If `RetryAfterError` is not used, Inngest will use [the default retry backoff policy](https://github.com/inngest/inngest/blob/main/pkg/backoff/backoff.go#L10-L22).

```typescript
inngest.createFunction(
  { id: "send-welcome-sms" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    const { success, retryAfter } = await twilio.messages.create({
      to: event.data.user.phoneNumber,
      body: "Welcome to our service!",
    });

    if (!success && retryAfter) {
      throw new RetryAfterError("Hit Twilio rate limit", retryAfter);
    }
  }
);
```

### Parameters

```ts
new RetryAfterError(
  message: string,
  retryAfter: number | string | date,
  options?: { cause?: Error }
): RetryAfterError
```

- `message` (string): The error message.

* `retryAfter` (number | string | date): The specified time to delay the next retry attempt. The following formats are accepted:number - The number of milliseconds to delay the next retry attempt.string - A time string, parsed by the ms package, such as "30m", "3 hours", or "2.5d".date - A Date object.

- `options` (object): The original error that caused the non-retriable error.

#### Python

Use `RetryAfterError` to control when Inngest should retry the function or step. This is useful when you want to delay the next retry attempt for a specific period of time, for example, to more gracefully handle a race condition or backing off after hitting an API rate limit.

If `RetryAfterError` is not used, Inngest will use [the default retry backoff policy](https://github.com/inngest/inngest/blob/main/pkg/backoff/backoff.go#L10-L22).

```python
@client.create_function(
    fn_id="import-item-data",
    retries=0,
    trigger=inngest.TriggerEvent(event="store/import.requested"),
)
async def fn_async(ctx: inngest.Context) -> None:
  def step_1() -> None:
      raise inngest.RetryAfterError("rate-limit-hit", 1000) # delay in milliseconds

  ctx.step.run("step_1", step_1)
```

### Parameters

```python
RetryAfterError(
  message: typing.Optional[str],
  retry_after: typing.Union[int, datetime.timedelta, datetime.datetime],
) -> None
```

- `message` (string): The error message.

* `retry_after` (int | datetime.timedelta | datetime.datetime): The specified time to delay the next retry attempt. The following formats are accepted:int - The number of milliseconds to delay the next retry attempt.datetime.timedelta - A time delta object, such as datetime.timedelta(seconds=30).datetime.datetime - A datetime object.

#### Go

Use `RetryAtError` to control when Inngest should retry the function or step. This is useful when you want to delay the next retry attempt for a specific period of time, for example, to more gracefully handle a race condition or backing off after hitting an API rate limit.

If `RetryAtError` is not used, Inngest will use [the default retry backoff policy](https://github.com/inngest/inngest/blob/main/pkg/backoff/backoff.go#L10-L22).

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/step"
)

// Register the function
inngestgo.CreateFunction(
    client,
    inngestgo.FunctionOpts{
        ID: "send-user-email",
    },
    inngestgo.EventTrigger("user/created", nil),
    func(ctx context.Context, input inngestgo.Input[UserCreatedEvent]) (any, error) {
        // Run a step which emails the user.  This automatically retries on error.
        // This returns the fully typed result of the lambda.
        result, err := step.Run(ctx, "on-user-created", func(ctx context.Context) (bool, error) {
            // Run any code inside a step.
            result, err := emails.Send(emails.Opts{})
            return result, err
        })
        if err != nil {
            // This step retried 5 times by default and permanently failed.
            // We delay the next retry attempt by 5 hours
            return nil, inngestgo.RetryAtError(err, time.Now().Add(5*time.Hour))
        }

        return result, nil
    },
)
```

#### TypeScript

## Step errors&#x20;

After a step exhausts all of its retries, it will throw a `StepError` which can be caught and handled in the function handler if desired.

```ts {{ title: "try/catch" }}
inngest.createFunction(
  { id: "send-weather-forecast" },
  { event: "weather/forecast.requested" },
  async ({ event, step }) => {
    let data;

    try {
      data = await step.run('get-public-weather-data', async () => {
        return await fetch('https://api.weather.com/data');
      });
    } catch (err) {
      // err will be an instance of StepError
      // Handle the error by recovering with a different step
      data = await step.run('use-backup-weather-api', async () => {
        return await fetch('https://api.stormwaters.com/data');
      });
    }
    // ...
  }
);
```

```ts {{ title: "Chaining with .catch()" }}
inngest.createFunction(
  { id: "send-weather-forecast" },
  { event: "weather/forecast.requested" },
  async ({ event, step }) => {

    const data = await step
      .run('get-public-weather-data', async () => {
        return await fetch('https://api.example.com/data');
      })
      .catch((err) => {
        // err will be an instance of StepError
        // Recover with a chained step
        return step.run("use-backup-weather-api", () => {
          return await fetch('https://api.stormwaters.com/data');
        });
      });
  }
);
```

```ts {{ title: "Ignoring and logging the error" }}
inngest.createFunction(
  { id: "send-weather-forecast" },
  { event: "weather/forecast.requested" },
  async ({ event, step }) => {

    const data = await step
      .run('get-public-weather-data', async () => {
        return await fetch('https://api.example.com/data');
      })
      // This will swallow the error and log it if it's non critical
      .catch((err) => logger.error(err));
  }
);
```

> **Callout:** Support for handling step errors is available in the Inngest TypeScript SDK starting from version 3.12.0. Prior to this version, wrapping a step in try/catch will not work correctly.

#### Python

## Step errors

After a step exhausts all of its retries, it will throw a `StepError` which can be caught and handled in the function handler if desired.

```python
@client.create_function(
    fn_id="import-item-data",
    retries=0,
    trigger=inngest.TriggerEvent(event="store/import.requested"),
)
async def fn_async(ctx: inngest.Context) -> None:
    def foo() -> None:
        raise ValueError("foo")

    try:
        ctx.step.run("foo", foo)
    except inngest.StepError:
        raise MyError("I am new")
```

#### TypeScript

## Attempt counter

The current attempt number is passed in as input to the function handler. `attempt` is a zero-index number that increments for each retry. The first attempt will be `0`, the second `1`, and so on. The number is reset after a successfully executed step.

```ts
inngest.createFunction(
  { id: "generate-summary" },
  { event: "blog/post.created" },
  async ({ attempt }) => {
    // `attempt` is the zero-index attempt number

    await step.run('call-llm', async () => {
      if (attempt < 2) {
        // Call OpenAI's API two times
      } else {
        // After two attempts to OpenAI, try a different LLM, for example, Mistral
      }
    });
  }
);
```

## Stack traces

When calling functions that return Promises, await the Promise to ensure that the stack trace is preserved. This applies to functions executing in different cycles of the event loop, for example, when calling a database or an external API. This is especially useful when debugging errors in production.

```ts {{ title: "Returning Promise" }}
inngest.createFunction(
  { id: "update-recent-usage" },
  { event: "app/update-recent-usage" },
  async ({ event, step }) => {
    // ...
    await step.run("update in db", () => doSomeWork(event.data));
    // ...
  }
);
```

```ts {{ title: "Awaiting Promise" }}
inngest.createFunction(
  { id: "update-recent-usage" },
  { event: "app/update-recent-usage" },
  async ({ event, step }) => {
    // ...
    await step.run("update in db", async () => {
      return await doSomeWork(event.data);
    });
    // ...
  }
);

```

Please note that immediately returning the Promise will not include a pointer to the calling function in the stack trace. Awaiting the Promise will ensure that the stack trace includes the calling function.


--------------------------------------------------------------------------------
title: "Retries"
source: "https://www.inngest.com/docs/features/inngest-functions/error-retries/retries"
--------------------------------------------------------------------------------

# Retries

By default, in *addition* to the **initial attempt**, Inngest will retry a function or a step up to 4 times until it succeeds. This means that for a function with a default configuration, it will be attempted 5 times in total.

For the function below, if the database write fails then it'll be retried up to 4 times until it succeeds:

#### TypeScript

```ts
inngest.createFunction(
  { id: "click-recorder" },
  { event: "app/button.clicked" },
  async ({ event, attempt }) => {
    await db.clicks.insertOne(event.data); // this code now retries!
  },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "click-recorder"},
	inngestgo.EventTrigger("app/button.clicked", nil),
	func(ctx context.Context, input inngestgo.Input[ButtonClickedEvent]) (any, error) {
		result, err := db.Clicks.InsertOne(input.Event.Data)
		return result, err
	},
)
```

#### Python

```python
@inngest_client.create_function(
    fn_id="click-recorder",
    trigger=inngest.TriggerEvent(event="app/button.clicked"),
)
def record_click(ctx: inngest.Context) -> None:
    db.clicks.insert_one(ctx.event.data)
```

You can configure the number of `retries` by specifying it in your function configuration. Setting the value to `0` will disable retries.

#### TypeScript

```ts
inngest.createFunction(
  {
    id: "click-recorder",
    retries: 10, // choose how many retries you'd like
  },
  { event: "app/button.clicked" },
  async ({ event, step, attempt }) => { /* ... */ },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID:      "click-recorder",
		Retries: 10, // choose how many retries you'd like
	},
	inngestgo.EventTrigger("app/button.clicked", nil),
	func(ctx context.Context, input inngestgo.Input[ButtonClickedEvent]) (any, error) {
		// ...
		return nil, nil
	},
)
```

#### Python

```python
@inngest_client.create_function(
    fn_id="click-recorder",
    retries=10,  # choose how many retries you'd like
    trigger=inngest.TriggerEvent(event="app/button.clicked"),
)
def click_recorder(ctx: inngest.Context) -> None:
    # ...
```

You can customize the behavior of your function based on the number of retries using the `attempt` argument. `attempt` is passed in the function handler's context and is zero-indexed, meaning the first attempt is `0`, the second is `1`, and so on. The `attempt` is incremented every time the function throws an error and is retried, and is reset when steps complete. This allows you to handle attempt numbers differently in each step.

Retries will be performed with backoff according to [the default schedule](https://github.com/inngest/inngest/blob/main/pkg/backoff/backoff.go#L10-L22).

## Steps and Retries

A function can be broken down into multiple steps, where each step is individually executed and retried.

**Each `step.run()` has its own independent retry counter.** The retry configuration you set on your function applies to each individual step, not as a shared pool across all steps. For example, if you configure a function with 5 retries, each `step.run()` will be retried up to 5 times independently.

In the example below, both the "*get-data*" and "*save-data*" steps each get their own set of 4 retries (5 total attempts including the initial attempt). If the "*save-data*" step fails all 5 attempts, it doesn't affect the retry count of the "*get-data*" step - they are completely independent.

#### TypeScript

```ts
inngest.createFunction(
  { id: "sync-systems" },
  { event: "auto/sync.request" },
  async ({ step }) => {
    // Can be retried up to 4 times
    const data = await step.run("get-data", async () => {
      return getDataFromExternalSource();
    });

    // Can also be retried up to 4 times
    await step.run("save-data", async () => {
      return db.syncs.insertOne(data);
    });
  },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "sync-systems"},
	inngestgo.EventTrigger("auto/sync.request", nil),
	func(ctx context.Context, input inngestgo.Input[SyncRequestEvent]) (any, error) {
		// can be retried up to 4 times
		data, err := step.Run(ctx, "get-data", func(ctx context.Context) (any, error) {
			return getDataFromExternalSource()
		})
		if err != nil {
			return nil, err
		}

		// can also be retried up to 4 times
		_, err = step.Run(ctx, "save-data", func(ctx context.Context) (any, error) {
			return db.Syncs.InsertOne(data.(DataType))
		})
		if err != nil {
			return nil, err
		}

		return nil, nil
	},
)
```

#### Python

```python
@inngest_client.create_function(
    fn_id="sync-systems",
    trigger=inngest.TriggerEvent(event="auto/sync.request"),
)
def sync_systems(ctx: inngest.ContextSync) -> None:
    # Can be retried up to 4 times
    data = ctx.step.run("Get data", get_data_from_external_source)

    # Can also be retried up to 4 times
    ctx.step.run("Save data", db.syncs.insert_one, data)
```

> **Callout:** Important: Each step gets its own independent retry counter. You can configure the number of retries for each function. This excludes the initial attempt. A retry count of 4 means that each individual step will be attempted up to 5 times (1 initial attempt + 4 retries).For example, if you have a function with 3 steps and retries: 4 configured, each of the 3 steps can be retried up to 4 times independently. This means you could theoretically have up to 15 total attempts across all steps (5 attempts √ó 3 steps) if every step fails every time.

## Preventing retries with Non-retriable errors

You can throw a [non-retriable error](/docs-markdown/reference/typescript/functions/errors#non-retriable-error) from a step or a function, which will bypass any remaining retries and fail the step or function it was thrown from.

This is useful for when you know an error is permanent and want to stop all execution. In this example, the user doesn't exist, so there's no need to continue to email them.

#### TypeScript

```ts
import { NonRetriableError } from "inngest";

inngest.createFunction(
  { id: "user-weekly-digest" },
  { event: "user/weekly.digest.requested" },
  async ({ event, step }) => {
    const user = await step
      .run("get-user-email", () => {
        return db.users.findOne(event.data.userId);
      })
      .catch((err) => {
        if (err.name === "UserNotFoundError") {
          throw new NonRetriableError("User no longer exists; stopping");
        }

        throw err;
      });

    await step.run("send-digest", () => {
      return sendDigest(user.email);
    });
  },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "user-weekly-digest"},
	inngestgo.EventTrigger("user/weekly.digest.requested", nil),
	func(ctx context.Context, input inngestgo.Input[WeeklyDigestRequestedEvent]) (any, error) {
		user, err := step.Run(ctx, "get-user-email", func(ctx context.Context) (any, error) {
			return db.Users.FindOne(input.Event.Data.UserID)
		})
		if err != nil {
			if stepErr, ok := err.(step.StepError); ok && stepErr.Name == "UserNotFoundError" {
				return nil, inngestgo.NoRetryError(fmt.Errorf("User no longer exists; stopping"))
			}
			return nil, err
		}

		_, err = step.Run(ctx, "send-digest", func(ctx context.Context) (any, error) {
			return sendDigest(user.(UserType).Email)
		})
		if err != nil {
			return nil, err
		}

		return nil, nil
	},
)
```

#### Python

```python
from inngest.errors import NonRetriableError

@inngest_client.create_function(
    fn_id="user-weekly-digest",
    trigger=inngest.TriggerEvent(event="user/weekly.digest.requested"),
)
def user_weekly_digest(ctx: inngest.ContextSync) -> None:
    try:
        user = ctx.step.run("get-user-email", db.users.find_one, ctx.event.data["userId"])
    except Exception as err:
        if err.name == "UserNotFoundError":
            raise NonRetriableError("User no longer exists; stopping")
        raise

    ctx.step.run("send-digest", send_digest, user["email"])
```

## Customizing retry times

Retries are executed with exponential back-off with some jitter, but it's also possible to specify exactly when you'd like a step or function to be retried.

In this example, an external API provided `Retry-After` header with information on when requests can be made again, so you can tell Inngest to retry your function then.

#### TypeScript

```ts
import { RetryAfterError } from 'inngest';

inngest.createFunction(
  { id: "send-welcome-notification" },
  { event: "app/user.created" },
  async ({ event, step }) => {

    const msg = await step.run('send-message', async () => {
      const { success, retryAfter, message } = await twilio.messages.create({
        to: event.data.user.phoneNumber,
        body: "Welcome to our service!",
      });

      if (!success && retryAfter) {
        throw new RetryAfterError("Hit Twilio rate limit", retryAfter);
      }
      
      return { message };
    });
    
  },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "send-welcome-notification"},
	inngestgo.EventTrigger("user.created", nil),
	func(ctx context.Context, input inngestgo.Input[SignedUpEvent]) (any, error) {
		success, retryAfter, err := twilio.Messages.Create(twilio.MessageOpts{
			To:   input.Event.Data.User.PhoneNumber,
			Body: "Welcome to our service!",
		})
		if err != nil {
			return nil, err
		}

		if !success && retryAfter != nil {
			return nil, inngestgo.RetryAtError(fmt.Errorf("Hit Twilio rate limit"), *retryAfter)
		}

		return nil, nil
	}
)
```

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="send-welcome-notification",
    trigger=inngest.TriggerEvent(event="user.created"),
)
def send_welcome_notification(ctx: inngest.ContextSync) -> None:
	success, retryAfter, err = twilio.Messages.Create(twilio.MessageOpts{
		To:   ctx.event.data["user"]["phoneNumber"],
		Body: "Welcome to our service!",
	})

	if not success and retryAfter is not None:
		raise inngest.RetryAfterError("Hit Twilio rate limit", retryAfter)
```


--------------------------------------------------------------------------------
title: "Rollbacks"
source: "https://www.inngest.com/docs/features/inngest-functions/error-retries/rollbacks"
--------------------------------------------------------------------------------

# Rollbacks

Unlike an error being thrown in the main function's body, a failing step (one that has exhausted all retries) will throw a `StepError`. This allows you to handle failures for each step individually, where you can recover from the error gracefully.

If a step failure isn't handled, the error will bubble up to the function itself, which will then be marked as failed.

Below is an attempt to use DALL-E to generate an image from a prompt, and to fall back to Midjourney if it fails. Remember that these calls are split over separate requests, making the code much more durable against timeouts, transient errors, and these dependencies on external APIs.

#### TypeScript

```ts
inngest.createFunction(
  { id: "generate-result" },
  { event: "prompt.created" },
  async ({ event, step }) => {
    // try one AI model, if it fails, try another
    let imageURL: string | null = null;
    let via: "dall-e" | "midjourney";

    try {
      imageURL = await step.run("generate-image-dall-e", () => {
        // open api call to generate image...
      });
      via = "dall-e";
    } catch (err) {
      imageURL = await step.run("generate-image-midjourney", () => {
        // midjourney call to generate image...
      });
      via = "midjourney";
    }

    await step.run("notify-user", () => {
      return pusher.trigger(event.data.channelID, "image-result", {
        imageURL,
        via,
      });
    });
  },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "generate-result"},
	inngestgo.EventTrigger("prompt.created", nil),
	func(ctx context.Context, input inngestgo.Input[PromptCreatedEvent]) (any, error) {
		var (
			imageURL string
			err      error
		)

		via := "dall-e"
		imageURL, err = step.Run(ctx, "generate-image-dall-e", func(ctx context.Context) (string, error) {
			// Open API call to generate image with Dall-E...
		})
		if err != nil {
			// Update how we ran the code.  This could also have been a return from the step.
			via = "midjourney"
			imageURL, err = step.Run(ctx, "generate-image-midjourney", func(ctx context.Context) (string, error) {
				// MidJourney call to generate image...
			})
		}
		if err != nil {
			return nil, err
		}

		_, err = step.Run(ctx, "notify-user", func(ctx context.Context) (any, error) {
			return pusher.Trigger(input.Event.Data.ChannelID, "image-result", map[string]string{
				"imageURL": imageURL.(string),
				"via":      via,
			})
		})
		if err != nil {
			return nil, err
		}

		return nil, nil
	},
)
```

### Simple rollbacks

With this pattern, it's possible to assign a small rollback for each step, making sure that every action is safe regardless of how many steps are being run.

#### TypeScript

```ts
inngest.createFunction(
  { id: "add-data" },
  { event: "app/row.data.added" },
  async ({ event, step }) => {
    // ignore the error - this step is fine if it fails
    await step
      .run("non-critical-step", () => {
        return updateMetric();
      })
      .catch();

    // Add a rollback to a step
    await step
      .run("create-row", async () => {
        const row = await createRow(event.data.rowId);
        await addDetail(event.data.entry);
      })
      .catch((err) =>
        step.run("rollback-row-creation", async () => {
          await removeRow(event.data.rowId);
        }),
      );
  },
);
```

#### Go

```go
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "add-data"},
	inngestgo.EventTrigger("app/row.data.added", nil),
	func(ctx context.Context, input inngestgo.Input[RowDataAddedEvent]) (any, error) {
		_, _ = step.Run(ctx, "non-critical-step", func(ctx context.Context) (any, error) {
			return updateMetric()
		})

		_, err := step.Run(ctx, "create-row", func(ctx context.Context) (any, error) {
			_, err := createRow(input.Event.Data.RowID)
			if err != nil {
				return nil, err
			}
			return addDetail(input.Event.Data.Entry)
		})
		if err != nil {
			_, err = step.Run(ctx, "rollback-row-creation", func(ctx context.Context) (any, error) {
				return removeRow(input.Event.Data.RowID)
			})
			if err != nil {
				return nil, err
			}
		}

		return nil, nil
	},
)
```


--------------------------------------------------------------------------------
title: "Steps & Workflows"
source: "https://www.inngest.com/docs/features/inngest-functions/steps-workflows"
--------------------------------------------------------------------------------

# Steps & Workflows

Steps are fundamental building blocks of Inngest, turning your Inngest Functions into reliable workflows that can runs for months and recover from failures.

**Thinking in Steps**: [Discover by example how steps enable more reliable and flexible functions with step-level error handling, conditional steps and waits.]('/docs-markdown/guides/multi-step-functions')

Once you are familiar with Steps, start adding new capabilities to your Inngest Functions:

**Add sleeps**: [Enable your Inngest Functions to pause by waiting from minutes to months.]('/docs/features/inngest-functions/steps-workflows/sleeps')

**Wait for events**: [Write functions that react to incoming events.]('/docs/features/inngest-functions/steps-workflows/wait-for-event')

**Loop over steps**: [Iterate over large datasets by looping with steps.]('/docs/guides/working-with-loops')

**Parallelize steps**: [Discover how to apply the map-reduce pattern with Steps.]('/docs/guides/step-parallelism')

## How steps work

You might wonder: how do Steps work? Why doesn't an Inngest Function get timed out when running on a Serverless environment?

You can think of steps as an API for expressing checkpoints in your workflow, such as waits or work that might benefit from retries or parallelism:

```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "sync-systems" },
  { event: "auto/sync.request" },
  async ({ step }) => {
    // By wrapping code in step.run, the code will be retried if it throws an error and when successfuly.
    // It's result is saved to prevent unnecessary re-execution
    const data = await step.run("get-data", async () => {
      return getDataFromExternalSource();
    });

    // Can also be retried up to 4 times
    await step.run("save-data", async () => {
      return db.syncs.insertOne(data);
    });
  },
);
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="sync-systems",
    trigger=inngest.TriggerEvent(event="auto/sync.request"),
)
def sync_systems(ctx: inngest.ContextSync) -> None:
    # By wrapping code in step.run, the code will be retried if it throws an error and when successfuly.
    # It's result is saved to prevent unnecessary re-execution
    data = ctx.step.run("Get data", get_data_from_external_source)

    # Can also be retried up to 4 times
    ctx.step.run("Save data", db.syncs.insert_one, data)
```

```go {{ title: "Go" }}
import (
	"context"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadSyncDataInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(client,
		inngestgo.FunctionOpts{ID: "sync-systems"},
		// Functions are triggered by events
		inngestgo.EventTrigger("auto/sync.request", nil),
		func(ctx context.Context, input inngestgo.Input[SyncRequestEvent]) (any, error) {
			// By wrapping code in step.run, the code will be retried if it throws an error and when successfuly.
			// It's result is saved to prevent unnecessary re-execution
			data, err := step.Run(ctx, "get-data", func(ctx context.Context) (any, error) {
				return getDataFromExternalSource()
			})
			if err != nil {
				return nil, err
			}

			// steps can reuse data from previous ones
			// can also be retried up to 4 times
			_, err = step.Run(ctx, "save-data", func(ctx context.Context) (any, error) {
				return InsertIntoDB(data.(DataType))
			})
			if err != nil {
				return nil, err
			}

			return nil, nil
		},
	)
}
```

Each step execution relies on a communication with Inngest's [Durable Execution Engine](/docs-markdown/learn/how-functions-are-executed) which is responsible to:

- Invoking Functions with the correct steps state (current step + previous steps data)
- Gather each step result and schedule the next step to perform

This architecture powers the durability of Inngest Functions with retriable steps and waits from hours to months. Also, when used in a serverless environment, steps benefit from an extended max duration, enabling workflows that both span over months and run for more than 5 minutes!

Explore the following guide for a step-by-step overview of a complete workflow run:

**How Functions are executed**: [A deep dive into Inngest's Durable Execution Engine with a step-by-step workflow run example.]('/docs/learn/how-functions-are-executed')

## SDK References

**"TypeScript SDK"**: [Steps API reference]("/docs/reference/functions/step-run")

**"Python SDK"**: [Steps API reference]("/docs/reference/python/steps/invoke")

**"Go SDK"**: [Steps API reference]("https://pkg.go.dev/github.com/inngest/inngestgo@v0.9.0/step")


--------------------------------------------------------------------------------
title: "Fetch: performing API requests or fetching data&#x20;"
source: "https://www.inngest.com/docs/features/inngest-functions/steps-workflows/fetch"
--------------------------------------------------------------------------------

# Fetch: performing API requests or fetching data&#x20;

The Inngest TypeScript SDK provides a `step.fetch()` API and a `fetch()` utility, enabling you to make requests to third-party APIs or fetch data in a durable way by offloading them to the Inngest Platform:

- `step.fetch()` is a shorthand for making HTTP requests from within an Inngest function, and it also makes it easier to start parallel HTTP requests.
- The `fetch()` utility can be passed to packages that accept a custom `fetch` implementation, such as `axios`.

![Using Fetch offloads the HTTP request to the Inngest Platform](/assets/docs-markdown/features/inngest-functions/steps-workflows/fetch/step-fetch.png)

## Using `step.fetch()`

You can use `step.fetch()` to make HTTP requests within an Inngest function.

`step.fetch()` offloads the HTTP request to the Inngest Platform, so your service does not need to be active and waiting for the response.

```ts {{ title: "src/inngest/functions.ts" }}
import { inngest } from "./client";

export const retrieveTextFile = inngest.createFunction(
  { id: "retrieveTextFile" },
  { event: "textFile/retrieve" },
  async ({ step }) => {
    // The fetching of the text file is offloaded to the Inngest Platform
    const response = await step.fetch(
      "https://example-files.online-convert.com/document/txt/example.txt"
    );

    // The Inngest function run is resumed when the HTTP request is complete
    await step.run("extract-text", async () => {
      const text = await response.text();
      const exampleOccurences = text.match(/example/g);
      return exampleOccurences?.length;
    });
  }
);
```

**"step.fetch() example"**: [See the complete step.fetch() example including the source code and other use cases.]("/docs-markdown/examples/fetch")

`step.fetch()` is useful:

- In serverless environments, to offload long-running HTTP requests that might trigger timeouts.
- As a shorthand for making HTTP requests within an Inngest function, making it easier to start parallel HTTP requests using `Promise.all()`.
- As a best practice to ensure that all HTTP requests are durable and can be inspected in the Inngest Platform or Dev Server.

### `step.fetch()` observability

All `step.fetch()` calls are visible in your [Inngest Traces](/docs-markdown/platform/monitor/observability-metrics), allowing you to monitor and debug your HTTP requests:

![Inngest Traces showing a step.fetch() call](/assets/blog/announcing-step-fetch/step-fetch-trace.png)

## Using the `fetch()` utility

A Fetch API-compatible function is exported, allowing you to make any HTTP requests durable if they're called within an Inngest function.

For example, a `MyProductApi` class that relies on axios can take a `fetch` parameter:

```ts {{ title: "TypeScript" }}
import { fetch } from "inngest";

const api = new MyProductApi({ fetch });

// A call outside an Inngest function will fall back to the global fetch
await api.getProduct(1);

// A call from inside an Inngest function will be made durable and offloaded to the Inngest Platform
inngest.createFunction(
  { id: "my-fn" },
  { event: "product/activated" },
  async () => {
    await api.getProduct(1);
  },
);
```

> **Callout:** ‚ö†Ô∏è fetch() and step.run()Inngest's fetch() calls should not be performed inside of step.run() blocks.
> Doing so will result in fetch() to fallback to the global fetch implementation.Why? The fetch() utility transforms the fetch calls into step.run() calls, which cannot be nested.

### Within steps

By default, using Inngest's `fetch` retains all the functionality of requests made outside of an endpoint, but ensures that those made from inside are durable.

```ts {{ title: "TypeScript" }}
import { fetch as inngestFetch } from 'inngest';
import { generateText } from 'ai';
import { createAnthropic } from '@ai-sdk/anthropic';

// The AI SDK's createAnthropic objects can be passed a custom fetch implementation
const anthropic = createAnthropic({
  fetch: inngestFetch,
});

// NOTE - Using this fetch outside of an Inngest function will fall back to the global fetch
const response = await generateText({
  model: anthropic('claude-3-5-sonnet-20240620'),
  prompt: 'Hello, world!',
});

// A call from inside an Inngest function will be made durable
inngest.createFunction(
  { id: "generate-summary" },
  { event: "post.created" },
  async ({ event }) => {
    // This will use step.fetch automatically!
    const response = await generateText({
      model: anthropic('claude-3-5-sonnet-20240620'),
      prompt: `Summarize the following post: ${event.data.content}`,
    });
  },
);
```

### Using with AI SDK: Disable AI SDK retries

> **Callout:** Important: When using Inngest's fetch with the AI SDK, disable the AI SDK's built-in retry mechanism and let Inngest handle retries instead.

The AI SDK has built-in retry logic that can interfere with Inngest's retry handling, especially when working with long-running models or serverless platforms with timeout limits (e.g., Vercel's 15-minute max timeout).

**Why this matters:**

- When AI SDK retries are enabled alongside Inngest's retry mechanism, the combined retry duration can exceed your platform's timeout limits
- For long-running models (like OpenAI's o3), this is especially problematic
- When a timeout occurs, the error messages can be confusing: Vercel cancels the request, but it appears in Inngest as an "Internal server error" (from Inngest, not Vercel), making debugging difficult

**Recommended configuration:**

```ts {{ title: "generateText() with maxRetries: 0" }}
import { generateText } from 'ai';
import { createOpenAI } from '@ai-sdk/openai';
import { fetch as inngestFetch } from 'inngest';

const openai = createOpenAI({
  fetch: inngestFetch,
});

inngest.createFunction(
  { id: "generate-with-o3" },
  { event: "content/generate" },
  async ({ event }) => {
    // Disable AI SDK retries - let Inngest handle them instead
    const response = await generateText({
      model: openai('o3'),
      prompt: event.data.prompt,
      maxRetries: 0, // Critical: Set to 0 to let Inngest handle retries
    });
    
    return response;
  },
);
```

```ts {{ title: "streamText() with maxRetries: 0" }}
import { streamText } from 'ai';
import { createAnthropic } from '@ai-sdk/anthropic';
import { fetch as inngestFetch } from 'inngest';

const anthropic = createAnthropic({
  fetch: inngestFetch,
});

inngest.createFunction(
  { id: "stream-completion" },
  { event: "completion/stream" },
  async ({ event, step }) => {
    // Disable AI SDK retries for streaming operations
    const result = await streamText({
      model: anthropic('claude-3-5-sonnet-20240620'),
      prompt: event.data.prompt,
      maxRetries: 0, // Let Inngest handle retries
    });
    
    return result;
  },
);
```

By setting `maxRetries: 0` in your AI SDK calls, you:

- Avoid timeout issues on serverless platforms
- Get clearer error messages when failures occur
- Leverage Inngest's retry mechanism, which is designed for long-running operations
- Benefit from Inngest's observability to see exactly what happened during each retry attempt

However, the same `fetch` is also exported as `step.fetch`, allowing you to create your APIs isolated within the function instead:

```ts {{ title: "TypeScript" }}
import { createAnthropic } from '@ai-sdk/anthropic';
import { fetch as inngestFetch } from 'inngest';
import { generateText } from 'ai';

const anthropic = createAnthropic({
  fetch: inngestFetch,
});

inngest.createFunction(
  { id: "generate-summary" },
  { event: "post.created" },
  async ({ step }) => {
    const response = await generateText({
      model: anthropic('claude-3-5-sonnet-20240620'),
      prompt: `Summarize the following post: ${event.data.content}`,
    });
  },
);
```

### Fallbacks

By default, it will gracefully fall back to the global `fetch` if called outside of an Inngest function, though you can also set a custom fallback using the `config` method:

```ts {{ title: "TypeScript" }}
import { fetch } from "inngest";

const api = new MyProductApi({
  fetch: fetch.config({ fallback: myCustomFetch }),
});
```

You can also disable the fallback entirely:

```ts {{ title: "TypeScript" }}
import { fetch } from "inngest";

const api = new MyProductApi({
  fetch: fetch.config({ fallback: undefined }),
});
```

### How it works

Inngest's `fetch` function uses some of the basic building blocks of Inngest to allow seamless creation of optionally durable code. When it's called, it will:

- Check the context in which it's running
- If not in an Inngest function, optionally use the fallback; otherwise,
- Report the request to Inngest
- Inngest makes the request
- Inngest continues the function with the `Response` received from your request

Critically, this means that your service does not have to be active for the duration of the call; we'll continue your function when we have a result, while also keeping it durable!


--------------------------------------------------------------------------------
title: "Sleeps"
source: "https://www.inngest.com/docs/features/inngest-functions/steps-workflows/sleeps"
--------------------------------------------------------------------------------

# Sleeps

Two step methods, `step.sleep` and `step.sleepUntil`, are available to pause the execution of your function for a specific amount of time. Your function can sleep for seconds, minutes, or days, up to a maximum of one year.

Using sleep methods can avoid the need to run multiple cron jobs or use additional queues. For example, Sleeps enable you to create a user onboarding workflow that sequences multiple actions in time: first send a welcome email, then send a tutorial each day for a week.

## How Sleeps work

`step.sleep` and `step.sleepUntil` tell Inngest to resume execution of your function at a future time. Your code doesn't need to be running during the sleep interval, allowing sleeps to be used in any environment, even serverless platforms.

A Function paused by a sleeping Step doesn't affect your account capacity; i.e. it does not count against your plan's concurrency limit. A sleeping Function doesn't count against any [concurrency policy](/docs-markdown/guides/concurrency) you've set on the function, either.

## Pausing an execution for a given time

#### TypeScript

Use `step.sleep()` to pause the execution of your function for a specific amount of time.

```ts
export default inngest.createFunction(
  { id: "send-delayed-email" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    await step.sleep("wait-a-couple-of-days", "2d");
    // Do something else
  }
);
```

Check out the [`step.sleep()` TypeScript reference.](/docs-markdown/reference/functions/step-sleep)

#### Python

Use `step.sleep()` to pause the execution of your function for a specific amount of time.

```py
@inngest_client.create_function(
    fn_id="my_function",
    trigger=inngest.TriggerEvent(event="app/my_function"),
)
async def fn(ctx: inngest.Context) -> None:
    await ctx.step.sleep("zzz", datetime.timedelta(seconds=2))
```

Check out the [`step.sleep()` Python reference.](/docs-markdown/reference/python/steps/sleep)

#### Go

Use `step.Sleep()` to pause the execution of your function for a specific amount of time.

```go
func AccountCreated(ctx context.Context, input inngestgo.Input[AccountCreatedEvent]) (any, error) {
  // Sleep for a second, minute, hour, week across server restarts.
  step.Sleep(ctx, "initial-delay", time.Second)

  // ...

  return nil, nil
}
```

Check out the [`step.Sleep()` Go reference.](https://pkg.go.dev/github.com/inngest/inngestgo@v0.9.0/step#Sleep)

## Pausing an execution until a given date

#### TypeScript

Use `step.sleepUntil()` to pause the execution of your function until a specific date time.

```ts
export default inngest.createFunction(
  { id: "send-scheduled-reminder" },
  { event: "app/reminder.scheduled" },
  async ({ event, step }) => {
    const date = new Date(event.data.remind_at);
    await step.sleepUntil("wait-for-scheduled-reminder", date);
    // Do something else
  }
);
```

Check out the [`step.sleepUntil()` TypeScript reference.](/docs-markdown/reference/functions/step-sleep-until)

#### Python

Use `step.sleep_until()` to pause the execution of your function until a specific date time.

```py
@inngest_client.create_function(
    fn_id="my_function",
    trigger=inngest.TriggerEvent(event="app/my_function"),
)
async def fn(ctx: inngest.Context) -> None:
    await ctx.step.sleep_until(
        "zzz",
        datetime.datetime.now() + datetime.timedelta(seconds=2),
    )
```

Check out the [`step.sleep_until()` Python reference.](/docs-markdown/reference/python/steps/sleep-until)

#### Go

*Sleep until a given date is not yet available in the Go SDK.*

> **Callout:** Sleeps and trace/log historyYou may notice that Inngest Cloud's Function Runs view doesn't show function runs that use sleeps longer than your Inngest plan's trace & log history limit, even though the functions are still sleeping and will continue to run as expected. This is a known limitation in our current dashboard and we're working to improve it.In the meantime:Rest assured that your sleeping functions are still sleeping and will resume as scheduled, even if they're not visible in the Function Runs list.Given a function run's ID, you can inspect its status using Inngest Cloud's Quick Search feature (Ctrl-K or ‚åòK) or the REST API.


--------------------------------------------------------------------------------
title: "AI Inference&#x20;"
source: "https://www.inngest.com/docs/features/inngest-functions/steps-workflows/step-ai-orchestration"
--------------------------------------------------------------------------------

# AI Inference&#x20;

You can build complex AI workflows and call model providers as steps using two-step methods, `step.ai.infer()` and `step.ai.wrap()`, or our AgentKit SDK.  They work with any model provider, and all offer full AI observability:

- `step.ai.wrap()`  wraps other AI SDKs (OpenAI, Anthropic, and Vercel AI SDK) as a step, augmenting the observability of your Inngest Functions with information such as prompts and tokens used.
- `step.ai.infer()` offloads the inference request to Inngest's infrastructure, pausing your function execution until the request finishes.  This can be a significant cost saver if you deploy to serverless functions
- [AgentKit](https://agentkit.inngest.com) allows you to easily create single model calls or agentic workflows.

### Benefits

Using `step.ai` or [AgentKit](https://agentkit.inngest.com) allows you to:

- Automatically monitor AI usage in production to ensure quality output
- Easily iterate and test prompts in the dev server
- Track requests and responses from foundational inference providers
- Track how inference calls work together in multi-step or agentic workflows

## Step tools: `step.ai`  &#x20;

### `step.ai.infer()`

Using `step.ai.infer()` allows you to call any inference provider's endpoints by offloading it to Inngest's infrastructure.
All requests and responses are automatically tracked within your workflow traces.

**Request offloading**

On serverless environments, your function is not executing while the request is in progress ‚Äî which means you don't pay for function execution while waiting for the provider's response.
Once the request finishes, your function restarts with the inference result's data.  Inngest never logs or stores your API keys or authentication headers.  Authentication originates from your own functions.

Here's an example which calls OpenAI:

```ts {{ title: "TypeScript" }}
export default inngest.createFunction(
  { id: "summarize-contents" },
  { event: "app/ticket.created" },
  async ({ event, step }) => {

    // This calls your model's chat endpoint, adding AI observability,
    // metrics, datasets, and monitoring to your calls.
    const response = await step.ai.infer("call-openai", {
      model: step.ai.models.openai({ model: "gpt-4o" }),
      // body is the model request, which is strongly typed depending on the model
      body: {
        messages: [{
          role: "assistant",
          content: "Write instructions for improving short term memory",
        }],
      },
    });

    // The response is also strongly typed depending on the model.
    return response.choices;
  }
);
```

```py {{ title: "Python" }}
import inngest
from inngest.experimental import ai

client = inngest.Inngest(app_id="my-app")

@client.create_function(
    fn_id="summarize-contents",
    trigger=inngest.TriggerEvent(event="app/ticket.created"),
)
async def summarize_contents(ctx: inngest.Context) -> object:
    # This calls your model's chat endpoint, adding AI observability,s
    # metrics, datasets, and monitoring to your calls.
    res = await ctx.step.ai.infer(
        "call-openai",
        adapter=ai.openai.Adapter(
            auth_key="sk-openai-000000",
            model="gpt-4o",
        ),
        # body is the model request
        body={
            "messages": [
                {
                    "role": "assistant",
                    "content": "Write instructions for improving short term memory",
                }
            ],
        },
    )

    # The response is a dict matching the provider's response
    return res["choices"]
```

**"PDF processing with Claude Sonnet and step.ai.infer()"**: [Use step.ai.infer() to process a PDF with Claude Sonnet.]("https://github.com/inngest/inngest-js/tree/main/examples//step-ai/anthropic-claude-pdf-processing/#readme")

### `step.ai.wrap()`  (TypeScript only)

Using `step.ai.wrap()` allows you to wrap other TypeScript AI SDKs, treating each inference call as a step.  This allows you to easily convert AI calls to steps with full observability without changing much application-level code:

```ts {{ title: "Vercel AI SDK" }}
import { generateText } from "ai"
import { openai } from "@ai-sdk/openai"

export default inngest.createFunction(
  { id: "summarize-contents" },
  { event: "app/ticket.created" },
  async ({ event, step }) => {

    // This calls `generateText` with the given arguments, adding AI observability,
    // metrics, datasets, and monitoring to your calls.
    const { text } = await step.ai.wrap("using-vercel-ai", generateText, {
      model: openai("gpt-4-turbo"),
      prompt: "What is love?"
    });

  }
);
```

```ts {{ title: "Anthropic SDK" }}
import Anthropic from '@anthropic-ai/sdk';
const anthropic = new Anthropic();

export default inngest.createFunction(
  { id: "summarize-contents" },
  { event: "app/ticket.created" },
  async ({ event, step }) => {

    // This calls `generateText` with the given arguments, adding AI observability,
    // metrics, datasets, and monitoring to your calls.
    const result = await step.ai.wrap("using-anthropic", anthropic.messages.create, {
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 1024,
      messages: [{ role: "user", content: "Hello, Claude" }],
    });

  }
);
```

In this case, instead of calling the SDK directly, you specify the SDK function you want to call and the function's arguments separately within `step.ai.wrap()`.

### Supported providers

The list of current providers supported for `step.ai.infer()` is:

- `openai`, including any OpenAI compatible API such as Perplexity
- `gemini`
- `anthropic`
- `grok`
- `azure-openai`

### Limitations

- Streaming responses from providers is coming soon, alongside real-time support with Inngest functions.

- When using `step.ai.wrap` with sdk clients that require client instance context to be preserved between
  invocations, currently it's necessary to bind the client call outside the `step.ai.wrap` call like so:

```ts {{ title: "Wrap Anthropic SDK" }}
import Anthropic from "@anthropic-ai/sdk";
const anthropic = new Anthropic();

export const anthropicWrapGenerateText = inngest.createFunction(
  { id: "anthropic-wrap-generateText" },
  { event: "anthropic/wrap.generate.text" },
  async ({ event, step }) => {
    //
    // Will fail because anthropic client requires instance context
    // to be preserved across invocations.
    await step.ai.wrap(
      "using-anthropic",
      anthropic.messages.create,
      {
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 1024,
        messages: [{ role: "user", content: "Hello, Claude" }],
      },
    );

    //
    // Will work beccause we bind to preserve instance context
    const createCompletion = anthropic.messages.create.bind(anthropic.messages);
    await step.ai.wrap(
      "using-anthropic",
      createCompletion,
      {
        model: "claude-3-5-sonnet-20241022",
        max_tokens: 1024,
        messages: [{ role: "user", content: "Hello, Claude" }],
      },
    );
  },
);
```

```ts {{ title: "Wrap OpenAI SDK" }}
import OpenAI from "openai";
const openai = new OpenAI({ apiKey: OPENAI_API_KEY });

export const openAIWrapCompletionCreate = inngest.createFunction(
  { id: "opeai-wrap-completion-create" },
  { event: "openai/wrap.completion.create" },
  async ({ event, step }) => {
    //
    // Will fail because anthropic client requires instance context
    // to be preserved across invocations.
    await step.ai.wrap(
      "openai.wrap.completions",
      openai.chat.completions.create,
      {
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          {
            role: "user",
            content: "Write a haiku about recursion in programming.",
          },
        ],
      },
    );

    //
    // Will work beccause we bind to preserve instance context
    const createCompletion = openai.chat.completions.create.bind(
      openai.chat.completions,
    );

    const response = await step.ai.wrap(
      "openai-wrap-completions",
      createCompletion,
      {
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: "You are a helpful assistant." },
          {
            role: "user",
            content: "Write a haiku about recursion in programming.",
          },
        ],
      },
    );
  },
);
```

- When using `step.ai.wrap`, you can edit prompts and rerun steps in the dev server.
  But, arguments must be JSON serializable.

```ts {{ title: "Vercel AI SDK" }}
import { generateText as vercelGenerateText } from "ai";
import { openai as vercelOpenAI } from "@ai-sdk/openai";

export const vercelWrapGenerateText = inngest.createFunction(
  { id: "vercel-wrap-generate-text" },
  { event: "vercel/wrap.generate.text" },
  async ({ event, step }) => {
    //
    // Will work but you will not be able to edit the prompt and rerun the step in the dev server.
    await step.ai.wrap(
      "vercel-openai-generateText",
      vercelGenerateText,
      {
        model: vercelOpenAI("gpt-4o-mini"),
        prompt: "Write a haiku about recursion in programming.",
      },
    );

    //
    // Will work and you will be able to edit the prompt and rerun the step in the dev server because
    // the arguments to step.ai.wrap are JSON serializable.
    const args = {
      model: "gpt-4o-mini",
      prompt: "Write a haiku about recursion in programming.",
    };

    const gen = ({ model, prompt }: { model: string; prompt: string }) =>
      vercelGenerateText({
        model: vercelOpenAI(model),
        prompt,
      });

    await step.ai.wrap("using-vercel-ai", gen, args);
  },
);
```

- `step.ai.wrap's` Typescript definition will for the most part infer allowable inputs based on the
  signature of the wrapped function. However, in some cases where the wrapped function contains complex
  overloads, such as Vercel's `generateObject`, it may be necessary to type cast.

*Note*: Future version of the Typescript SDK will correctly infer these complex types, but for now we
require type casting to ensure backward compatibility.

```ts {{ title: "Vercel AI SDK" }}
import { generateObject as vercelGenerateObject } from "ai";
import { openai as vercelOpenAI } from "@ai-sdk/openai";

export const vercelWrapSchema = inngest.createFunction(
  { id: "vercel-wrap-generate-object" },
  { event: "vercel/wrap.generate.object" },
  async ({ event, step }) => {
    //
    // Calling generateObject directly is fine
    await vercelGenerateObject({
      model: vercelOpenAI("gpt-4o-mini"),
      schema: z.object({
        recipe: z.object({
          name: z.string(),
          ingredients: z.array(
            z.object({ name: z.string(), amount: z.string() }),
          ),
          steps: z.array(z.string()),
        }),
      }),
      prompt: "Generate a lasagna recipe.",
    });

    //
    // step.ai.wrap requires type casting
    await step.ai.wrap(
      "vercel-openai-generateObject",
      vercelGenerateObject,
      {
        model: vercelOpenAI("gpt-4o-mini"),
        schema: z.object({
          recipe: z.object({
            name: z.string(),
            ingredients: z.array(
              z.object({ name: z.string(), amount: z.string() }),
            ),
            steps: z.array(z.string()),
          }),
        }),
        prompt: "Generate a lasagna recipe.",
      } as any,
    );
  },
);
```

## AgentKit: AI and agent orchestration&#x20;

AgentKit is a simple, standardized way to implement model calling ‚Äî either as individual calls, a complex workflow, or agentic flows.

Here's an example of a single model call:

```ts {{ title: "TypeScript" }}

import { Agent, agenticOpenai as openai, createAgent } from "@inngest/agent-kit";
export default inngest.createFunction(
  { id: "summarize-contents" },
  { event: "app/ticket.created" },
  async ({ event, step }) => {

    // Create a new agent with a system prompt (you can add optional tools, too)
    const writer = createAgent({
      name: "writer",
      system: "You are an expert writer.  You write readable, concise, simple content.",
      model: openai({ model: "gpt-4o", step }),
    });

    // Run the agent with an input.  This automatically uses steps
    // to call your AI model.
    const { output } = await writer.run("Write a tweet on how AI works");
  }
);

```

[Read the full AgentKit docs here](https://agentkit.inngest.com) and [see the code on GitHub](https://github.com/inngest/agent-kit).


--------------------------------------------------------------------------------
title: "Wait for an Event"
source: "https://www.inngest.com/docs/features/inngest-functions/steps-workflows/wait-for-event"
--------------------------------------------------------------------------------

# Wait for an Event

One step method is available to pause a Function's run until a given event is sent.

This is a useful pattern to react to specific user actions (for example, implement "Human in the loop" in AI Agent workflows).

#### TypeScript

Use `step.waitForEvent()` to wait for a particular event to be received before continuing. It returns a `Promise` that is resolved with the received event or `null` if the event is not received within the timeout.

```ts
export default inngest.createFunction(
  { id: "send-onboarding-nudge-email" },
  { event: "app/account.created" },
  async ({ event, step }) => {
    const onboardingCompleted = await step.waitForEvent(
      "wait-for-onboarding-completion",
      { event: "app/onboarding.completed", timeout: "3d", match: "data.userId" }
    );
    if (!onboardingCompleted) {
      // if no event is received within 3 days, onboardingCompleted will be null
    } else {
      // if the event is received, onboardingCompleted will be the event payload object
    }
  }
);
```

Check out the [`step.waitForEvent()` TypeScript reference.](/docs-markdown/reference/functions/step-wait-for-event)

To add a simple time based delay to your code, use [`step.sleep()`](/docs-markdown/reference/functions/step-sleep) instead.

## Examples

### Dynamic functions that wait for additional user actions

Below is an example of an Inngest function that creates an Intercom or Customer.io-like drip email campaign, customized based on

```ts
export default inngest.createFunction(
  { id: "onboarding-email-drip-campaign" },
  { event: "app/account.created" },
  async ({ event, step }) => {
    // Send the user the welcome email immediately
    await step.run("send-welcome-email", async () => {
      await sendEmail(event.user.email, "welcome");
    });

    // Wait up to 3 days for the user to complete the final onboarding step
    // If the event is received within these 3 days, onboardingCompleted will be the
    // event payload itself, if not it will be null
    const onboardingCompleted = await step.waitForEvent("wait-for-onboarding", {
      event: "app/onboarding.completed",
      timeout: "3d",
      // The "data.userId" must match in both the "app/account.created" and
      // the "app/onboarding.completed" events
      match: "data.userId",
    });

    // If the user has not completed onboarding within 3 days, send them a nudge email
    if (!onboardingCompleted) {
      await step.run("send-onboarding-nudge-email", async () => {
        await sendEmail(event.user.email, "onboarding_nudge");
      });
    } else {
      // If they have completed onboarding, send them a tips email
      await step.run("send-tips-email", async () => {
        await sendEmail(event.user.email, "new_user_tips");
      });
    }
  }
);
```

### Advanced event matching with `if`

For more complex functions, you may want to match the event payload against some other value. This could be a hard coded value like a billing plan name, a greater than filter for a number value or a value returned from a previous step.

In this example, we have built an AI blog post generator which returns three ideas to the user to select. Then when the user selects an idea from that batch of ideas, we generate an entire blog post and save it.

```ts
export default inngest.createFunction(
  { id: "generate-blog-post-with-ai" },
  { event: "ai/post.generator.requested" },
  async ({ event, step }) => {
    // Generate a number of suggestions for topics with OpenAI
    const generatedTopics = await step.run("generate-topic-ideas", async () => {
      const completion = await openai.createCompletion({
        model: "text-davinci-003",
        prompt: helpers.topicIdeaPromptWrapper(event.data.prompt),
        n: 3,
      });
      return {
        completionId: completion.data.id,
        topics: completion.data.choices,
      };
    });

    // Send the topics to the user via Websockets so they can select one
    // Also send the completion id so we can match that later
    await step.run("send-user-topics", () => {
      pusher.sendToUser(event.data.userId, "topics_generated", {
        sessionId: event.data.sessionId,
        completionId: generatedTopics.completionId,
        topics: generatedTopics.topics,
      });
    });

    // Wait up to 5 minutes for the user to select a topic
    // Ensuring the topic is from this batch of suggestions generated
    const topicSelected = await step.waitForEvent("wait-for-topic-selection", {
      event: "ai/post.topic.selected",
      timeout: "5m",
      // "async" is the "ai/post.topic.selected" event here:
      if: `async.data.completionId == "${generatedTopics.completionId}"`,
    });

    // If the user selected a topic within 5 minutes, "topicSelected" will
    // be the event payload, otherwise it is null
    if (topicSelected) {
      // Now that we've confirmed the user selected their topic idea from
      // this batch of suggestions, let's generate a blog post
      await step.run("generate-blog-post-draft", async () => {
        const completion = await openai.createCompletion({
          model: "text-davinci-003",
          prompt: helpers.blogPostPromptWrapper(topicSelected.data.prompt),
        });
        // Do something with the blog post draft like save it or something else...
        await blog.saveDraft(completion.data.choices[0]);
      });
    }
  }
);
```

#### Python

Use `step.wait_for_event()` to wait for a particular event to be received before continuing.

```py
@inngest_client.create_function(
    fn_id="my_function",
    trigger=inngest.TriggerEvent(event="app/my_function"),
)
async def fn(ctx: inngest.Context) -> None:
    res = await ctx.step.wait_for_event(
        "wait",
        event="app/wait_for_event.fulfill",
        timeout=datetime.timedelta(seconds=2),
    )
```

Check out the [`step.wait_for_event()` Python reference.](/docs-markdown/reference/python/steps/wait-for-event)

#### Go

Use `step.waitForEvent()` to wait for a particular event to be received before continuing. It either returns the received event data or a `step.ErrEventNotReceived` error.

```go
func AccountCreated(ctx context.Context, input inngestgo.Input[AccountCreatedEvent]) (any, error) {
  // Sleep for a second, minute, hour, week across server restarts.
  opened, err = step.waitForEvent(ctx, "wait-for-open", opts.WaitForEventOpts{
      Event: "email/mail.opened",
      If:	inngestgo.StrPtr(fmt.Sprintf("async.data.id == %s", strconv.Quote("my-id"))),
      Timeout: 24 * time.Hour,
  })

  if err == step.ErrEventNotReceived {
  	// A function wasn't created within 3 days.  Send a follow-up email.
  	step.Run(ctx, "follow-up-email", func(ctx context.Context) (any, error) {
  		// ...
  		return true, nil
  	})
  	return nil, nil
  }

  // ...

  return nil, nil
}
```

Check out the [`step.WaitForEvent()` Go reference.](https://pkg.go.dev/github.com/inngest/inngestgo@v0.9.0/step#WaitForEvent)

> **Callout:** Preventing race conditionsThe "wait for event" method begins listening for new events from when the code is executed. This means that events sent before the function is executed will not be handled by the wait.To avoid race condition, always double-check the flow of events going through your functions.Note: The "wait for event" mechanism will soon provide a "lookback" feature, including events from a given past timeframe.


--------------------------------------------------------------------------------
title: "Middleware"
source: "https://www.inngest.com/docs/features/middleware"
--------------------------------------------------------------------------------

# Middleware

Middleware allows your code to run at various points in an Inngest client's lifecycle, such as during a function's execution or when sending an event.

This can be used for a wide range of uses:

**Custom observability**: [Add custom logging, tracing or helpers to your Inngest Functions.]('/docs-markdown/features/middleware/create')

**Dependency Injection**: [Provide shared client instances (ex, OpenAI) to your Inngest Functions.]('/docs/features/middleware/dependency-injection')

**Encryption Middleware**: [End-to-end encryption for events, step output, and function output.]('/docs-markdown/features/middleware/encryption-middleware')

**Sentry Middleware**: [Quickly setup Sentry for your Inngest Functions.]('/docs/features/middleware/sentry-middleware')

## Middleware SDKs support

Middleware are available in the [TypeScript SDK](/docs/reference/middleware/typescript)  and [Python SDK](/docs-markdown/reference/python/middleware/lifecycle) .

Support in the Go SDK in planned.

## Middleware lifecycle

Middleware can be registered at the Inngest clients or functions level.

Adding middleware contributes to an overall "stack" of middleware. If you register multiple middlewares, the SDK will group and run hooks for each middleware in the following order:

1. Middleware registered on the **client**, in descending order
2. Middleware registered on the **function**, in descending order

For example:

```ts {{ title: "TypeScript" }}
const inngest = new Inngest({
  id: "my-app",
  middleware: [
    logMiddleware, // This is executed first
    errorMiddleware, // This is executed second
  ],
});

inngest.createFunction(
  {
    id: "example",
    middleware: [
      dbSetupMiddleware, // This is executed third
      datadogMiddleware, // This is executed fourth
    ],
  },
  { event: "test" },
  async () => {
    // ...
  }
);
```

```py {{ title: "Python" }}
inngest_client = inngest.Inngest(
    app_id="my_app",
    middleware=[
        LogMiddleware, # This is executed first
        ErrorMiddleware # This is executed second
    ],
)

# ...

@inngest_client.create_function(
    fn_id="import-product-images",
    trigger=inngest.TriggerEvent(event="shop/product.imported"),
    middleware=[
        DbSetupMiddleware, # This is executed third
        DatadogMiddleware # This is executed fourth
    ],
)
async def fn(ctx: inngest.Context):
    # ...

```

Learn more about the Middleware hooks and their execution order in ["Creating a Middleware"](/docs-markdown/features/middleware/create).


--------------------------------------------------------------------------------
title: "Creating middleware"
source: "https://www.inngest.com/docs/features/middleware/create"
--------------------------------------------------------------------------------

# Creating middleware

Creating middleware means defining the lifecycles and subsequent hooks in those lifecycles to run code in. Lifecycles are actions such as a function run or sending events, and individual hooks within those are where we run code, usually with a *before* and *after* step.

#### TypeScript

A Middleware is created using the `InngestMiddleware` class.

**`new InngestMiddleware(options): InngestMiddleware`**

```ts
// Create a new middleware
const myMiddleware = new InngestMiddleware({
  name: "My Middleware",
  init: () => {
      return {};
  },
});

// Register it on the client
const inngest = new Inngest({
  id: "my-app",
  middleware: [myMiddleware],
});
```

#### Python

A Middleware is created using the `inngest.Middleware` class.

**`class MyMiddleware(inngest.Middleware):`**

```py
import inngest

class MyMiddleware(inngest.Middleware):
    def __init__(
        self,
        client: inngest.Inngest,
        raw_request: object,
    ) -> None:
        #  ...

    async def before_send_events( self, events: list[inngest.Event]) -> None:
        print(f"Sending {len(events)} events")

    async def after_send_events(self, result: inngest.SendEventsResult) -> None:
        print("Done sending events")

inngest_client = inngest.Inngest(
    app_id="my_app",
    middleware=[MyMiddleware],
)
```

## Initialization

#### TypeScript

As you can see above, we start with the `init` function, which is called when the client is initialized.

```ts
import { InngestMiddleware } from "inngest";

new InngestMiddleware({
  name: "Example Middleware",
  init() {
    // This runs when the client is initialized
    // Use this to set up anything your middleware needs
    return {};
  },
});
```

#### Python

As you can see above, we start with the `__init__` method, which is called when the client is initialized.

```py
import inngest

    class MyMiddleware(inngest.Middleware):
        def __init__(
            self,
            client: inngest.Inngest,
            raw_request: object,
        ) -> None:
            # This runs when the client is initialized
            # Use this to set up anything your middleware needs
            #  ...
```

Function registration, lifecycles, and hooks can all be with synchronous or `async` functions. This makes it easy for our initialization handler to do some async work, like setting up a database connection.

#### TypeScript

```ts
new InngestMiddleware({
name: "Example Middleware",
async init() {
    const db = await connectToDatabase();

    return {};
},
});
```

#### Python

```py
import inngest

    class MyMiddleware(inngest.Middleware):
        def __init__(
            self,
            client: inngest.Inngest,
            raw_request: object,
        ) -> None:
            #  ...connect to database
```

All lifecycle and hook functions can be synchronous or `async` functions - the SDK will always wait until a middleware's function has resolved before continuing to the next one.

> **Callout:** As it's possible for an application to use multiple Inngest clients, it's recommended to always initialize dependencies within the initializer function/method, instead of in the global scope.

## Specifying lifecycles and hooks

#### TypeScript

Notice we're returning an empty object `{}`. From here, we can instead return the lifecycles we want to use for this client. See the [Middleware - Lifecycle - Hook reference](/docs-markdown/reference/middleware/lifecycle#hook-reference) for a full list of available hooks.

```ts
new InngestMiddleware({
name: "Example Middleware",
async init() {
    // 1. Use init to set up dependencies
    // 2. Use return values to group hooks by lifecycle: - "onFunctionRun" "onSendEvent"
    return {
    onFunctionRun({ ctx, fn, steps }) {
        // 3. Use the lifecycle function to pass dependencies into hooks
        // 4. Return any hooks that you want to define for this action
        return {
        // 5. Define the hook that runs at a specific stage for this lifecycle.
        beforeExecution() {
            // 6. Define your hook
        },
        };
    },
    };
},
});
```

Here we use the `beforeExecution()` hook within the `onFunctionRun()` lifecycle.

The use of [closures](https://developer.mozilla.org/en-US/docs-markdown/Web/JavaScript/Closures) here means that our `onFunctionRun()` lifecycle can access anything from the middleware's initialization, like our `db` connection.

`onFunctionRun()` here is also called for every function execution, meaning you can run code specific to this execution without maintaining any global state. We can even conditionally register hooks based on incoming arguments. For example, here we only register a hook for a specific event trigger:

```ts
new InngestMiddleware({
name: "Example Middleware",
async init() {
    return {
    onFunctionRun({ ctx, fn, steps }) {
        // Register a hook only if this event is the trigger
        if (ctx.event.name === "app/user.created") {
        return {
            beforeExecution() {
            console.log("Function executing with user created event");
            },
        };
        }

        // Register no hooks if the trigger was not `app/user.created`
        return {};
    },
    };
},
});
```

Learn more about hooks with:

- [Lifecycle](/docs-markdown/reference/middleware/lifecycle) - middleware ordering and see all available hooks
- [TypeScript](/docs-markdown/reference/middleware/typescript) - how to affect input and output types and values

#### Python

You might have notice that our custom middleware defines custom method such as `before_send_events` and `after_send_events`. Those methods, called hooks, enable your middleware
to hook itself to specific steps of the Function and Steps execution lifecycle.

```py
import inngest

class MyMiddleware(inngest.Middleware):
    def __init__(
        self,
        client: inngest.Inngest,
        raw_request: object,
    ) -> None:
        #  ...

    async def before_send_events( self, events: list[inngest.Event]) -> None:
        # called before an event is sent from within a Function or Step
        print(f"Sending {len(events)} events")

    async def after_send_events(self, result: inngest.SendEventsResult) -> None:
        # called after an event is sent from within a Function or Step
        print("Done sending events")

```

You can find the [full list of available hooks in the Python SDK reference](/docs-markdown/reference/python/middleware/lifecycle).

## Adding configuration

It's common for middleware to require additional customization or options from developers. For this, we recommend creating a function that takes in some options and returns the middleware.

#### TypeScript

```ts {{ title: "inngest/middleware/myMiddleware.ts" }}
import { InngestMiddleware } from "inngest";

export const createMyMiddleware = (logEventOutput: string) => {
return new InngestMiddleware({
    name: "My Middleware",
    init() {
    return {
        onFunctionRun({ ctx, fn, steps }) {
        if (ctx.event.name === logEventOutput) {
            return {
            transformOutput({ result, step }) {
                console.log(
                `${logEventOutput} output: ${JSON.stringify(result)}`
                );
            },
            };
        }

        return {};
        },
    };
    },
});
};
```

```ts
import { createMyMiddleware } from "./middleware/myMiddleware";

export const inngest = new Inngest({
id: "my-client",
middleware: [createMyMiddleware("app/user.created")],
});
```

> **Callout:** Make sure to let TypeScript infer the output of the function instead of strictly typing it; this helps Inngest understand changes to input and output of arguments. See Middleware - TypeScript for more information.

#### Python

Adding configuration to a custom middleware can be achieved by adding a `factory()` class method, leveraging the [Factory pattern](https://en.wikipedia.org/wiki/Factory_method_pattern).

For example, let's add a `secret_key` configuration option to our `MyMiddleware` middleware:

```py
import inngest

class MyMiddleware(inngest.Middleware):
    def __init__(
        self,
        client: inngest.Inngest,
        raw_request: object,
    ) -> None:
        #  ...

    @classmethod
    def factory(
        cls,
        secret_key: typing.Union[bytes, str],
    ) -> typing.Callable[[inngest.Inngest, object], MyMiddleware]:
        def _factory(
            client: inngest.Inngest,
            raw_request: object,
        ) -> MyMiddleware:
            return cls(
                client,
                raw_request,
                secret_key,
            )

        return _factory

    async def before_send_events( self, events: list[inngest.Event]) -> None:
        # called before an event is sent from within a Function or Step
        print(f"Sending {len(events)} events")

    async def after_send_events(self, result: inngest.SendEventsResult) -> None:
        # called after an event is sent from within a Function or Step
        print("Done sending events")
```

Our middleware can now be registered as follow:

```py
inngest_client = inngest.Inngest(
    app_id="my_app",
    middleware=[MyMiddleware.factory(_secret_key)],
)
```

## Next steps

Check out our pre-built middleware and examples:

**Dependency Injection**: [Provide shared client instances (ex, OpenAI) to your Inngest Functions.]('/docs-markdown/features/middleware/dependency-injection')

**Encryption Middleware**: [End-to-end encryption for events, step output, and function output.]('/docs-markdown/features/middleware/encryption-middleware')

**Sentry Middleware**: [Quickly setup Sentry for your Inngest Functions.]('/docs/features/middleware/sentry-middleware')

**Datadog middleware**: [Add tracing with Datadog under a few minutes.]('/docs/examples/track-failures-in-datadog')

**Cloudflare Workers & Hono middleware**: [Access environment variables within Inngest functions.]('/docs/examples/middleware/cloudflare-workers-environment-variables')


--------------------------------------------------------------------------------
title: "Using Middleware for Dependency Injection"
source: "https://www.inngest.com/docs/features/middleware/dependency-injection"
--------------------------------------------------------------------------------

# Using Middleware for Dependency Injection

Inngest Functions running in the same application often need to share common clients instances such as database clients or third-party
libraries.

The following is an example of adding a OpenAI client to all Inngest functions, allowing them immediate access without needing to create the client themselves.

#### typescript-middleware

We can use the `dependencyInjectionMiddleware` to add arguments to a
function's input.

Check out the [TypeScript example](?guide=typescript) for a customized middleware.

```ts
import { dependencyInjectionMiddleware } from "inngest";
import OpenAI from 'openai';

const openai = new OpenAI();

const inngest = new Inngest({
  id: 'my-app',
  middleware: [
    dependencyInjectionMiddleware({ openai }),
  ],
});
```

Our Inngest Functions can now access the OpenAI client through the context:

```ts
inngest.createFunction(
 { name: "user-create" },
 { event: "app/user.create" },
 async ({ openai }) => {
   const chatCompletion = await openai.chat.completions.create({
     messages: [{ role: "user", content: "Say this is a test" }],
     model: "gpt-3.5-turbo",
   });

   // ...
 },
);

```

> **Callout:** üí° Types are inferred from middleware outputs, so your Inngest functions will see an appropriately-typed openai property in their input.

Explore other examples in the [TypeScript SDK Middleware examples page](/docs-markdown/reference/middleware/examples).

### Advanced mutation

When the middleware runs, the types and data within the passed `ctx` are merged on top of the default provided by the library. This means that you can use a few tricks to overwrite data and types safely and more accurately.

For example, here we use a `const` assertion to infer the literal value of our `foo` example above.

```ts
// In middleware
dependencyInjectionMiddleware({
  foo: "bar",
} as const)

// In a function
async ({ event, foo }) => {
  //             ^? (parameter) foo: "bar"
}
```

## Ordering middleware and types

Middleware runs in the order specified when registering it (see [Middleware - Lifecycle - Registering and order](/docs-markdown/reference/middleware/lifecycle#registering-and-order)), which affects typing too.

When inferring a mutated input or output, the SDK will apply changes from each middleware in sequence, just as it will at runtime. This means that for two middlewares that add a `foo` value to input arguments, the last one to run will be what it seen both in types and at runtime.

#### TypeScript

Our custom `openaiMiddleware` relies on the [`transformInput` hook](/docs-markdown/reference/middleware/lifecycle#on-function-run-lifecycle) to mutate the Function's context:

```ts
import { InngestMiddleware } from "inngest";
import OpenAI from "openai";

const openaiMiddleware = new InngestMiddleware({
  name: "OpenAI Middleware",
  init() {
    const openai = new OpenAI();

    return {
      onFunctionRun(ctx) {
        return {
          transformInput(ctx) {
            return {
              // Anything passed via `ctx` will be merged with the function's arguments
              ctx: {
                openai,
              },
            };
          },
        };
      },
    };
  },
});
```

Our Inngest Functions can now access the OpenAI client through the context:

```ts
inngest.createFunction(
 { name: "user-create" },
 { event: "app/user.create" },
 async ({ openai }) => {
   const chatCompletion = await openai.chat.completions.create({
     messages: [{ role: "user", content: "Say this is a test" }],
     model: "gpt-3.5-turbo",
   });

   // ...
 },
);

```

> **Callout:** üí° Types are inferred from middleware outputs, so your Inngest functions will see an appropriately-typed openai property in their input.

Explore other examples in the [TypeScript SDK Middleware examples page](/docs-markdown/reference/middleware/examples).

### Advanced mutation

When middleware runs and `transformInput()` returns a new `ctx`, the types and data within that returned `ctx` are merged on top of the default provided by the library. This means that you can use a few tricks to overwrite data and types safely and more accurately.

For example, here we use a `const` assertion to infer the literal value of our `foo` example above.

```ts
// In middleware
transformInput() {
  return {
    ctx: {
      foo: "bar",
    } as const,
  };
}

// In a function
async ({ event, foo }) => {
  //             ^? (parameter) foo: "bar"
}
```

Because the returned `ctx` object and the default are merged together, sometimes good inferred types are overwritten by more generic types from middleware. A common example of this might be when handling event data in middleware.

To get around this, you can provide the data but omit the type by using an `as` type assertion. For example, here we use a type assertion to add `foo` and alter the event data without affecting the type.

```ts
async transformInput({ ctx }) {
  const event = await decrypt(ctx.event);

  const newCtx = {
    foo: "bar",
    event,
  };

  return {
    // Don't affect the `event` type
    ctx: newCtx as Omit<typeof newCtx, "event">,
  };
},
```

## Ordering middleware and types

Middleware runs in the order specified when registering it (see [Middleware - Lifecycle - Registering and order](/docs-markdown/reference/middleware/lifecycle#registering-and-order)), which affects typing too.

When inferring a mutated input or output, the SDK will apply changes from each middleware in sequence, just as it will at runtime. This means that for two middlewares that add a `foo` value to input arguments, the last one to run will be what it seen both in types and at runtime.

#### Python

Our `OpenAIMiddleware` uses the [`transform_input` hook](/docs-markdown/reference/python/middleware/lifecycle#transform-input) to inject context:

```py
import inngest
from openai import OpenAI

class OpenAIMiddleware(inngest.Middleware):
    def __init__(
        self,
        client: inngest.Inngest,
        raw_request: object,
    ) -> None:
        self.openai = OpenAI(
            # This is the default and can be omitted
            api_key=os.environ.get("OPENAI_API_KEY"),
        )

    def transform_input(
        self,
        ctx: execution_lib.Context,
        function: function.Function,
        steps: step_lib.StepMemos,
    ) -> None:
        ctx.openai = self.openai  # type: ignore

inngest_client = inngest.Inngest(
    app_id="my_app",
    middleware=[OpenAIMiddleware],
)
```

Our Inngest Functions can now access the `openai` client through the context:

```py
    @inngest_client.create_function(
        fn_id="user-create",
        trigger=inngest.TriggerEvent(event="app/user.create"),
    )
    async def fn(ctx: inngest.Context):
        chat_completion = ctx.openai.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": "Say this is a test",
                }
            ],
            model="gpt-3.5-turbo",
        )
```


--------------------------------------------------------------------------------
title: "Encryption Middleware"
source: "https://www.inngest.com/docs/features/middleware/encryption-middleware"
--------------------------------------------------------------------------------

# Encryption Middleware

Encryption middleware provides end-to-end encryption for events, step output, and function output. **Only encrypted data is sent to Inngest servers**: encryption and decryption happen within your infrastructure.

## Installation

#### Python

The `EncryptionMiddleware` is available as part of the `inngest_encryption` package:

```py
import inngest
from inngest_encryption import EncryptionMiddleware

inngest_client = inngest.Inngest(
    app_id="my-app",
    middleware=[EncryptionMiddleware.factory("my-secret-key")],
)
```

The following data is encrypted by default:

- The `encrypted` field in `event.data`.
- `step.run` return values.
- Function return values.

#### TypeScript

Install the [`@inngest/middleware-encryption` package](https://www.npmjs.com/package/@inngest/middleware-encryption) ([GitHub](https://github.com/inngest/inngest-js/tree/main/packages/middleware-encryption#readme)) and configure it as follows:

```ts
import { encryptionMiddleware } from "@inngest/middleware-encryption";

// Initialize the middleware
const mw = encryptionMiddleware({
  // your encryption key string should not be hard coded
  key: process.env.MY_ENCRYPTION_KEY,
});

// Use the middleware with Inngest
const inngest = new Inngest({
  id: "my-app",
  middleware: [mw],
});
```

By default, the following will be encrypted:

- All step data
- All function output
- Event data placed inside `data.encrypted`

> **Info:** If using encryption middleware in combination with checkpointing, upgrade to 3.51.0 or later.

## Changing the encrypted `event.data` field

#### Python

By default, `event.data.encrypted` is encrypted. All other fields are sent in plaintext. To encrypt a different field, set the `event_encryption_field` parameter.

#### TypeScript

Only select pieces of event data are encrypted. By default, only the data.encrypted field.

This can be customized using the `eventEncryptionField: string` setting.

## Decrypt only mode

#### Python

To disable encryption but continue decrypting, set `decrypt_only=True`. This is useful when you want to migrate away from encryption but still need to process older events.

#### TypeScript

To disable encryption but continue decrypting, set `decryptOnly: true`. This is useful when you want to migrate away from encryption but still need to process older events.

## Fallback decryption keys

#### Python

To attempt decryption with multiple keys, set the `fallback_decryption_keys` parameter. This is useful when rotating keys, since older events may have been encrypted with a different key.

#### TypeScript

To attempt decryption with multiple keys, set the `fallbackDecryptionKeys` parameter. This is useful when rotating keys, since older events may have been encrypted with a different key:

```ts
// start out with the current key
encryptionMiddleware({
  key: process.env.MY_ENCRYPTION_KEY,
});

// deploy all services with the new key as a decryption fallback
encryptionMiddleware({
  key: process.env.MY_ENCRYPTION_KEY,
  fallbackDecryptionKeys: ["new"],
});

// deploy all services using the new key for encryption
encryptionMiddleware({
  key: process.env.MY_ENCRYPTION_KEY_V2,
  fallbackDecryptionKeys: ["current"],
});

// once you are sure all data using the "current" key has passed, phase it out
encryptionMiddleware({
  key: process.env.MY_ENCRYPTION_KEY_V2,
});
```

## Cross-language support

This middleware is compatible with our encryption middleware in our TypeScript SDK. Encrypted events can be sent from Python and decrypted in TypeScript, and vice versa.


--------------------------------------------------------------------------------
title: "Sentry Middleware"
source: "https://www.inngest.com/docs/features/middleware/sentry-middleware"
--------------------------------------------------------------------------------

# Sentry Middleware

Using the Sentry middleware is useful to:

- Capture exceptions for reporting
- Add tracing to each function run
- Include useful context for each exception and trace like function ID and event names

## Installation

#### Python

The `SentryMiddleware` is shipped as part of the `inngest` package:

```py
import inngest
from inngest.experimental.sentry_middleware import SentryMiddleware

import sentry_sdk

# Initialize Sentry as usual wherever is appropriate
sentry_sdk.init(
    traces_sample_rate=1.0,
    profiles_sample_rate=1.0,
)

inngest_client = inngest.Inngest(
    app_id="my-app",
    middleware=[SentryMiddleware],
)
```

#### TypeScript

Install the [`@inngest/middleware-sentry` package](https://www.npmjs.com/package/@inngest/middleware-sentry) and configure it as follows:

```ts
import * as Sentry from "@sentry/node";
import { Inngest } from "inngest";
import { sentryMiddleware } from "@inngest/middleware-sentry";

// Initialize Sentry as usual wherever is appropriate
Sentry.init(...);

const inngest = new Inngest({
  id: "my-app",
  middleware: [sentryMiddleware()],
});
```

> **Callout:** Requires inngest@>=3.0.0 and @sentry/\*@>=8.0.0\`.


--------------------------------------------------------------------------------
title: "Realtime  &#x20;"
source: "https://www.inngest.com/docs/features/realtime"
--------------------------------------------------------------------------------

# Realtime  &#x20;

> **Info:** Realtime is currently in developer preview. Some details including APIs are still subject to change during this period. Read more about the developer preview here.

Realtime enables you to stream updates from your Inngest functions to your users, power live UIs, and implement bi-directional workflows such as Human-in-the-Loop.

Realtime user experience is a core requirement for any web application, especially when long-running tasks are involved. This is supported natively in Inngest without any additional infrastructure or configuration. Inngest manages the WebSocket server and the connection to your users.

## Concepts

There are two core parts of Realtime: **[publishing](#publishing)** and **[subscribing](#subscribing)**. You **publish** data from your functions and **subscribe** to data in your application, either browser or server.

Publishing data is done using the `publish()` function and has three components:

- `channel` - A namespace for which data belongs to, e.g., `user:123`. This is helpful to segment data to ensure that users only receive data that they are authorized to see.
- `topic` - A category of data within a `channel`, e.g., `llm_text_stream` or `upload_progress`. This is helpful to differentiate between types of data that you might use in different parts of your application.
- `data` - The data to be published to the realtime stream.

## Quick start

In this guide, we'll cover how to use realtime, publishing from an Inngest function and subscribing from the client (browser). Start by installing the `@inngest/realtime` package:

#### TypeScript

```shell {{ title: "npm" }}
npm install @inngest/realtime
```

```shell {{ title: "yarn" }}
yarn add @inngest/realtime
```

```shell {{ title: "pnpm" }}
pnpm add @inngest/realtime
```

```shell {{ title: "Bun" }}
bun add @inngest/realtime
```

```shell {{ title: "Deno" }}
deno add jsr:@inngest/realtime
```

> **Info:** This guide requires @inngest/realtime version 0.4.0 or higher.

#### Python

> **Info:** This guide requires inngest version 0.5.9 or higher.

### Publishing

#### TypeScript

To publish data from your Inngest functions, you'll need to add the `realtimeMiddleware()` to your Inngest client. This will automatically add the `publish()` function to your Inngest functions.

```ts {{ title: "client.ts" }}
import { Inngest } from "inngest";
// ‚ÑπÔ∏è Import the middleware from the middleware sub-package:
import { realtimeMiddleware } from "@inngest/realtime/middleware";

export const inngest = new Inngest({
  id: "my-app",
  middleware: [realtimeMiddleware()],
});
```

Now, in your Inngest functions, the `publish()` function will be available as a parameter to your handler function. When publishing data, you'll need to specify the `channel` and `topic` you want to publish to and any data you want to publish.

#### Python

To publish data from your Inngest functions, you'll need to import the experimental.realtime module. This is where you'll find the publish and publish\_sync functions.

See the [Fast API example](https://github.com/inngest/inngest-py/tree/main/examples/fast_api_realtime) for more information.

#### TypeScript

```tsx {{ title: "Basic (untyped)" }}
import { inngest } from "./client";

inngest.createFunction(
  { id: "create-recommendation" },
  { event: "ai/recommendation.requested" },
  async ({ event, step, publish }) => {

    const response = await step.run('generate-response', () => {
      const response = llm.generateResponse(event.data.prompt);
      await publish({
        channel: `user:${event.data.userId}`,
        topic: "ai",
        data: {
          response: response,
          success: true,
        },
      })
    });

    // ‚ÑπÔ∏è Want type-safety with channels and topics? See the typed channels tab above.
  }
);

```

```tsx {{ title: "Typed channels (recommended)" }}
import { inngest } from "./client";
import { channel, topic } from "@inngest/realtime";

// Use the "channel" and "topic" functions to create helpers to
// add type-safety when using realtime:

// The "channel" builder function can accept a string as a channel name,
// or a function that returns a string. Here we create a channel for all logs:
const logsChannel = channel("logs").addTopic(topic("info").type<string>());

// Here we create a channel using the function pattern, which allows us to pass
// a parameter to the channel name. Here we create a channel for each user:
// The "topic" builder function can accept a schema or a type
const userChannel = channel((userId: string) => `user:${userId}`)
  // Add a specific topic, eg. "ai" for all AI data within the user's channel
  .addTopic(
    topic("ai").schema(
      z.object({
        response: z.string(),
        // Transforms are supported for realtime data
        success: z.number().transform(Boolean),
      })
    )
  );

inngest.createFunction(
  { id: "create-recommendation" },
  { event: "ai/recommendation.requested" },
  async ({ event, step, publish }) => {

    await step.run('generate-response', () => {
      const response = llm.generateResponse(event.data.prompt)
      await publish(
        userChannel(event.data.userId).ai({
          response: response,
          success: true,
        })
      );
    });

    await step.run("log-all-went-well", () => {
      await publish(logsChannel().info("All went well"));
    });
  }
);
```

#### Python

```py {{ title: "Python" }}
import inngest
from inngest.experimental import realtime

from .client import inngest_client

@inngest_client.create_function(
    fn_id="python-realtime-publish",
    trigger=inngest.TriggerEvent(event="realtime.test"),
)
async def python_realtime_publish(ctx: inngest.Context) -> str:
    async def my_first_step() -> dict[str, str]:
        result = {"message": "My llm response from python!"}
        await realtime.publish(
            client=inngest_client,
            channel="user:user_123456789",
            topic="messages",
            data=result,
        )
        return result

    await ctx.step.run("my-first-step", my_first_step)

    return "Finished!"
```

### Subscribing

To subscribe to data on the client (browser), you'll need to create a subscription token and use the `subscribe()` function which also requires `channel` and `topic` to be specified.

Your application uses the Inngest SDK to create a token, which is then used by the subscribe function to connect to the Inngest WebSocket server.

### Create a subscription token

Subscription tokens are required to securely establish a connection to the Inngest WebSocket server.

Your application must create tokens on the server and pass them to the client. You can create a new endpoint to generate a token, ensuring that the user is authorized to subscribe to a given channel and topics.

Here's an example of a server endpoint that creates a token, scoped to a user's channel and specific topics.

```ts {{ title: "Next.js - Server action" }}
// ex. /app/actions/get-subscribe-token.ts
"use server";

import { inngest } from "@/inngest/client";
// See the "Typed channels (recommended)" section above for more details:
import { userChannel } from "@/inngest/functions/helloWorld";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";
import { getSession } from "@/app/lib/session"; // this could be any auth provider

export type UserChannelToken = Realtime.Token<typeof userChannel, ["ai"]>;

export async function fetchRealtimeSubscriptionToken(): Promise<UserChannelToken> {
  const { userId } = await getSession();

  // This creates a token using the Inngest API that is bound to the channel and topic:
  const token = await getSubscriptionToken(inngest, {
    channel: `user:${userId}`,
    topics: ["ai"],
  });

  return token;
}
```

```ts {{ title: "Express" }}
import { inngest } from "./inngest/client";
import { getSubscriptionToken } from "@inngest/realtime";
import { getSession } from "src/session"; // this could be any auth provider

app.post("/api/get-subscribe-token", async (req, res) => {
  const { userId } = getSession(req)

  // This creates a token using the Inngest API that is bound to the channel and topic:
  const token = await getSubscriptionToken(inngest, {
    channel: `user:${userId}`,
    topics: ["ai"],
  })

  res.json({ token })
})
```

```py {{ title: "Python - Fast API" }}
@app.get("/api/get-subscription-token")
async def get_realtime_token():
# Here, you can get params from the request to;
user_id = session["user_id"]
# - Authorize what the user is allowed to subscribe to
# - Allow the client to specify what topics they want to subscribe to
return await realtime.get_subscription_token(
    client=inngest_client,
    channel=f"user:{user_id}",
    topics=["messages"],
)
```

### Subscribe to a channel

Once you have a token, you can subscribe to a channel by calling the `subscribe` function with the token. You can also subscribe using the `useInngestSubscription` React hook. Read more about the [React hook here](/docs-markdown/features/realtime/react-hooks).

```ts {{ title: "React hook - useInngestSubscription()" }}
// ex: ./app/page.tsx
"use client";

// ‚ÑπÔ∏è Import the hook from the hooks sub-package:
import { useInngestSubscription } from "@inngest/realtime/hooks";
import { useState } from "react";
import { fetchRealtimeSubscriptionToken } from "./actions";

export default function Home() {
  // The hook automatically fetches the token from the server.
  // The server checks that the user is authorized to subscribe to
  // the channel and topic, then returns a token:
  const { data, error, freshData, state, latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
  });

  return (
    <div>
      {data.map((message, i) => (
        <div key={i}>{message.data}</div>
      ))}
    </div>
  );
}
```

```ts {{ title: "Basic subscribe" }}
import { subscribe } from "@inngest/realtime";

// The server checks that the user is authorized to subscribe to
// the channel and topic, then returns a token:
const { token } = await fetch("/api/get-subscribe-token", {
  method: "POST",
  credentials: "include",
}).then(res => res.json());

// The token is bound to the channel and topic, so we can
// subscribe to the channel and topic:
const stream = await subscribe(token);

for await (const message of stream) {
  console.log(message)
}
```

That's all you need to do to subscribe to a channel from the client!

## Guides

Explore guides for using realtime with different frameworks and patterns:

**"Use Realtime React hooks in Next.js"**: [Leverage the useInngestSubscription() hook to subscribe to realtime streams in your Next.js application.](/docs-markdown/features/realtime/react-hooks)

**"Explore patterns and examples"**: [Use Realtime to stream updates from one or multiple Inngest functions, or to implement a Human-in-the-Loop mechanism.](/docs-markdown/examples/realtime)

## SDK Support

Realtime is supported in the following SDKs:

| SDK        | Publish | Subscribe | Version   |
| ---------- | ------- | --------- | --------- |
| TypeScript | ‚úÖ       | ‚úÖ         | >=v3.32.0 |
| Golang     | ‚úÖ       | ‚úÖ         | >=v0.9.0  |
| Python     | ‚úÖ       | -         | >=v0.5.9  |

## Limitations

- The number of currently active topics depends on your Inngest plan
- Data sent is currently at-most-once and ephemeral
- The max message size is currently 512KB

## Developer preview

Realtime is available as a developer preview. During this period:

- This feature is **widely available** for all Inngest accounts.
- Some details including APIs and SDKs are subject to change based on user feedback.
- There is no additional cost to using realtime. Realtime will be available to all Inngest billing plans at general availability, but final pricing is not yet determined.

Read the [release phases](/docs/release-phases) for more details.

## Security

Realtime is secure by default. You can only subscribe to a channel's topics using time-sensitive tokens. The subscription token mechanism must be placed within your own protected API endpoints.

You must always specify the channel and topics when publishing data. This ensures that users can only access specific subsets of data within runs.

## Delivery guarantees

Message delivery is currently at-most-once. We recommend that your users subscribe to a channel's topics as you invoke runs or send events to ensure delivery of data within a topic.


--------------------------------------------------------------------------------
title: "Realtime in Next.js"
source: "https://www.inngest.com/docs/features/realtime/nextjs"
--------------------------------------------------------------------------------

# Realtime in Next.js

Realtime provides a direct compatibility with Next.js API Routes's streaming capabilities.

A `stream` returned by the `subscribe()` helper can be used to create a HTTP stream response:

```tsx {{ filename: "app/api/simple-search/route.ts" }}
import crypto from "crypto";
import { inngest } from "@/inngest/client";
import { subscribe } from "@inngest/realtime";

export async function POST(req: Request) {
  const json = await req.json();
  const { prompt } = json;

  // Generate a unique ID for Inngest function run
  const uuid = crypto.randomUUID();

  // The Inngest function will rely on this ID to publish messages
  // on a dedicated channel for this run.
  await inngest.send({
    name: "app/simple-search-agent.run",
    data: {
      uuid,
      input: prompt,
    },
  });

  // Subscribe to the Inngest function's channel.
  const stream = await subscribe({
    channel: `simple-search.${uuid}`,
    topics: ["updates"], // subscribe to one or more topics in the user channel
  });

  // Stream the response to the client with Vercel's streaming response.
  return new Response(stream.getEncodedStream(), {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
```

On the client, you can consume the stream using a simple `fetch()`:

```tsx {{ filename: "app/components/Chat.tsx" }}
"use client";
import { useState, useRef, useEffect } from "react";

export function SimpleSearch() {
  const [updates, setUpdates] = useState<string[]>([]);
  const [input, setInput] = useState("");

  const handleNewChat = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!input.trim()) return;

    try {
      const response = await fetch("/api/simple-search", {
        method: "POST",
        body: JSON.stringify({ prompt: input }),
      });

      const reader = response.body?.getReader();
      if (!reader) {
        return;
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        const text = new TextDecoder().decode(value);
        const data = JSON.parse(text).data;
        if (data === "Search complete") {
          reader.cancel();
          break;
        } else {
          setUpdates((prev) => [...prev, data]);
        }
      }
    } catch (error) {
      console.error("Error:", error);
    } finally {
      setInput("");
    }
  };

  return (
    // ...
  );
}
```

**"See the complete example source code"**: [Explore our Next.js Realtime demo applications.]("https://github.com/inngest/inngest-js/tree/main/examples/realtime-demos#readme")

## FAQ

### How do I consume the stream on the client?

A stream return by a Vercel Function can be consumed by the client using the `fetch()` API.

From the `fetch()` response, you can get a `Reader` object, which you can use to read the stream's content using:

- a loop to read the stream's content chunk by chunk
- a `TextDecoder` to decode the stream's content into a string
- a `JSON.parse()` to parse the stream's content into a JSON object

```ts
const response = await fetch("/api/simple-search", {
  method: "POST",
  body: JSON.stringify({ prompt: input }),
});

const reader = response.body?.getReader();
if (!reader) {
  return;
}

while (true) {
  const { done, value } = await reader.read();
  if (done) {
      break;
  }
  const text = new TextDecoder().decode(value);
  const data = JSON.parse(text).data;
  if (data === "Search complete") {
      setIsLoading(false);
      setIsInputVisible(true);
      reader.cancel();
      break;
  } else {
      setUpdates((prev) => [...prev, data]);
  }
}
```

Depending on your use case, you might want to handle the stream's termination differently (see below for an example).

### How do I handle the termination of the stream?

By default, an Inngest Realtime stream will remain open until explicitly closed by the client.
For this reason, you should handle the stream's termination by publishing a specific message from your Inngest function and handling it in the client's stream reader.

```ts {{ filename: "app/inngest/functions/streaming-workflow.ts" }}
import { inngest } from "../client";

export const simpleSearchAgent = inngest.createFunction(
  {
    id: "simple-search-agent-workflow",
  },
  {
    event: "app/simple-search-agent.run",
  },
  async ({ step, event, publish }) => {
    const { uuid } = event.data;

    // ...

    await publish({
      channel: `simple-search.${uuid}`,
      topic: "updates",
      data: "Search complete",
    });

    return {
      response,
    };
  }
);

```

```tsx {{ filename: "app/components/Chat.tsx" }}
"use client";
import { useState, useRef, useEffect } from "react";

export function SimpleSearch() {
  const [updates, setUpdates] = useState<string[]>([]);
  const [input, setInput] = useState("");

  const handleNewChat = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!input.trim()) return;

    try {
      const response = await fetch("/api/simple-search", {
        method: "POST",
        body: JSON.stringify({ prompt: input }),
      });

      const reader = response.body?.getReader();
      if (!reader) {
        return;
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        const text = new TextDecoder().decode(value);
        const data = JSON.parse(text).data;
        if (data === "Search complete") {
          reader.cancel();
          break;
        } else {
          setUpdates((prev) => [...prev, data]);
        }
      }
    } catch (error) {
      console.error("Error:", error);
    } finally {
      setInput("");
    }
  };

  return (
    // ...
  );
}
```

### Is it compatible with Vercel's AI `useChat()`?

An Inngest Function publishing messages matching the `useChat()` hook's signature will be compatible with it.

See the [`Message`](https://sdk.vercel.ai/docs-markdown/reference/ai-sdk-ui/use-chat#messages) reference for the expected message format.


--------------------------------------------------------------------------------
title: "React hooks / Next.js&#x20;"
source: "https://www.inngest.com/docs/features/realtime/react-hooks"
--------------------------------------------------------------------------------

# React hooks / Next.js&#x20;

Realtime provides a [`useInngestSubscription()`](#use-inngest-subscription-api-reference) React hook, offering a fully typed experience for subscribing to channels.

`useInngestSubscription()` securely subscribes to channels using a subscription token fetched from the server.

In Next.js, this is implemented as a server action that returns a token, which is then used by the client to subscribe:

```tsx {{filename: "src/actions.ts"}}
"use server";
// securely fetch an Inngest Realtime subscription token from the server as a server action
export async function fetchSubscriptionToken(): Promise<Realtime.Token<typeof helloChannel, ["logs"]>> {
  const token = await getSubscriptionToken(getInngestApp(), {
    channel: helloChannel(),
    topics: ["logs"],
  });

  return token;
}
```

```tsx {{filename: "src/App.tsx"}}
"use client";

import { useInngestSubscription } from "@inngest/realtime/hooks";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";
import { getInngestApp } from "@/inngest";
import { helloChannel } from "@/inngest/functions/helloWorld";
// import the server action to securely fetch the Realtime subscription token
import { fetchRealtimeSubscriptionToken } from "./actions";

export default function Home() {
  // subscribe to the hello-world channel via the subscription token
  // `data` is fully typed based on the selected channel and topics!
  const { data, error } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
  });

  return (
    <div>
      <h1>Realtime</h1>
      {data.map((message, i) => (
        <div key={i}>{message.data}</div>
      ))}
    </div>
  )
}
```

## `useInngestSubscription()` API Reference

### Parameters

- `enabled?: boolean` - Whether or not the hook will subscribe.
- `bufferInterval?: number` - If set and above `0`, the outputs will only update every `n` milliseconds. This helps with very busy streams that could overwhelm a UI.
- `token?: Realtime.Subscribe.Token` - The token to be used for subscribing (see [Subscribe from the client](/docs-markdown/features/realtime#subscribe-from-the-client)).
- `refreshToken?: () => Promise<Realtime.Subscribe.Token>` - A function that will be called if no `token` is available, or if the hook has been re-`enabled` and the previous `token` has expired.

> **Warning:** A token or refreshToken parameter is required.

### Return value

- `data: Array<Realtime.Message>` - All messages received on the subscription in chronological order.
- `latestData: Realtime.Message` - A shortcut to the last message received on the subscription. Useful for streams where each message is the latest state of an entity.
- `freshData: Array<Realtime.Message>` - If `bufferInterval` is active, this will be the last batch of messages released from the buffer. If `bufferInterval` is inactive, this is always the latest message.
- `error: Error | null` - If truthy, this indicates an error with the subscription.
- `state: InngestSubscriptionState` - The current state of the subscription, one of `"closed"`, `"error"`, `"refresh_token"`, `"connecting"`, `"active"`, or `"closing"`.
- `clear: () => void` - A function to clear all accumulated message data from the internal state. This includes `data`, `freshData`, and `latestData` arrays. Does not affect the connection or error state.

## Examples

**"useInngestSubscription() Next.js demo"**: [Clone this demo to see an interactive example of the useInngestSubscription() hook in action.](https://github.com/inngest/inngest-js/tree/main/examples/realtime/next-realtime-hooks)

**"Explore patterns and examples"**: [Use Realtime to stream updates from one or multiple Inngest functions, or to implement a Human-in-the-Loop mechanism.](/docs-markdown/examples/realtime)


--------------------------------------------------------------------------------
title: "Here, you can get params from the request to;"
source: "https://www.inngest.com/docs/features/realtime/subscribe"
--------------------------------------------------------------------------------

### Subscribing

To subscribe to data on the client (browser), you'll need to create a subscription token and use the `subscribe()` function which also requires `channel` and `topic` to be specified.

Your application uses the Inngest SDK to create a token, which is then used by the subscribe function to connect to the Inngest WebSocket server.

### Create a subscription token

Subscription tokens are required to securely establish a connection to the Inngest WebSocket server.

Your application must create tokens on the server and pass them to the client. You can create a new endpoint to generate a token, ensuring that the user is authorized to subscribe to a given channel and topics.

Here's an example of a server endpoint that creates a token, scoped to a user's channel and specific topics.

```ts {{ title: "Next.js - Server action" }}
// ex. /app/actions/get-subscribe-token.ts
"use server";

import { inngest } from "@/inngest/client";
// See the "Typed channels (recommended)" section above for more details:
import { userChannel } from "@/inngest/functions/helloWorld";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";
import { getSession } from "@/app/lib/session"; // this could be any auth provider

export type UserChannelToken = Realtime.Token<typeof userChannel, ["ai"]>;

export async function fetchRealtimeSubscriptionToken(): Promise<UserChannelToken> {
  const { userId } = await getSession();

  // This creates a token using the Inngest API that is bound to the channel and topic:
  const token = await getSubscriptionToken(inngest, {
    channel: `user:${userId}`,
    topics: ["ai"],
  });

  return token;
}
```

```ts {{ title: "Express" }}
import { inngest } from "./inngest/client";
import { getSubscriptionToken } from "@inngest/realtime";
import { getSession } from "src/session"; // this could be any auth provider

app.post("/api/get-subscribe-token", async (req, res) => {
  const { userId } = getSession(req)

  // This creates a token using the Inngest API that is bound to the channel and topic:
  const token = await getSubscriptionToken(inngest, {
    channel: `user:${userId}`,
    topics: ["ai"],
  })

  res.json({ token })
})
```

```py {{ title: "Python - Fast API" }}
@app.get("/api/get_subscription_token")
async def get_realtime_token():
# Here, you can get params from the request to;
user_id = session["user_id"]
# - Authorize what the user is allowed to subscribe to
# - Allow the client to specify what topics they want to subscribe to
return await realtime.get_subscription_token(
    client=inngest_client,
    channel=f"user:{user_id}",
    topics=["messages"],
)
```

### Subscribe to a channel

Once you have a token, you can subscribe to a channel by calling the `subscribe` function with the token. You can also subscribe using the `useInngestSubscription` React hook. Read more about the [React hook here](/docs-markdown/features/realtime/react-hooks).

```ts {{ title: "React hook - useInngestSubscription()" }}
// ex: ./app/page.tsx
"use client";

// ‚ÑπÔ∏è Import the hook from the hooks sub-package:
import { useInngestSubscription } from "@inngest/realtime/hooks";
import { useState } from "react";
import { fetchRealtimeSubscriptionToken } from "./actions";

export default function Home() {
  // The hook automatically fetches the token from the server.
  // The server checks that the user is authorized to subscribe to
  // the channel and topic, then returns a token:
  const { data, error, freshData, state, latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
  });

  return (
    <div>
      {data.map((message, i) => (
        <div key={i}>{message.data}</div>
      ))}
    </div>
  );
}
```

```ts {{ title: "Basic subscribe" }}
import { subscribe } from "@inngest/realtime";

// The server checks that the user is authorized to subscribe to
// the channel and topic, then returns a token:
const { token } = await fetch("/api/get-subscribe-token", {
  method: "POST",
  credentials: "include",
}).then(res => res.json());

// The token is bound to the channel and topic, so we can
// subscribe to the channel and topic:
const stream = await subscribe(token);

for await (const message of stream) {
  console.log(message)
}
```

That's all you need to do to subscribe to a channel from the client!


--------------------------------------------------------------------------------
title: "Managing concurrency"
source: "https://www.inngest.com/docs/functions/concurrency"
--------------------------------------------------------------------------------

# Managing concurrency

Limit the number of concurrently running steps for your function with the [`concurrency`](/docs-markdown/reference/functions/create#configuration) configuration options. Setting an optional `key` parameter limits the concurrency for each unique value of the expression.

[Read our concurrency guide for more information on concurrency, including how it works and any limits](/docs-markdown/guides/concurrency).

```ts {{ title: "Simple" }}
export default inngest.createFunction(
  {
    id: "sync-contacts",
    concurrency: {
      limit: 10,
    },
  }
  // ...
);
```

```ts {{ title: "Multiple keys" }}
inngest.createFunction(
  {
    id: "unique-function-id",
    concurrency: [
      {
         // Use an account-level concurrency limit for this function, using the
         // "openai" key as a virtual queue.  Any other function which
         // runs using the same "openai"` key counts towards this limit.
         scope: "account",
         key: `"openai"`,
         // If there are 10 steps executing with the "openai" key, this function's
         // runs will wait for capacity before executing.
         limit: 10,
      },
      {
         // Create another virtual concurrency queue for this function only.  This
         // limits all accounts to a single executing step for this function, based off
         // of the `event.data.account_id` field.
         // "fn" is the default scope, so we could omit this field.
         scope: "fn",
         key: "event.data.account_id",
         limit: 1,
      },
    ],
  }
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);
```

Setting `concurrency` limits are very useful for:

- Handling API rate limits - Limit concurrency to stay within the rate limit quotas that are allowed by a given third party API.
- Limiting database operations or connections
- Preventing one of your user's accounts from consuming too many resources (see `key`)

Alternatively, if you want to limit the number of times that your function runs in a given period, [the `rateLimit` option](/docs-markdown/reference/functions/rate-limit) may be better for your use case.

## Configuration

- `concurrency` (number | object | \[object, object]): Options to configure concurrency. Specifying a number is a shorthand to set the limit property.The maximum number of concurrently running steps.
  A value of 0 or undefined is the equivalent of not setting a limit.
  The maximum value is dictated by your account's plan.The scope for the concurrency limit, which impacts whether concurrency is managed on an individual function, across an environment, or across your entire account.fn (default):  only the runs of this function affects the concurrency limitenv:  all runs within the same environment that share the same evaluated key value will affect the concurrency limit.  This requires setting a key which evaluates to a virtual queue name.account:  every run that shares the same evaluated key value will affect the concurrency limit, across every environment.  This requires setting a key which evaluates to a virtual queue name.An expression which evaluates to a string given the triggering event.  The string returned from the expression is used as the concurrency queue name.  A key is required when setting an env or account level scope.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Limit concurrency to n (via limit) per customer id: 'event.data.customer\_id'Limit concurrency to n per user, per import id: 'event.data.user\_id + "-" + event.data.import\_id'Limit globally using a specific string: '"global-quoted-key"' (wrapped in quotes, as the expression is evaluated as a language)

> **Callout:** The current concurrency option controls the number of concurrent steps that can be running at any one time.Because a single function run can contain multiple steps, it's possible that more functions than the concurrency limit are triggered, but only the set number of steps will ever be running.


--------------------------------------------------------------------------------
title: "Referencing functions"
source: "https://www.inngest.com/docs/functions/references"
--------------------------------------------------------------------------------

# Referencing functions

Using [`step.invoke()`](/docs-markdown/reference/functions/step-invoke), you can directly call one Inngest function from another and handle the result. You can use this with `referenceFunction` to call Inngest functions located in other apps, or to avoid importing dependencies of functions within the same app.

```ts
// @/inngest/compute.ts
import { referenceFunction } from "inngest";
import { z } from "zod";
import { type computePi } from "@/inngest/computePi";

// Create a local reference to a function without importing dependencies
export const computePi = referenceFunction<typeof computePi>({
  functionId: "compute-pi",
});

// Create a reference to a function in another application
export const computeSquare = referenceFunction({
  appId: "my-python-app",
  functionId: "compute-square",
  // Schemas are optional, but provide types for your call if specified
  schemas: {
    data: z.object({
      number: z.number(),
    }),
    return: z.object({
      result: z.number(),
    }),
  },
});
```

```ts
// @/inngest/someFn.ts
import { computeSquare } from "@/inngest/compute"; // import the referenece

// square.result is typed as a number
const square = await step.invoke("compute-square-value", {
  function: computeSquare,
  data: { number: 4 }, // input data is typed, requiring input if it's needed
});
```

## How to use `referenceFunction`

The simplest reference just contains a `functionId`. When used, this will invoke the function with the given ID in the same app that is used to invoke it.

The input and output types are `unknown`.

```ts
import { referenceFunction } from "inngest";

await step.invoke("start-process", {
  function: referenceFunction({
    functionId: "some-fn",
  }),
});
```

If referencing a function in a different application, specify an `appId` too:

```ts
import { referenceFunction } from "inngest";

await step.invoke("start-process", {
  function: referenceFunction({
    functionId: "some-fn",
    appId: "some-app",
  }),
});
```

You can optionally provide `schemas`, which are a collection of [Standard Schemas](https://standardschema.dev/) used to provide typing to the input and output of the referenced function.

> **Callout:** In the future, this will also validate the input and output.

```ts
import { referenceFunction } from "inngest";
import { z } from "zod";

await step.invoke("start-process", {
  function: referenceFunction({
    functionId: "some-fn",
    appId: "some-app",
    schemas: {
      data: z.object({
        foo: z.string(),
      }),
      return: z.object({
        success: z.boolean(),
      }),
    },
  }),
});
```

Even if functions are within the same app, this can also be used to avoid importing the dependencies of one function into another, which is useful for frameworks like Next.js where edge and serverless logic can be colocated but require different dependencies.

```ts
import { referenceFunction } from "inngest";
import { type someInngestFn } from "@/inngest/someFn"; // import only the type

await step.invoke("start-process", {
  function: referenceFunction<typeof someInngestFn>({
    functionId: "some-fn",
  }),
});
```

## Configuration

- `functionId` (string): The ID of the function to reference. This can be either a local function ID or the ID of a function that exists in another app.If the latter, appId must also be provided. If appId is not provided, the function ID will be assumed to be a local function ID (the app ID of the calling app will be used).

* `appId` (string): The ID of the app that the function belongs to. This is only required if the function being refenced exists in another app.

- `schemas` (object): The schemas of the referenced function, providing typing to the input data and return of invoking the referenced function.If not provided and a local function type is not being passed as a generic into referenceFunction(), the schemas will be inferred as unknown.The Standard Schema to use to provide typing to the data payload required by the referenced function.The Standard Schema to use to provide typing to the return value of the referenced function when invoked.


--------------------------------------------------------------------------------
title: "Next.js Quick Start"
source: "https://www.inngest.com/docs/getting-started/nextjs-quick-start"
--------------------------------------------------------------------------------

# Next.js Quick Start

In this tutorial you will add Inngest to a Next.js app to see how easy it can be to build complex workflows.

Inngest makes it easy to build, manage, and execute reliable workflows. Some use cases include scheduling drip marketing campaigns, building payment flows, or chaining LLM interactions.

By the end of this ten-minute tutorial you will:

- Set up and run Inngest on your machine.
- Write your first Inngest function.
- Trigger your function from your app and through Inngest Dev Server.

Let's get started!

### Choose Next.js version

Choose your preferred Next.js version for this tutorial:

## Before you start: choose a project

In this tutorial you can use any existing Next.js project, or you can create a new one.

Instructions for creating a new Next.js project&#x20;

Run the following command in your terminal to create a new Next.js project:

#### nextpages

```shell
npx create-next-app@latest --ts --eslint --tailwind --no-src-dir --no-app --import-alias='@/*' inngest-guide
```

#### nextappdir

```shell
npx create-next-app@latest --ts --eslint --tailwind --src-dir --app --import-alias='@/*' inngest-guide
```

Once you've chosen a project, open it in a code editor.

Next, start your Next.js app in development mode by running:

```shell
npm run dev
```

Now you can add Inngest to your project!

## 1. Install Inngest

With the Next.js app now running running open a new tab in your terminal. In your project directory's root, run the following command to install Inngest SDK:

```shell {{ title: "npm" }}
npm install inngest
```

```shell {{ title: "yarn" }}
yarn add inngest
```

```shell {{ title: "pnpm" }}
pnpm add inngest
```

```shell {{ title: "bun" }}
bun add inngest
```

## 2. Run the Inngest Dev Server

Next, start the [Inngest Dev Server](/docs-markdown/local-development#inngest-dev-server), which is a fast, in-memory version of Inngest where you can quickly send and view events and function runs:

```shell {{ title: "npm" }}
npx --ignore-scripts=false inngest-cli@latest dev
```

```shell {{ title: "yarn" }}
yarn dlx inngest-cli@latest dev
```

```shell {{ title: "pnpm" }}
pnpm dlx inngest-cli@latest dev
```

```shell {{ title: "bun" }}
npx --ignore-scripts=false inngest-cli@latest dev
```

> **Callout:** üëâ For bun we also use npx. The Inngest npm package relies on lifecycle scripts to install the CLI binary, which Bun doesn't allow by default

You should see a similar output to the following:

```bash {{ language: 'js' }}
$ npx --ignore-scripts=false inngest-cli@latest dev

12:33PM INF executor > service starting
12:33PM INF runner > starting event stream backend=redis
12:33PM INF executor > subscribing to function queue
12:33PM INF runner > service starting
12:33PM INF runner > subscribing to events topic=events
12:33PM INF no shard finder;  skipping shard claiming
12:33PM INF devserver > service starting
12:33PM INF devserver > autodiscovering locally hosted SDKs
12:33PM INF api > starting server addr=0.0.0.0:8288

        Inngest dev server online at 0.0.0.0:8288, visible at the following URLs:

         - http://127.0.0.1:8288 (http://localhost:8288)

        Scanning for available serve handlers.
        To disable scanning run `inngest dev` with flags: --no-discovery -u <your-serve-url>
```

In your browser open [`http://localhost:8288`](http://localhost:8288) to see the development UI where later you will test the functions you write:

## 3. Create an Inngest client

Inngest invokes your functions securely via an [API endpoint](/docs/learn/serving-inngest-functions) at `/api/inngest`. To enable that, you will create an [Inngest client](/docs-markdown/reference/client/create) in your Next.js project, which you will use to send events and create functions.

#### nextpages

Create a new file at `./pages/api/inngest.ts` with the following code:

```ts {{ filename: "pages/api/inngest.ts" }}
import { Inngest } from "inngest";
import { serve } from "inngest/next";

// Create a client to send and receive events
export const inngest = new Inngest({ id: "my-app" });

// Create an API that serves zero functions
export default serve({
  client: inngest,
  functions: [
    /* your functions will be passed here later! */
  ],
});
```

#### nextappdir

Make a new directory next to your `app` directory (for example, `src/inngest`) where you'll define your Inngest functions and the client.

In the `/src/inngest` directory create an Inngest client:

```ts {{ filename: "src/inngest/client.ts" }}
import { Inngest } from "inngest";

// Create a client to send and receive events
export const inngest = new Inngest({ id: "my-app" });
```

Next, you will set up a route handler for the `/api/inngest` route. To do so, create a file inside your `app` directory (for example, at `src/app/api/inngest/route.ts`) with the following code:

```ts {{ filename: "src/app/api/inngest/route.ts" }}
import { serve } from "inngest/next";
import { inngest } from "../../../inngest/client";

// Create an API that serves zero functions
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    /* your functions will be passed here later! */
  ],
});
```

## 4. Write your first Inngest function

In this step, you will write your first reliable serverless function. This function will be triggered whenever a specific event occurs (in our case, it will be `test/hello.world`). Then, it will sleep for a second and return a "Hello, World!".

### Define the function

To define the function, use the [`createFunction`](/docs-markdown/reference/functions/create) method on the Inngest client.

Learn more: What is `createFunction` method?

The `createFunction` method takes three objects as arguments:

- **Configuration**: A unique `id` is required and it is the default name that will be displayed on the Inngest dashboard to refer to your function. You can also specify [additional options](/docs-markdown/reference/functions/create#configuration) such as `concurrency`, `rateLimit`, `retries`, or `batchEvents`, and others.
- **Trigger**: `event` is the name of the event that triggers your function. Alternatively, you can use `cron` to specify a schedule to trigger this function. Learn more about triggers [here](/docs-markdown/features/events-triggers).
- **Handler**: The function that is called when the `event` is received. The `event` payload is passed as an argument. Arguments include `step` to define durable steps within your handler and [additional arguments](/docs-markdown/reference/functions/create#handler) include logging helpers and other data.

#### nextpages

Add the following code to the `./pages/api/inngest.ts` file:

```ts
// Step 2 code...
export const helloWorld = inngest.createFunction(
  { id: "hello-world" },
  { event: "test/hello.world" },
  async ({ event, step }) => {
    await step.sleep("wait-a-moment", "1s");
    return { message: `Hello ${event.data.email}!` };
  },
);
```

#### nextappdir

Inside your `src/inngest` directory create a new file called `functions.ts` where you will define Inngest functions. Add the following code:

```ts {{ filename: "src/inngest/functions.ts" }}
import { inngest } from "./client";

export const helloWorld = inngest.createFunction(
  { id: "hello-world" },
  { event: "test/hello.world" },
  async ({ event, step }) => {
    await step.sleep("wait-a-moment", "1s");
    return { message: `Hello ${event.data.email}!` };
  },
);
```

### Add the function to `serve()`

#### nextpages

Next, add your Inngest function to the `serve()` handler.

```ts
export default serve({
  client: inngest,
  functions: [
    helloWorld, // <-- This is where you'll always add your new functions
  ],
});
```

#### nextappdir

Next, import your Inngest function in the routes handler (`src/app/api/inngest/route.ts`) and add it to the `serve` handler so Inngest can invoke it via HTTP:

```ts {{ filename: "src/app/api/inngest/route.ts" }}
import { serve } from "inngest/next";
import { inngest } from "../../../inngest/client";
import { helloWorld } from "../../../inngest/functions";

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    helloWorld, // <-- This is where you'll always add all your functions
  ],
});
```

> **Callout:** üëâ Note that you can import serve() for other frameworks and the rest of the code, in fact, remains the same ‚Äî only the import statement changes (instead of inngest/next, it would be inngest/astro, inngest/remix, and so on).

Now, it's time to run your function!

## 5. Trigger your function from the Inngest Dev Server UI

Inngest is powered by events.You will trigger your function in two ways: first, by invoking it directly from the Inngest Dev Server UI, and then by sending events from code.

With your Next.js app and Inngest Dev Server running, open the Inngest Dev Server UI and select the "Functions" tab [`http://localhost:8288/functions`](http://localhost:8288/functions). You should see your function. (Note: if you don't see any function, select the "Apps" tab to troubleshoot)

To trigger your function, use the "Invoke" button for the associated function:

In the pop up editor, add your event payload data like the example below. This can be any JSON and you can use this data within your function's handler. Next, press the "Invoke Function" button:

```json
{
  "data": {
    "email": "test@example.com"
  }
}
```

The payload is sent to Inngest (which is running locally) which automatically executes your function in the background! You can see the new function run logged in the "Runs" tab:

When you click on the run, you will see more information about the event, such as which function was triggered, its payload, output, and timeline:

In this case, the payload triggered the `hello-world` function, which did sleep for a second and then returned `"Hello, World!"`. No surprises here, that's what we expected!

To aid in debugging your functions, you can quickly "Rerun" or "Cancel" a function. Try clicking "Rerun" at the top of the "Run details" table:

After the function was replayed, you will see two runs in the UI:

Now you will trigger an event from inside your app.

## 6. Trigger from code

Inngest is powered by events.

Learn more: events in Inngest.

It is worth mentioning here that an event-driven approach allows you to:

- Trigger one *or* multiple functions from one event, aka [fan-out](/docs/guides/fan-out-jobs).
- Store received events for a historical record of what happened in your application.
- Use stored events to [replay](/docs-markdown/platform/replay) functions when there are issues in production.
- Interact with long-running functions by sending new events including [waiting for input](/docs-markdown/features/inngest-functions/steps-workflows/wait-for-event) and [cancelling](/docs-markdown/features/inngest-functions/cancellation/cancel-on-events).

To trigger Inngest functions to run in the background, you will need to send events from your application to Inngest. Once the event is received, it will automatically invoke all functions that are configured to be triggered by it.

To send an event from your code, you can use the `Inngest` client's `send()` method.

Learn more: `send()` method.

Note that with the `send` method used below you now can:

- Send one or more events within any API route.
- Include any data you need in your function within the `data` object.

In a real-world app, you might send events from API routes that perform an action, like registering users (for example, `app/user.signup`) or creating something (for example, `app/report.created`).

You will now send an event from within your Next.js app: from the ‚Äúhello‚Äù Next.js API function. To do so, create a new API handler in the #### nextpages`./pages/api/hello.ts`#### nextappdir`src/app/api/hello/route.ts` file:

#### nextpages

```ts {{ filename: "pages/api/hello.ts" }}
import { NextApiRequest, NextApiResponse } from "next";
import { inngest } from "./inngest";

// Opt out of caching; every request should send a new event
export const dynamic = "force-dynamic";

// Create a simple async Next.js API route handler
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  // Send your event payload to Inngest
  await inngest.send({
    name: "test/hello.world",
    data: {
      email: "testUser@example.com",
    },
  });

  res.status(200).json({ message: "Event sent!" });
}
```

#### nextappdir

```ts {{ filename: "src/app/api/hello/route.ts" }}
import { NextResponse } from "next/server";
import { inngest } from "../../../inngest/client"; // Import our client

// Opt out of caching; every request should send a new event
export const dynamic = "force-dynamic";

// Create a simple async Next.js API route handler
export async function GET() {
  // Send your event payload to Inngest
  await inngest.send({
    name: "test/hello.world",
    data: {
      email: "testUser@example.com",
    },
  });

  return NextResponse.json({ message: "Event sent!" });
}
```

> **Callout:** üëâ Note that we use "force-dynamic" to ensure we always send a new event on every request. In most situations, you'll probably want to send an event during a POST request so that you don't need this config option.

Every time this API route is requested, an event is sent to Inngest. To test it, open [`http://localhost:3000/api/hello`](http://localhost:3000/api/hello) (change your port if your Next.js app is running elsewhere). You should see the following output: `{"message":"Event sent!"}`

If you go back to the Inngest Dev Server, you will see a new run is triggered by this event:

And - that's it! You now have learned how to create Inngest functions and you have sent events to trigger those functions. Congratulations ü•≥

## Next Steps

To continue your exploration, feel free to check out:

- [Examples](/docs/examples) of what other people built with Inngest.
- [Case studies](/customers) showcasing a variety of use cases.
- [Our blog](/blog) where we explain how Inngest works, publish guest blog posts, and share our learnings.

You can also read more:

- About [Inngest functions](/docs-markdown/functions).
- About [Inngest steps](/docs-markdown/steps).
- About [Durable Execution](/docs-markdown/learn/how-functions-are-executed)
- How to [use Inngest with other frameworks](/docs-markdown/learn/serving-inngest-functions).
- How to [deploy your app to your platform](/docs-markdown/deploy).


--------------------------------------------------------------------------------
title: "Node.js Quick Start"
source: "https://www.inngest.com/docs/getting-started/nodejs-quick-start"
--------------------------------------------------------------------------------

# Node.js Quick Start

In this tutorial you will add Inngest to a Node.js app to easily run background tasks and build complex workflows.

Inngest makes it easy to build, manage, and execute durable functions. Some use cases include scheduling drip marketing campaigns, building payment flows, or chaining LLM interactions.

By the end of this ten-minute tutorial you will:

- Set up and run Inngest on your machine.
- Write your first Inngest function.
- Trigger your function from your app and through Inngest Dev Server.

Let's get started!

## Select your Node.js framework

Choose your preferred Node.js web framework to get started. This guide uses ESM (ECMAScript Modules), but it also works for Common.js with typical modifications.

Inngest works with any Node, Bun or Deno backend framework,but this tutorial will focus on some of the most popular frameworks.

### Optional: Use a starter project

If you don't have an existing project, you can clone the following starter project to run through the quick start tutorial:

## Starting your project

Start your server using your typical script. We recommend using something like [`tsx`](https://www.npmjs.com/package/tsx) or [`nodemon`](https://www.npmjs.com/package/nodemon) for automatically restarting on file save:

```shell {{ title: "tsx" }}
npx tsx watch ./index.ts # replace with your own main entrypoint file
```

```shell {{ title: "nodemon" }}
nodemon ./index.js # replace with your own main entrypoint file
```

Now let's add Inngest to your project.

## 1. Install the Inngest SDK

In your project directory's root, run the following command to install Inngest SDK:

```shell {{ title: "npm" }}
npm install inngest
```

```shell {{ title: "yarn" }}
yarn add inngest
```

```shell {{ title: "pnpm" }}
pnpm add inngest
```

```shell {{ title: "bun" }}
bun add inngest
```

## 2. Run the Inngest Dev Server

Next, start the [Inngest Dev Server](/docs-markdown/local-development#inngest-dev-server), which is a fast, in-memory version of Inngest where you can quickly send and view events and function runs. This tutorial assumes that your  server will be running on port `3000`; change this to match your port if you use another.

```shell {{ title: "npm" }}
npx --ignore-scripts=false inngest-cli@latest dev -u http://localhost:3000/api/inngest
```

```shell {{ title: "yarn" }}
yarn dlx inngest-cli@latest dev -u http://localhost:3000/api/inngest
```

```shell {{ title: "pnpm" }}
pnpm dlx inngest-cli@latest dev -u http://localhost:3000/api/inngest
```

```shell {{ title: "bun" }}
bunx --ignore-scripts=false inngest-cli@latest dev -u http://localhost:3000/api/inngest
```

> **Callout:** üëâ For bun we also use npx. The Inngest npm package relies on lifecycle scripts to install the CLI binary, which Bun doesn't allow by default

You should see a similar output to the following:

```bash {{ language: 'js' }}
$ npx --ignore-scripts=false inngest-cli@latest dev -u http://localhost:3000/api/inngest

12:33PM INF executor > service starting
12:33PM INF runner > starting event stream backend=redis
12:33PM INF executor > subscribing to function queue
12:33PM INF runner > service starting
12:33PM INF runner > subscribing to events topic=events
12:33PM INF no shard finder;  skipping shard claiming
12:33PM INF devserver > service starting
12:33PM INF devserver > autodiscovering locally hosted SDKs
12:33PM INF api > starting server addr=0.0.0.0:8288

        Inngest dev server online at 0.0.0.0:8288, visible at the following URLs:

         - http://127.0.0.1:8288 (http://localhost:8288)

        Scanning for available serve handlers.
        To disable scanning run `inngest dev` with flags: --no-discovery -u <your-serve-url>
```

In your browser open [`http://localhost:8288`](http://localhost:8288) to see the development UI where later you will test the functions you write:

## 3. Create an Inngest client

Inngest invokes your functions securely via an [API endpoint](/docs/learn/serving-inngest-functions) at `/api/inngest`. To enable that, you will create an [Inngest client](/docs-markdown/reference/client/create) in your project, which you will use to send events and create functions.

Create a file in the directory of your preference. We recommend creating an `inngest` directory for your client and all functions.

```ts {{ filename: "src/inngest/index.ts" }}
import { Inngest } from "inngest";

// Create a client to send and receive events
export const inngest = new Inngest({ id: "my-app" });

// Create an empty array where we'll export future Inngest functions
export const functions = [];
```

## 4. Set up the Inngest http endpoint

#### express

Using your existing Express.js server, we'll set up Inngest using the provided `serve` handler which will "serve" Inngest functions. Here we'll assume this file is your entrypoint at `inngest.ts` and all import paths will be relative to that:

```ts {{ filename: "./index.ts" }}
import express from "express";
import { serve } from "inngest/express";
import { inngest, functions } from "./src/inngest"

const app = express();
// Important: ensure you add JSON middleware to process incoming JSON POST payloads.
app.use(express.json());
// Set up the "/api/inngest" (recommended) routes with the serve handler
app.use("/api/inngest", serve({ client: inngest, functions }));

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

#### fastify

Using your existing Fastify server, we'll set up Inngest using the provided Fastify plugin which will "serve" Inngest functions. Here we'll assume this file is your entrypoint at `inngest.ts` and all import paths will be relative to that:

```ts {{ filename: "./index.ts" }}
import Fastify from "fastify";
import { fastifyPlugin } from "inngest/fastify";
import { inngest, functions } from "./src/inngest"

const fastify = Fastify({
  logger: true,
});

// This automatically adds the "/api/inngest" routes to your server
fastify.register(fastifyPlugin, {
  client: inngest,
  functions,
  options: {},
});

// Start up the fastify server
fastify.listen({ port: 3000 }, function (err, address) {
  if (err) {
    fastify.log.error(err);
    process.exit(1);
  }
});
```

> **Callout:** üëâ Note that you can import a serve handler for other frameworks and the rest of the code remains the same. These adapters enable you to change your web framework without changing any Inngest function code (ex. instead of inngest/expressinngest/fastify it could be inngest/next or inngest/hono);

## 5. Write your first Inngest function

In this step, you will write your first durable function. This function will be triggered whenever a specific event occurs (in our case, it will be `test/hello.world`). Then, it will sleep for a second and return a "Hello, World!".

To define the function, use the [`createFunction`](/docs-markdown/reference/functions/create) method on the Inngest client.

Learn more: What is `createFunction` method?

The `createFunction` method takes three objects as arguments:

- **Configuration**: A unique `id` is required and it is the default name that will be displayed on the Inngest dashboard to refer to your function. You can also specify [additional options](/docs-markdown/reference/functions/create#configuration) such as `concurrency`, `rateLimit`, `retries`, or `batchEvents`, and others.
- **Trigger**: `event` is the name of the event that triggers your function. Alternatively, you can use `cron` to specify a schedule to trigger this function. Learn more about triggers [here](/docs-markdown/features/events-triggers).
- **Handler**: The function that is called when the `event` is received. The `event` payload is passed as an argument. Arguments include `step` to define durable steps within your handler and [additional arguments](/docs-markdown/reference/functions/create#handler) include logging helpers and other data.

Define a function in the same file where we defined our Inngest client:

```ts {{ filename: "src/inngest/index.ts" }}
import { Inngest } from "inngest";

export const inngest = new Inngest({ id: "my-app" });

// Your new function:
const helloWorld = inngest.createFunction(
  { id: "hello-world" },
  { event: "test/hello.world" },
  async ({ event, step }) => {
    await step.sleep("wait-a-moment", "1s");
    return { message: `Hello ${event.data.email}!` };
  },
);

// Add the function to the exported array:
export const functions = [
  helloWorld
];
```

> **Callout:** In the previous step, we configured the exported functions array to be passed to our Inngest http endpoint. Each new function must be added to this array in order for Inngest to read it's configuration and invoke it.

Now, it's time to run your function!

## 5. Trigger your function from the Inngest Dev Server UI

You will trigger your function in two ways: first, by invoking it directly from the Inngest Dev Server UI, and then by sending events from code.

With your  server and Inngest Dev Server running, open the Inngest Dev Server UI and select the "Functions" tab [`http://localhost:8288/functions`](http://localhost:8288/functions). You should see your function. (Note: if you don't see any function, select the "Apps" tab to troubleshoot)

To trigger your function, use the "Invoke" button for the associated function:

In the pop up editor, add your event payload data like the example below. This can be any JSON and you can use this data within your function's handler. Next, press the "Invoke Function" button:

```json
{
  "data": {
    "email": "test@example.com"
  }
}
```

The payload is sent to Inngest (which is running locally) which automatically executes your function in the background! You can see the new function run logged in the "Runs" tab:

When you click on the run, you will see more information about the event, such as which function was triggered, its payload, output, and timeline:

In this case, the payload triggered the `hello-world` function, which did sleep for a second and then returned `"Hello, World!"`. No surprises here, that's what we expected!

To aid in debugging your functions, you can quickly "Rerun" or "Cancel" a function. Try clicking "Rerun" at the top of the "Run details" table:

After the function was replayed, you will see two runs in the UI:

Now you will trigger an event from inside your app.

## 6. Trigger from code

Inngest is powered by events.

Learn more: events in Inngest.

It is worth mentioning here that an event-driven approach allows you to:

- Trigger one *or* multiple functions from one event, aka [fan-out](/docs/guides/fan-out-jobs).
- Store received events for a historical record of what happened in your application.
- Use stored events to [replay](/docs-markdown/platform/replay) functions when there are issues in production.
- Interact with long-running functions by sending new events including [waiting for input](/docs-markdown/features/inngest-functions/steps-workflows/wait-for-event) and [cancelling](/docs-markdown/features/inngest-functions/cancellation/cancel-on-events).

To trigger Inngest functions to run in the background, you will need to send events from your application to Inngest. Once the event is received, it will automatically invoke all functions that are configured to be triggered by it.

To send an event from your code, you can use the `Inngest` client's `send()` method.

Learn more: `send()` method.

Note that with the `send` method used below you now can:

- Send one or more events within any API route.
- Include any data you need in your function within the `data` object.

In a real-world app, you might send events from API routes that perform an action, like registering users (for example, `app/user.signup`) or creating something (for example, `app/report.created`).

You will now send an event from within your server from a `/api/hello` `GET` endpoint. Create a new get handler on your server object:

#### express

```ts {{ filename: "./index.ts" }}
import express from "express";
import { serve } from "inngest/express";
import { inngest, functions } from "./src/inngest"

const app = express();
app.use(express.json());
app.use("/api/inngest", serve({ client: inngest, functions }));

// Create a new route
app.get("/api/hello", async function (req, res, next) {
  await inngest.send({
    name: "test/hello.world",
    data: {
      email: "testUser@example.com",
    },
  }).catch(err => next(err));
  res.json({ message: 'Event sent!' });
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

#### fastify

```ts {{ filename: "./index.ts" }}
import Fastify from "fastify";
import { fastifyPlugin } from "inngest/fastify";
import { inngest, functions } from "./src/inngest"

const fastify = Fastify({
  logger: true,
});
fastify.register(fastifyPlugin, { client: inngest, functions, options: {} });

// Create a new route:
fastify.get("/api/hello", async function (request, reply) {
  await inngest.send({
    name: "test/hello.world",
    data: {
      email: "testUser@example.com",
    },
  });
  return { message: "Event sent!" };
})

fastify.listen({ port: 3000 }, function (err, address) {
  if (err) {
    fastify.log.error(err);
    process.exit(1);
  }
});
```

Every time this API route is requested, an event is sent to Inngest. To test it, open [`http://localhost:3000/api/hello`](http://localhost:3000/api/hello) (change your port if your  app is running elsewhere). You should see the following output: `{"message":"Event sent!"}`

If you go back to the Inngest Dev Server, you will see a new run is triggered by this event:

And - that's it! You now have learned how to create Inngest functions and you have sent events to trigger those functions. Congratulations ü•≥

## Next Steps

To continue your exploration, feel free to check out:

- [Examples](/docs/examples) of what other people built with Inngest.
- [Case studies](/customers) showcasing a variety of use cases.
- [Our blog](/blog) where we explain how Inngest works, publish guest blog posts, and share our learnings.

You can also read more:

- About [Inngest functions](/docs-markdown/functions).
- About [Inngest steps](/docs-markdown/steps).
- About [Durable Execution](/docs-markdown/learn/how-functions-are-executed)
- How to [use Inngest with other frameworks](/docs-markdown/learn/serving-inngest-functions).
- How to [deploy your app to your platform](/docs-markdown/deploy).


--------------------------------------------------------------------------------
title: "Python Quick Start"
source: "https://www.inngest.com/docs/getting-started/python-quick-start"
--------------------------------------------------------------------------------

# Python Quick Start

This guide will teach you how to add Inngest to a FastAPI app and run an Inngest function.

> **Callout:** üí° If you prefer to explore code instead, here are example apps in the frameworks currently supported by Inngest:  FastAPI, Django,  Flask, DigitalOcean Functions, and Tornado.Is your favorite framework missing here? Please open an issue on GitHub!

***

## Create an app

> **Callout:** ‚ö†Ô∏è Use Python 3.10 or higher.

Create and source virtual environment:

```sh
python -m venv .venv && source .venv/bin/activate
```

Install dependencies:

```sh
pip install fastapi inngest uvicorn
```

Create a FastAPI app file:

```py {{ filename: "main.py" }}
from fastapi import FastAPI

app = FastAPI()
```

***

## Add Inngest

Let's add Inngest to the app! We'll do a few things

1. Create an **Inngest client**, which is used to send events to an Inngest server.
2. Create an **Inngest function**, which receives events.
3. Serve the **Inngest endpoint** on the FastAPI app.

```py {{ filename: "main.py" }}
import logging
from fastapi import FastAPI
import inngest
import inngest.fast_api

# Create an Inngest client
inngest_client = inngest.Inngest(
    app_id="fast_api_example",
    logger=logging.getLogger("uvicorn"),
)

# Create an Inngest function
@inngest_client.create_function(
    fn_id="my_function",
    # Event that triggers this function
    trigger=inngest.TriggerEvent(event="app/my_function"),
)
async def my_function(ctx: inngest.Context) -> str:
    ctx.logger.info(ctx.event)
    return "done"

app = FastAPI()

# Serve the Inngest endpoint
inngest.fast_api.serve(app, inngest_client, [my_function])
```

Start your app:

```sh
(INNGEST_DEV=1 uvicorn main:app --reload)
```

> **Callout:** üí° The INNGEST\_DEV environment variable tells the Inngest SDK to run in "dev mode". By default, the SDK will start in production mode. We made production mode opt-out for security reasons.Always set INNGEST\_DEV when you want to sync with the Dev Server. Never set INNGEST\_DEV when you want to sync with Inngest Cloud.

***

## Run Inngest Dev Server

Inngest functions are run using an **Inngest server**. For this guide we'll use the [Dev Server](https://github.com/inngest/inngest), which is a single-binary version of our [Cloud](https://app.inngest.com) offering. The Dev Server is great for local development and testing, while Cloud is for deployed apps (e.g. production).

Start the Dev Server:

```sh {{ title: "npx (npm)" }}
npx --ignore-scripts=false inngest-cli@latest dev -u http://127.0.0.1:8000/api/inngest --no-discovery
```

```sh {{ title: "Docker" }}
docker run -p 8288:8288 inngest/inngest \
  inngest dev -u http://host.docker.internal:8000/api/inngest --no-discovery
```

After a few seconds, your app and function should now appear in the Dev Server UI:

> **Callout:** üí° You can sync multiple apps and multiple functions within each app.

***

## Run your function

Click the function's "Trigger" button and a run should appear in the Dev Server stream tab:


--------------------------------------------------------------------------------
title: "Guides"
source: "https://www.inngest.com/docs/guides"
--------------------------------------------------------------------------------

# Guides

Learn how to build with Inngest:

## Patterns


--------------------------------------------------------------------------------
title: "Background jobs"
source: "https://www.inngest.com/docs/guides/background-jobs"
--------------------------------------------------------------------------------

# Background jobs

This guide will walk you through creating background jobs with retries in a few minutes.

By running background tasks in Inngest:

- You don't need to create queues, workers, or subscriptions.
- You can run background jobs on serverless functions without setting up infrastructure.
- You can enqueue jobs to run in the future, similar to a task queue, without any configuration.

## How to create background jobs

Background jobs in Inngest are executed in response to a trigger (an event or cron).

The example below shows a background job that uses an event (here called `app/user.created`) to send an email to new signups. It consists of two parts: creating the function that runs in the background and triggering the function.

üëâ To be able to use the code below, remember to first [serve your functions in your Inngest API](/docs-markdown/learn/serving-inngest-functions) to make it available to Inngest.

### 1. Create a function that runs in the background

#### TypeScript

Let's walk through the code step by step:

1. We [create a new Inngest function](/docs-markdown/reference/functions/create), which will run in the background any time the `app/user.created` event is sent to Inngest.
2. We send an email reliably using the [`step.run()`](/docs-markdown/reference/functions/step-run) method. Every [Inngest step](/docs-markdown/steps) is automatically retried upon failure.
3. We pause the execution of the function until a specific date using [`step.sleepUntil()`](/docs-markdown/reference/functions/step-sleep-until). The function will be resumed automatically, across server restarts or serverless functions. You don't have to worry about scale, memory leaks, connections, or restarts.
4. We resume execution and perform other tasks.

```ts
import { Inngest } from "inngest";
const inngest = new Inngest({ id: "signup-flow" });

export const sendSignUpEmail = inngest.createFunction(
  { id: "send-signup-email" },
  { event: "app/user.created" },
  ({ event, step }) => {
    await step.run("send-the-user-a-signup-email", async () => {
      await sesclient.clientsendEmail({
        to: event.data.user_email,
        subject: "Welcome to Inngest!"
        message: "...",
      });
    });
    await step.sleepUntil("wait-for-the-future", "2023-02-01T16:30:00");

    await step.run("do-some-work-in-the-future", async () => {
      // Code here runs in the future automatically.
    });
  }
);
```

### 2. Trigger the function

Your `sendSignUpEmail` function will be triggered whenever Inngest receives an event called `app/user.created`. is received. You send this event to Inngest like so:

```ts
await inngest.send({
  name: "app/user.created", // This matches the event used in `createFunction`
  data: {
    email: "test@example.com",
    // any data you want to send
  },
});
```

#### Go

Let's walk through the code step by step:

1. We [create a new Inngest function](https://pkg.go.dev/github.com/inngest/inngestgo#CreateFunction), which will run in the background any time the `app/user.created` event is sent to Inngest.
2. We send an email reliably using the [`step.Run()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Run) method. Every [Inngest step](/docs-markdown/steps) is automatically retried upon failure.
3. We pause the execution of the function for 4 hours using [`step.Sleep()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Sleep). The function will be resumed automatically, across server restarts or serverless functions. You don't have to worry about scale, memory leaks, connections, or restarts.
4. We resume execution and perform other tasks.

```go
import (
	"context"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadSendSignUpEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "send-signup-email",
		},
		inngestgo.EventTrigger("app/user.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			// business logic
			_, err := step.Run(ctx, "send-the-user-a-signup-email", func(ctx context.Context) (any, error) {
				return SendEmail(SendEmailInput{
					To:      input.Event.Data["user_email"].(string),
					Subject: "Welcome to Inngest!",
					Message: "...",
				})
			})
			if err != nil {
				return nil, err
			}

			step.Sleep(ctx, "wait-for-the-future", 4*time.Hour)

			_, err = step.Run(ctx, "do-some-work-in-the-future", func(ctx context.Context) (any, error) {
				// Code here runs in the future automatically.
				return nil, nil
			})
			return nil, err
		},
	)
}
```

### 2. Trigger the function

Your `sendSignUpEmail` function will be triggered whenever Inngest receives an event called `app/user.created`. is received. You send this event to Inngest like so:

```go
_, err := client.Send(context.Background(), inngestgo.Event{
	Name: "app/user.created", // This matches the event used in `createFunction`
	Data: map[string]interface{}{
		"email": "test@example.com",
		// any data you want to send
	},
})
```

#### Python

Let's walk through the code step by step:

1. We [create a new Inngest function](/docs-markdown/reference/python/functions/create), which will run in the background any time the `app/user.created` event is sent to Inngest.
2. We send an email reliably using the [`step.run()`](/docs-markdown/reference/python/steps/run) method. Every [Inngest step](/docs-markdown/steps) is automatically retried upon failure.
3. We pause the execution of the function until a specific date using [`step.sleep_until()`](/docs-markdown/reference/python/steps/sleep-until). The function will be resumed automatically, across server restarts or serverless functions. You don't have to worry about scale, memory leaks, connections, or restarts.
4. We resume execution and perform other tasks.

```python
import inngest

inngest_client = inngest.Inngest(
    app_id="my-app",
)

@inngest_client.create_function(
    fn_id="send-signup-email",
    trigger=inngest.TriggerEvent(event="app/user.created")
)
async def send_signup_email(ctx: inngest.Context):
    async def send_email():
        await sesclient.send_email(
            to=ctx.event.data["user_email"],
            subject="Welcome to Inngest!",
            message="..."
        )

    await ctx.step.run("send-the-user-a-signup-email", send_email)

    await ctx.step.sleep_until("wait-for-the-future", "2023-02-01T16:30:00")

    async def future_work():
        # Code here runs in the future automatically
        pass

    await ctx.step.run("do-some-work-in-the-future", future_work)
```

### 2. Trigger the function

Your `sendSignUpEmail` function will be triggered whenever Inngest receives an event called `app/user.created`. is received. You send this event to Inngest like so:

```python
from src.inngest.client import inngest_client

await inngest_client.send(
    name="app/user.created",  # This matches the event used in `create_function`
    data={
        "email": "test@example.com",
        # any data you want to send
    }
)
```

When you send an event to Inngest, it automatically finds any functions that are triggered by the event ID and automatically runs those functions in the background. The entire JSON object you pass in to `inngest.send()` will be available to your functions.

> **Callout:** üí° Tip: You can create many functions which listen to the same event, and all of them will run in the background. Learn more about this pattern in our "Fan out" guide.

## Further reading

More information on background jobs:

- [Email sequence examples](/docs-markdown/examples/email-sequence) implemented with Inngest.
- [Customer story: Soundcloud](/customers/soundcloud): building scalable video pipelines with Inngest to streamline dynamic video generation.
- [Customer story: GitBook](/customers/gitbook): how GitBook scaled background job processing with Inngest.
- [Customer story: Fey](/customers/fey): how Fey cut execution time and costs by 50x in data-intensive processes.
- Blog post: [building Truckload](/blog/mux-migrating-video-collections), a tool for heavy video migration between hosting platforms, from Mux.
- Blog post: building *banger.show*'s [video rendering pipeline](/blog/banger-video-rendering-pipeline).


--------------------------------------------------------------------------------
title: "Batching events"
source: "https://www.inngest.com/docs/guides/batching"
--------------------------------------------------------------------------------

# Batching events

Batching allows a function to process multiple events in a single run. This is useful for high load systems where it's more efficient to handle a batch of events together rather than handling each event individually. Some use cases for batching include:

- Reducing the number of requests to an external API that supports batch operations.
- Creating a batch of database writes to reduce the number of transactions.
- Reducing the number of requests to your [Inngest app](/docs-markdown/apps) to improve performance or serverless costs.

## How to configure batching

```ts {{ title: "TypeScript"}}
inngest.createFunction(
  {
    id: "record-api-calls",
    batchEvents: {
      maxSize: 100,
      timeout: "5s",
      key: "event.data.user_id", // Optional: batch events by user ID
      if: "event.data.account_type == \"free\"", // Optional: Only batch events from free accounts 
    },
  },
  { event: "log/api.call" },
  async ({ events, step }) => {
    // NOTE: Use the `events` argument, which is an array of event payloads
    const attrs = events.map((evt) => {
      return {
        user_id: evt.data.user_id,
        endpoint: evt.data.endpoint,
        timestamp: toDateTime(evt.ts),
        account_type: evt.data.account_type,
      };
    });

    const result = await step.run("record-data-to-db", async () => {
      return db.bulkWrite(attrs);
    });

    return { success: true, recorded: result.length };
  }
);
```

// TODO(lk) fix

```go {{ title: "Go" }}
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "record-api-calls",
		BatchEvents: &inngestgo.ConfigBatchEvents{
			MaxSize: 100,
			Timeout: "5s",
			Key: inngestgo.StrPtr("event.data.user_id"), // Optional: batch events by user ID
      If: inngestgo.StrPtr("event.data.account_type == \"free\""), // Optional: Only batch events from free accounts 
		},
	},
	inngestgo.EventTrigger("log/api.call", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// NOTE: Use the events argument, which is an array of event payloads
		events := input.Events
		attrs := make([]interface{}, len(events))
		for i, evt := range events {
			attrs[i] = map[string]interface{}{
				"user_id":   evt.Data["user_id"],
				"endpoint":  evt.Data["endpoint"],
				"timestamp": toDateTime(evt.Ts),
        "account_type": evt.Data["account_type"],
			}
		}

		_, err := step.Run(ctx, "record-data-to-db", func(ctx context.Context) (interface{}, error) {
			return db.BulkWrite(attrs)
		})
		if err != nil {
			return nil, err
		}

		return map[string]interface{}{
			"success":  true,
			"recorded": len(attrs),
		}, nil
	},
)
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="record-api-calls",
    trigger=inngest.TriggerEvent(event="log/api.call"),
    batch_events=inngest.Batch(
        max_size=100,
        timeout=datetime.timedelta(seconds=5),
        key="event.data.user_id"  # Optional: batch events by user ID
        if="event.data.account_type == \"free\"" # Optional: Only batch events from free accounts 
    ),
)
async def record_api_calls(ctx: inngest.Context):
    # NOTE: Use the events from ctx, which is an array of event payloads
    attrs = [
        {
            "user_id": evt.data.user_id,
            "endpoint": evt.data.endpoint,
            "timestamp": to_datetime(evt.ts),
            "account_type": evt.data.account_type
        }
        for evt in ctx.events
    ]

    async def record_data():
        return await db.bulk_write(attrs)

    result = await ctx.step.run("record-data-to-db", record_data)

    return {"success": True, "recorded": len(result)}
```

### Configuration reference

- `maxSize` - The maximum number of events to add to a single batch.
- `timeout` - The duration of time to wait to add events to a batch. If the batch is not full after this time, the function will be invoked with whatever events are in the current batch, regardless of size.
- `key` - An optional [expression](/docs-markdown/guides/writing-expressions) using event data to batch events by. Each unique value of the `key` will receive its own batch, enabling you to batch events by any particular key, like a user ID.
- `if` - An optional [boolean expression](/docs-markdown/guides/writing-expressions) using event data to conditionally batch events that evaluate to true on this expression.

> **Callout:** It is recommended to consider the overall batch size that you will need to process including the typical event payload size. Processing large batches can lead to memory or performance issues in your application.For system safety purposes, We also enforce a 10 MiB size limit for a batch, meaning if the size of the total number of events exceeds 10 MiB, the batch will start execution even if it's not full or has reached a timeout.
> This limit cannot be changed at the moment.

## How batching works

When batching is enabled, Inngest creates a new batch when the first event is received. The batch is filled with events until the `maxSize` is reached *or* the `timeout` is up. The function is then invoked with the full list of events in the batch. When `key` is set, Inngest will maintain a batch for each unique key, which allows you to batch events belonging to a single entity, for example a customer.

Depending on your SDK, the `events` argument will contain the full list of events within a batch. This allows you to operate on all of them within a single function.

### Conditional Batching

Conditional Batching can be enabled by providing a boolean expression in `if`.  If the expression cannot be evaluated to a boolean value or if the expression evaluates to `false`, batching will be skipped for this event and the event will be scheduled for execution immediately.

## Combining with other flow control methods

Batching does not work with all other flow control features.

### Batching with concurrency limits

You *can* combine batching with simple [concurrency](/docs-markdown/guides/concurrency) limits. For example, setting `concurrency: { limit: 1 }` will process one batch at a time.

However, **the concurrency `key` option is ignored when batching is enabled**. This means:

- If you configure `concurrency: { limit: 1, key: "event.data.user_id" }` with batching, the `key` expression will have no effect
- Batches will be processed one at a time globally (based on the `limit`), not per unique key value
- The concurrency limit applies to all batches regardless of what key values the events contain

If you need per-key concurrency with batched events, consider processing events individually with a keyed concurrency limit instead of using batching.

### Incompatible flow control features

You *cannot* use batching with [idempotency](/docs-markdown/guides/handling-idempotency), [rate limiting](/docs-markdown/guides/rate-limiting), [cancellation events](/docs-markdown/guides/cancel-running-functions#cancel-with-events), or [priority](/docs-markdown/guides/priority).

## Limitations

- Check our [pricing page](https://www.inngest.com/pricing) to verify the batch size limits for each plan.

## Further reference

- [TypeScript SDK Reference](/docs-markdown/reference/functions/create#batchEvents)
- [Python SDK Reference](/docs-markdown/reference/python/functions/create#batch_events)


--------------------------------------------------------------------------------
title: "Bulk Cancellation"
source: "https://www.inngest.com/docs/guides/cancel-running-functions"
--------------------------------------------------------------------------------

# Bulk Cancellation

With Inngest, your functions can be running or paused for long periods of time. You may have function with hundreds of steps, or you may be using [`step.sleep`](/docs-markdown/reference/functions/step-sleep), [`step.sleepUntil`](/docs-markdown/reference/functions/step-sleep-until), or [`step.waitForEvent`](/docs-markdown/reference/functions/step-wait-for-event). Sometimes, things happen in your system that make it no longer necessary to complete running the function, which is when cancelling is necessary.

Inngest provides both a Bulk Cancellation API and UI. The Bulk Cancellation API offers more flexibility with the support of event expression matching
while the [Bulk Cancellation UI](/docs-markdown/platform/manage/bulk-cancellation), available from the Platform, provides a quick way to cancel unwanted Function runs.

## Bulk cancel via the REST API

You can also cancel functions in bulk via the [REST API](https://api-docs.inngest.com/docs-markdown/inngest-api). This is useful if you have a large number of functions within a specific range that you need to cancel.

With the `POST /cancellations` endpoint, you can cancel functions by specifying the `app_id`, `function_id`, and a `started_after` and `started_before` timestamp range. You can also optionally specify an `if` statement to only cancel functions that match a [given expression](/docs-markdown/guides/writing-expressions).

```bash {{ title: 'cURL' }}
curl -X POST https://api.inngest.com/v1/cancellations \
  -H 'Authorization: Bearer signkey-prod-<YOUR-SIGNING-KEY>' \
  -H 'Content-Type: application/json' \
  --data '{
    "app_id": "acme-app",
    "function_id": "schedule-reminder",
    "started_after": "2024-01-21T18:23:12.000Z",
    "started_before": "2024-01-22T14:22:42.130Z",
    "if": "event.data.userId == 'user_o9235hf84hf'"
  }'
```

When successful, the response will be returned with the cancellation ID and the cancellation job data:

```json {{ title: 'Response' }}
{
  "id": "01HMRMPE5ZQ4AMNJ3S2N79QGRZ",
  "environment_id": "e03843e1-d2df-419e-9b7b-678b03f7398f",
  "function_id": "schedule-reminder",
  "started_after": "2024-01-21T18:23:12.000Z",
  "started_before": "2024-01-22T14:22:42.130Z",
  "if": "event.data.userId == 'user_o9235hf84hf'"
}
```

To learn more, read the full [REST API reference](https://api-docs.inngest.com/docs-markdown/inngest-api).


--------------------------------------------------------------------------------
title: "Handling Clerk webhook events"
source: "https://www.inngest.com/docs/guides/clerk-webhook-events"
--------------------------------------------------------------------------------

# Handling Clerk webhook events

![Clerk logo and graphic showing Clerk webhook events](/assets/docs-markdown/guides/clerk-webhook-events/featured-image.png)

Third party authentication providers like [Clerk](https://clerk.com/) are a fantastic way to add auth, user management, and security features to your application. They also provide drop-in components that can get your auth set up quickly. However, with an external source of truth for auth, you'll often need to:

- Sync data from Clerk with your database,
- Provision resources for new accounts, or
- Trigger other work from events (such as emails).

This page offers a guide on setting up a Clerk webhook with Inngest and using Clerk events within Inngest functions.

## Setting up the Clerk webhook

Clerk enables [sending events to a webhook endpoint](https://clerk.com/docs-markdown/integrations/webhooks/overview) when certain events occur. Inngest's [webhook endpoints](/docs-markdown/platform/webhooks) allow you to receive these events within your account just like [events that you send](/docs-markdown/events) from your own application.

To set up the Clerk webhook, open the Clerk dashboard and navigate to the "Webhooks" page. Next, select the "Add Endpoint" button.

![The Webhooks page in the Clerk Dashboard. A red arrow points to the button for Add Endpoint.](/assets/docs-markdown/guides/clerk-webhook-events/webhook-page.webp)

On the next page, select the "Transformation" template tab and the Inngest template, then click on the "Connect to Inngest" button.

![The Webhooks page in the Clerk Dashboard showing the Inngest transformation template. Red arrows point to the Transformation Template tab, the Inngest template, and the Connect to Inngest button.](/assets/docs-markdown/guides/clerk-webhook-events/webhook-transformation-template.webp)

A popup window will appear to complete the setup. Select "Approve" to create the webhook.

![The Inngest permissions popup window showing the Approve button.](/assets/docs-markdown/guides/clerk-webhook-events/inngest-permissions-dialog.png)

After the popup window disappears, the Webhooks page will now display "Connected" with the webhook URL underneath. There is one more step to complete setup.

![The Webhooks page in the Clerk Dashboard showing a connected Inngest account. A red arrow points to the Connected button.](/assets/docs-markdown/guides/clerk-webhook-events/webhook-endpoint-connected.webp)

To complete the setup, scroll down and select "Create".

![The Webhooks page in the Clerk Dashboard showing the end of the page to create a new endpoint. A red arrow points to the Create button.](/assets/docs-markdown/guides/clerk-webhook-events/webhook-create.webp)

You'll be redirected to the new endpoint. In your Inngest dashboard, you will see a new webhook created in your account's [production environment](https://app.inngest.com/env/production/manage/webhooks).

## Creating a function to sync a new user to a database

Often, one key part of integrating with an auth provider like [Clerk](https://clerk.com/) is handling asynchronous updates with a webhook.

Suppose you need to write a function which will insert a new user into the database which will be triggered whenever `clerk/user.created` event occurs. You would use the `inngest.createFunction()` method, like in the example below:

```ts {{ filename: "src/inngest/sync-user.ts" }}
const syncUser = inngest.createFunction(
  { id: 'sync-user-from-clerk' },
  { event: 'clerk/user.created' },
  async ({ event }) => {
    // The event payload's data will be the Clerk User json object
    const { user } = event.data;
    const { id, first_name, last_name } = user;
    const email = user.email_addresses.find(e =>
      e.id === user.primary_email_address_id
    ).email;
    await database.users.insert({ id, email, first_name, last_name });
  }
)
```

The `event` object contains all of the relevant data for the event. The `event.data` will match the `data` object from the standard Clerk webhook [payload structure](https://clerk.com/docs-markdown/integrations/webhooks/overview#payload-structure). With this `clerk/user.created` event, the `event.data` will be a Clerk User json object.

As you can see, you can choose which events you want to handle with each function. You might write a separate function for `clerk/user.updated` and `clerk/user.deleted` handling the entire lifecycle end to end.

Note that multiple functions can also listen to the same event. This pattern is called ‚Äú[fan-out](/docs-markdown/guides/fan-out-jobs).‚Äù

## Creating a function to send a welcome email

Often, applications need to perform additional tasks when a new user is created, like send a welcome email with tips and useful information.

While it is possible to add this logic at the end of your sync function as seen in the [previous section](/docs-markdown/guides/clerk-webhook-events#creating-a-function-to-sync-a-new-user-to-a-database), it‚Äôs better to decouple unrelated tasks into different functions so issues with one task do not affect the other ones. For example, if your email fails to send, it should not affect starting a trial for that user in Stripe.

You can make use of the fact that with Inngest, each function has [automatic retries](/docs-markdown/functions/retries), so only the code that has issues is re-run.

The code below creates another function using the same `clerk/user.created` event and adds the logic to send the welcome email:

```ts {{ filename: "src/inngest/send-welcome-email.ts" }}
const sendWelcomeEmail = inngest.createFunction(
  { id: 'send-welcome-email' },
  { event: 'clerk/user.created' },
  async ({ event }) => {
    const { user } = event.data;
    const { first_name } = user;
    const email = user.email_addresses.find(e =>
      e.id === user.primary_email_address_id
    ).email;
    await emails.sendWelcomeEmail({ email, first_name });
  }
)
```

Now, you have a function that utilizes the same Clerk webhook event for another purpose. Clerk webhook events can be used for all sorts of application lifecycle use cases. For example, adding users to a marketing email list, starting a Stripe trial, or provisioning new account resources.

### Sending a delayed follow-up email

To send a follow-up email, you can use the [`step.run()`](/docs-markdown/reference/functions/step-run). This method will encapsulate specific code that will be automatically retried ensuring that issues with one part of your function don't force the entire function to re-run. Additionally, you will extend the functionality with [`step.sleep()`](/docs-markdown/reference/functions/step-sleep).

The code below sends a welcome email, then uses `step.sleep()` to wait for three days before sending another email offering a free trial:

```ts {{ filename: "src/inngest/send-welcome-email.ts" }}
const sendWelcomeEmail = inngest.createFunction(
  { id: 'send-welcome-email' },
  { event: 'clerk/user.created' },
  async ({ event, step }) => {
    const { user } = event.data;
    const { first_name } = user;
    const email = user.email_addresses.find(e =>
      e.id === user.primary_email_address_id
    ).email;

    // Wrapping each distinct task in step.run() ensures that each
    // will be retried automatically on error and will not be re-run
    await step.run('welcome-email', async () => {
      await emails.sendWelcomeEmail({ email, first_name })
    });

    // wait 3 days before second email
    await step.sleep('wait-3-days', '3 days');

    await step.run('trial-offer-email', async () => {
      await emails.sendTrialOfferEmail({ email, first_name })
    });
  }
)
```

## Next steps

To continue learning about how to get the most out of Clerk webhook events, check out the following:

- Platform guide: [Consuming webhooks](/docs-markdown/platform/webhooks)
- Guide: [Fan-out (one-to-many)](/docs-markdown/guides/fan-out-jobs)
- Guide: [Parallel steps](/docs-markdown/guides/step-parallelism)
- Reference: [`step.run()`](/docs-markdown/reference/functions/step-run)


--------------------------------------------------------------------------------
title: "Concurrency management"
source: "https://www.inngest.com/docs/guides/concurrency"
--------------------------------------------------------------------------------

# Concurrency management

Limiting concurrency in systems is an important tool for correctly managing computing resources and scaling workloads. Inngest's concurrency control enables you to manage the number of *steps* that concurrently execute.

Step concurrency can be optionally configured using "keys" which applies the limit to each unique value of the key (ex. user id). The concurrency option can also be applied to different "scopes" which allows a concurrency limit to be shared across *multiple* functions.

As compared to traditional queue and worker systems, Inngest manages the concurrency within the system you do not need to implement additional worker-level logic or state.

## When to use concurrency

Concurrency is most useful when you want to constrain your function for a set of resources. Some use cases include:

- **Limiting in multi-tenant systems** - Prevent a single account, user, or tenant from consuming too many resources and creating a backlog for others. See: [Concurrency keys (Multi-tenant concurrency)](#concurrency-keys-multi-tenant-concurrency).
- **Limiting throughput for database operations** - Prevent potentially high volume jobs from overwhelming a database or similar resource. See: [Sharing limits across functions (scope)](#sharing-limits-across-functions-scope).
- **Basic concurrent operations limits** - Limit the capacity dedicated to processing a certain job, for example an import pipeline. See: [Basic concurrency](#basic-concurrency).
- **Combining multiple of the above** - Multiple concurrency limits can be added per function. See: [Combining multiple concurrency limits](#combining-multiple-concurrency-limits)

> **Info:** If you need to limit a function to a certain rate of processing, for example with a third party API rate limit, you might need throttling instead. Throttling is applied at the function level, compared to concurrency which is at the step level.

## How to configure concurrency

One or more concurrency limits can be configured for each function.

- [Basic concurrency](#basic-concurrency)
- [Concurrency keys (Multi-tenant concurrency)](#concurrency-keys-multi-tenant-concurrency)
- [Sharing limits across functions (scope)](#sharing-limits-across-functions-scope)
- [Combining multiple concurrency limits](#combining-multiple-concurrency-limits)

### Basic concurrency

The most basic concurrency limit is a single `limit` set to an integer value of the maximum number of concurrently executing steps. When concurrency limit is reached, new steps will continue to be queued and create a backlog to be processed.

```ts
inngest.createFunction(
  {
    id: "generate-ai-summary",
    concurrency: 10,
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
    // Your function handler here
  }
);
```

```go
_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "generate-ai-summary",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{Limit: 10},
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Your function handler here
		return nil, nil
	},
)
```

```python
@inngest_client.create_function(
    fn_id="generate-ai-summary",
    concurrency=[
        inngest.Concurrency(
            limit=10,
        )
    ],
    trigger=inngest.TriggerEvent(event="ai/summary.requested"),
)
async def generate_ai_summary(ctx: inngest.Context):
    # Your function handler here
    pass
```

### Concurrency keys (Multi-tenant concurrency)

Use a concurrency `key` expression to apply the `limit` to each unique value of key received. Within the Inngest system, this creates a **virtual queue** for every unique value and limits concurrency to each.

```ts
inngest.createFunction(
  {
    id: "generate-ai-summary",
    concurrency: [
      {
        key: "event.data.account_id",
        limit: 10,
      },
    ],
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);
```

```go
_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "generate-ai-summary",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{
				Scope: enums.ConcurrencyScopeFn,
				Key:   inngestgo.StrPtr("event.data.account_id"),
				Limit: 10,
			},
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Your function handler here
		return nil, nil
	},
)
```

```python
@inngest_client.create_function(
    fn_id="generate-ai-summary",
    concurrency=[
        inngest.Concurrency(
            scope="fn",
            key="event.data.account_id",
            limit=10,
        )
    ],
    trigger=inngest.TriggerEvent(event="ai/summary.requested"),
)
async def generate_ai_summary(ctx: inngest.Context):
    # Your function handler here
    pass
```

> **Tip:** Concurrency keys are great for creating fair, multi-tenant systems. This can help prevent the noisy neighbor issue where one user triggers a lot of jobs and consumes far more resources that slow down your other users.

### Sharing limits across functions (scope)

Using the `scope` option, limits can be set across your entire Inngest account, shared across multiple functions. Here is an example of setting an `"account"` level limit for a *static* `key` equal to `"openai"`. This will create a virtual queue using `"openai"` as the key. Any other functions using this same `"openai"` key will consume from this same limit.

```ts
inngest.createFunction(
  {
    id: "generate-ai-summary",
    concurrency: [
      {
        scope: "account",
        key: `"openai"`,
        limit: 60,
      },
    ],
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);
```

```go
_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "generate-ai-summary",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{
				Scope: enums.ConcurrencyScopeAccount,
				Key:   inngestgo.StrPtr(`"openai"`),
				Limit: 10,
			},
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Your function handler here
		return nil, nil
	},
)
```

```python
@inngest_client.create_function(
    fn_id="generate-ai-summary",
    concurrency=[
        inngest.Concurrency(
            scope="account",
            key='"openai"',
            limit=10,
        )
    ],
    trigger=inngest.TriggerEvent(event="ai/summary.requested"),
)
async def generate_ai_summary(ctx: inngest.Context):
    # Your function handler here
    pass
```

### Combining multiple concurrency limits

Each SDK's concurrency option supports up to two limits. This is the most beneficial when combining limits, each with a different `scope`. Here is an example that combines two limits, one on the `"account"` scope and another on the `"fn"` level. Combining limits will create multiple virtual queues to limit concurrency. In the below function:

- If there are 10 steps executing under the 'openai' key's virtual queue, any future runs will be blocked and will wait for existing runs to finish before executing.
- If there are 5 steps executing under the 'openai' key and a single `event.data.account_id` enqueues 2 runs, the second run is limited by the `event.data.account_id` virtual queue and will wait before executing.

```ts {{ title: "TypeScript" }}
inngest.createFunction(
  {
    id: "unique-function-id",
    concurrency: [
      {
         // Use an account-level concurrency limit for this function, using the
         // "openai" key as a virtual queue.  Any other function which
         // runs using the same "openai"` key counts towards this limit.
         scope: "account",
         key: `"openai"`,
         limit: 10,
      },
      {
         // Create another virtual concurrency queue for this function only.  This
         // limits all accounts to a single executing step for this function, based off
         // of the `event.data.account_id` field.
         // NOTE - "fn" is the default scope, so we could omit this field.
         scope: "fn",
         key: "event.data.account_id",
         limit: 1,
      },
    ],
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);
```

```go {{ title: "Go" }}
_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "generate-ai-summary",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{
				// Use an account-level concurrency limit for this function, using the
				// "openai" key as a virtual queue. Any other function which
				// runs using the same "openai" key counts towards this limit.
				Scope: enums.ConcurrencyScopeAccount,
				Key:   inngestgo.StrPtr(`"openai"`),
				Limit: 10,
			},
			{
				// Create another virtual concurrency queue for this function only. This
				// limits all accounts to a single execution for this function, based off
				// of the `event.data.account_id` field.
				// NOTE - "fn" is the default scope, so we could omit this field.
				Scope: enums.ConcurrencyScopeFn,
				Key:   inngestgo.StrPtr("event.data.account_id"),
				Limit: 1,
			},
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Your function handler here
		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="generate-ai-summary",
    concurrency=[
        inngest.Concurrency(
            # Use an account-level concurrency limit for this function, using the
            # "openai" key as a virtual queue.  Any other function which
            # runs using the same "openai" key counts towards this limit.
            scope="account",
            key='"openai"',
            limit=10,
        ),
        inngest.Concurrency(
            # Create another virtual concurrency queue for this function only.  This
            # limits all accounts to a single execution for this function, based off
            # of the `event.data.account_id` field.
            # NOTE - "fn" is the default scope, so we could omit this field.
            scope="fn",
            key="event.data.account_id",
            limit=1,
        ),
    ],
    trigger=inngest.TriggerEvent(event="ai/summary.requested"),
)
async def generate_ai_summary(ctx: inngest.Context):
    # Your function handler here
    pass
```

> **Info:** It's worth it to note that the "fn" scope is the default and is optional to include.

## How concurrency works

**Concurrency works by limiting the number of steps executing at a single time.** Within Inngest, execution is defined as "an SDK running code". **Calling **`step.sleep`**, **`step.sleepUntil`**, **`step.waitForEvent`**, or **`step.invoke`** does not count towards capacity limits**, as the SDK doesn't execute code while those steps wait. Because sleeping or waiting is common, concurrency *does not* limit the number of functions in progress.  Instead, it limits the number of steps executing at any single time.

> **Info:** Steps that are asynchronous actions, step.sleep, step.sleepUntil, step.waitForEvent, and step.invoke do not contribute to the concurrency limit.

**Queues are ordered from oldest to newest jobs ([FIFO](https://en.wikipedia.org/wiki/FIFO))** across the same function.  Ordering amongst different functions is not guaranteed.  This means that within a specific function, Inngest prioritizes finishing older functions above starting newer functions - even if the older functions continue to schedule new steps to run.  Different functions, however, compete for capacity, with runs on the most backlogged function much more likely (but not guaranteed) to be scheduled first.

Some additional information:

- The order of keys does not matter.  Concurrency is limited by any key that reaches its limits.
- You can specify multiple keys for the same scope, as long as the resulting `key` evaluates to a different string.

## Concurrency control across specific steps in a function

You might need to set a different concurrency limit for a single step in a function. For example, within an AI flow you may have 10 pre-processing steps which can run with higher limits, and a single AI call with much lower limits.

To control concurrency on individual steps, extract the step into a new function with its *own* concurrency controls, and invoke the new function using `step.invoke`. This lets you combine concurrency controls and manage "flow control" in a clean, composable manner.

## How global limits work

> **Callout:** While two functions can share different account scoped limits, we strongly recommend that you use a global const with a single shared limit.

You may write two functions that define different levels for an 'account' scoped concurrency limit.  For example, function A may limit the "ai" capacity to 5, while function B limits the "ai" capacity to 50:

```ts {{ title: "TypeScript" }}
inngest.createFunction(
  {
    id: "func-a",
    concurrency: {
      scope: "account",
      key: `"openai"`,
      limit: 5,
    },
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);

inngest.createFunction(
  {
    id: "func-b",
    concurrency: {
      scope: "account",
      key: `"openai"`,
      limit: 50,
    },
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);
```

```go {{ title: "Go" }}
_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "func-a",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{
				Scope: enums.ConcurrencyScopeAccount,
				Key:   inngestgo.StrPtr(`"openai"`),
				Limit: 5,
			},
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		return nil, nil
	},
)
if err != nil {
	return err
}

_, err = inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "func-b",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{
				Scope: enums.ConcurrencyScopeAccount,
				Key:   inngestgo.StrPtr(`"openai"`),
				Limit: 50,
			},
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		return nil, nil
	},
)
if err != nil {
	return err
}
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="func-a",
    trigger=inngest.TriggerEvent(event="ai/summary.requested"),
    concurrency=[
      inngest.Concurrency(
        scope="account",
        key='"openai"',
        limit=5
      )
    ]
)
async def func_a(ctx: inngest.Context):
    pass

@inngest_client.create_function(
    fn_id="func-b",
    trigger=inngest.TriggerEvent(event="ai/summary.requested"),
    concurrency=[
      inngest.Concurrency(
        scope="account",
        key='"openai"',
        limit=50
      )
    ]
)
async def func_b(ctx: inngest.Context):
    pass
```

This works in Inngest and is *not* a conflict.  Instead, function A is limited any time there are 5 or more functions running in the 'openai' queue.  Function B, however, is limited when there are 50 or more items in the queue.  This means that function B has more capacity than function A, though both are limited and compete on the same virtual queue.

Because functions are FIFO, function runs are more likely to be worked on the older their jobs get (as the backlog grows).  If function A's jobs stay in the backlog longer than function B's jobs, it's likely that their jobs will be worked on as soon as capacity is free.  That said, function B will almost always have capacity before function A and may block function A's work.

**While this works we strongly recommend that you use global constants for `env` or `account` level scopes, giving functions the same limit.**

## Limitations

- Concurrency limits the number of steps executing at a single time. It does not *yet* perform rate limiting over a given period of time.
- Functions can specify up to 2 concurrency constraints at once
- The maximum concurrency limit is defined by your account's plan
- Ordering amongst the same function is guaranteed (with the exception of retries)
- Ordering amongst different functions is not guaranteed.  Functions compete with each other randomly to be scheduled.

## Concurrency reference

- `limit` (number): The maximum number of concurrently running steps.
  A value of 0 or undefined is the equivalent of not setting a limit.
  The maximum value is dictated by your account's plan.

* `scope` ('account' | 'env' | 'fn'): The scope for the concurrency limit, which impacts whether concurrency is managed on an individual function, across an environment, or across your entire account.fn (default):  only the runs of this function affects the concurrency limitenv:  all runs within the same environment that share the same evaluated key value will affect the concurrency limit.  This requires setting a key which evaluates to a virtual queue name.account:  every run that shares the same evaluated key value will affect the concurrency limit, across every environment.  This requires setting a key which evaluates to a virtual queue name.Each SDK exposes these enums in the idiomatic manner of a given language, though the meanings of the enums are the same across all languages.

- `key` (string): An expression which evaluates to a string given the triggering event.  The string returned from the expression is used as the concurrency queue name.  A key is required when setting an env or account level scope.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Limit concurrency to n (via limit) per customer id: 'event.data.customer\_id'Limit concurrency to n per user, per import id: 'event.data.user\_id + "-" + event.data.import\_id'Limit globally using a specific string: '"global-quoted-key"' (wrapped in quotes, as the expression is evaluated as a language)

## Further examples

### Restricting parallel import jobs for a customer id

In this hypothetical system, customers can upload `.csv` files which each need to be processed and imported. We want to limit each customer to only one import job at a time so no two jobs are writing to a customer's data at a given time. We do this by setting a `limit: 1` and a concurrency `key` to the `customerId` which is included in every single event payload.

Inngest ensures that the concurrency (`1`) applies to each unique value for `event.data.customerId`. This allows different customers to have steps executing at the same exact time, but no given customer can have two steps executing at once!

```ts {{ title: "TypeScript" }}
export const send = inngest.createFunction(
  {
    name: "Process customer csv import",
    id: "process-customer-csv-import",
    concurrency: {
      limit: 1,
      key: `event.data.customerId`, // You can use any piece of data from the event payload
    },
  },
  { event: "csv/file.uploaded" },
  async ({ event, step }) => {
    await step.run("process-file", async () => {
      const file = await bucket.fetch(event.data.fileURI);
      // ...
    });

    return { message: "success" };
  }
);
```

```go {{ title: "Go" }}
type EventData struct {
	CustomerID string `json:"customer_id"`
	FileURI    string `json:"file_uri"`
}

_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "Process customer csv import",
		ID:   "process-customer-csv-import",
		Concurrency: []inngestgo.ConfigStepConcurrency{
			{
				Limit: 1,
				Key:   inngestgo.StrPtr("event.data.customer_id"), // You can use any piece of data from the event payload
			},
		},
	},
	inngestgo.EventTrigger("csv/file.uploaded", nil),
	func(ctx context.Context, input inngestgo.Input[EventData]) (any, error) {
		_, err := step.Run(ctx, "process-file", func(ctx context.Context) (any, error) {
			file, err := bucket.Fetch(input.Event.Data.FileURI)
			if err != nil {
				return nil, err
			}
			parseFile(file)
			return nil, nil
		})
		if err != nil {
			return err, nil
		}

		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="process-customer-csv-import",
    name="Process customer csv import",
    trigger=inngest.TriggerEvent(event="csv/file.uploaded"),
    concurrency=[
        inngest.Concurrency(
            limit=1,
            key="event.data.customerId"  # You can use any piece of data from the event payload
        )
    ]
)
async def process_csv_import(ctx: inngest.Context):
    async def process_file():
        file = await bucket.fetch(ctx.event.data.file_uri)
        parse_file(file)

    await ctx.step.run("process-file", process_file)
    return {"message": "success"}
```

## Tips

- Configure [start timeouts](/docs-markdown/features/inngest-functions/cancellation/cancel-on-timeouts) to prevent large backlogs with concurrency


--------------------------------------------------------------------------------
title: "Debounce"
source: "https://www.inngest.com/docs/guides/debounce"
--------------------------------------------------------------------------------

# Debounce

Debounce delays function execution until a series of events are no longer received. This is useful for preventing wasted work when a function might be triggered in quick succession. Use cases for debounce include:

- Preventing wasted work when handling events from user input that may change multiple times in a short time period.
- Delaying processing of noisy webhook events until they are no longer received.
- Ensuring that functions use the latest event within a series of updates (for example, synchronization).

## How to configure debounce

```ts {{ title: "TypeScript" }}
inngest.createFunction(
  {
    id: "handle-webhook",
    debounce: {
      key: "event.data.account_id",
      period: "5m",
      timeout: "10m",
    },
  },
  { event: "intercom/company.updated" },
  async ({ event, step }) => {
    // This function will only be scheduled 5 minutes after events are no longer received with the same
    // `event.data.account_id` field.
    //
    // `event` will be the last event in the series received.
  }
);
```

```go {{ title: "Go" }}
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "handle-webhook",
		Debounce: &inngestgo.ConfigDebounce{
			Key:     "event.data.account_id",
			Period:  5 * time.Minute,
			Timeout: inngestgo.Ptr(10 * time.Minute),
		},
	},
	inngestgo.EventTrigger("intercom/company.updated", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// This function will only be scheduled 5 minutes after events are
		// no longer received with the same `data.account_id` field.
		//
		// `ctx.event` will be the last event in the series received.
		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="handle-webhook",
    debounce=inngest.Debounce(
        key="event.data.account_id",
        period=datetime.timedelta(minutes=5),
    ),
    trigger=inngest.TriggerEvent(event="intercom/company.updated")
)
async def handle_webhook(ctx: inngest.Context):
    # This function will only be scheduled 5 minutes after events are no longer
    # received with the same `data.account_id` field.
    #
    # `ctx.event` will be the last event in the series received.
    pass
```

### Configuration reference

- `period` - The time delay to delay execution. The period begins when the first matching event is received.
- `key` - An optional [expression](/docs-markdown/guides/writing-expressions) using event data to apply each limit too. Each unique value of the `key` has its own limit, enabling you to rate limit function runs by any particular key, like a user ID.
- `timeout` - Optional. The maximum time that a debounce can be extended before running.

## How it works

When a function is triggered, the debounce `period` begins. If another event is received that matches the function's trigger, the debounce `period` is reset.  This continues until no events are received for the debounce `period`.  Once the `period` has passed without any new events, the function is executed using the last event received.

If a `timeout` is provided, the function will always run after the `timeout` has passed even if new events are received. This ensures that the function does not continue to be debounced indefinitely if events continue to debounce the function.

### Using a `key`

When a `key` is added, a separate debounce period is applied for each unique value of the `key` expression. For example, if your `key` is set to `event.data.customer_id`, each customer would have their individual debounce period applied to functions run. Read [our guide to writing expressions](/docs/guides/writing-expressions) for more information.

## Comparison to rate limiting

If you prefer to execute a function for the *first* event received, consider using [rate limiting](/docs-markdown/guides/rate-limiting) instead. Rate limiting ensures that a function runs once for each `key` the *first* time an event is received, while debounce uses the *last* event during a specified period.

## Combining with idempotency

Debounce can be combined with [idempotency](/docs-markdown/guides/handling-idempotency#at-the-function-level-the-consumer) to ensure that once the debounced function has run, it does not run again.

## Limitations

- The maximum debounce `period` is 7 days (168 hours).
- The minimum debounce `period` is 1 second.
- Debounce does not work with [batched functions](/docs-markdown/guides/batching).

## Further reference

- [TypeScript SDK Reference](/docs-markdown/reference/functions/debounce)
- [Python SDK Reference](/docs-markdown/reference/python/functions/create#configuration)


--------------------------------------------------------------------------------
title: "Delayed Functions"
source: "https://www.inngest.com/docs/guides/delayed-functions"
--------------------------------------------------------------------------------

# Delayed Functions

You can easily enqueue jobs in the future with Inngest. Inngest offers two ways to run jobs in the future: delaying jobs for a specific amount of time (up to a year, and for free plan up to seven days), or running code at a specific date and time. There are some benefits to enqueuing jobs using Inngest:

- It works across any provider or platform
- Delaying jobs is durable, and works across server restarts, serverless functions, and redeploys
- You can enqueue jobs into the far future
- Serverless functions are fully supported on all platforms
- Our SDK bypasses serverless function timeouts on all platforms
- You never need to manage queues or backlogs

### Platform support

**This works across all providers and platforms**, whether you run serverless functions or use servers like express.  **It also bypasses serverless function timeouts** on all platforms, so you can sleep for a longer time than your provider supports.

## Delaying jobs

#### TypeScript

You can delay jobs using the [`step.sleep()`](/docs-markdown/reference/functions/step-sleep) method:

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "signup-flow" });

export const fn = inngest.createFunction(
  { id: "send-signup-email" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    await step.sleep("wait-a-moment", "1 hour");
    await step.run("do-some-work-in-the-future", async () => {
      // This runs after 1 hour
    });
  }
);
```

For more information on `step.sleep()` read [the reference](/docs-markdown/reference/functions/step-sleep).

## Running at specific times

You can run jobs at a specific time using the [`step.sleepUntil()`](/docs-markdown/reference/functions/step-sleep-until) method:

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "signup-flow" });

export const fn = inngest.createFunction(
  { id: "send-signup-email" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    await step.sleepUntil("wait-for-iso-string", "2023-04-01T12:30:00");

    // You can also sleep until a timestamp within the event data.  This lets you
    // pass in a time for you to run the job:
    await step.sleepUntil("wait-for-timestamp", event.data.run_at); // Assuming event.data.run_at is a timestamp.

    await step.run("do-some-work-in-the-future", async () => {
      // This runs at the specified time.
    });
  }
);
```

For more information on `step.sleepUntil()` [read the reference](/docs-markdown/reference/functions/step-sleep-until).

#### Go

You can delay jobs using the [`step.Sleep()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Sleep) method:

```go
import (
	"context"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadSendSignUpEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "send-signup-email",
		},
		inngestgo.EventTrigger("app/user.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			// business logic
			_, err := step.Run(ctx, "send-the-user-a-signup-email", func(ctx context.Context) (any, error) {
				return SendEmail(SendEmailInput{
					To:      input.Event.Data["user_email"].(string),
					Subject: "Welcome to Inngest!",
					Message: "...",
				})
			})
			if err != nil {
				return nil, err
			}

			step.Sleep(ctx, "wait-for-the-future", 4*time.Hour)

			_, err = step.Run(ctx, "do-some-work-in-the-future", func(ctx context.Context) (any, error) {
				// Code here runs in the future automatically.
				return nil, nil
			})
			return nil, err
		},
	)
}
```

For more information on `step.sleep()` read [the reference](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Sleep).

#### Python

You can delay jobs using the [`step.sleep()`](http://localhost:3001/docs-markdown/reference/python/steps/sleep) method:

```python
import inngest
from src.inngest.client import inngest_client
from datetime import timedelta

@inngest_client.create_function(
    fn_id="send-signup-email", 
    trigger=inngest.TriggerEvent(event="app/user.created")
)
async def send_signup_email(ctx: inngest.Context):
    
    await ctx.step.sleep("wait-for-the-future", timedelta(hours=4))

    async def future_work():
        # Code here runs in the future automatically
        pass

    await ctx.step.run("do-some-work-in-the-future", future_work)
```

For more information on `step.sleep()` read [the reference](/docs-markdown/reference/functions/step-sleep).

## Running at specific times

You can run jobs at a specific time using the [`step.sleep_until()`](/docs-markdown/reference/python/steps/sleep-until) method:

```python
import inngest
from src.inngest.client import inngest_client

inngest_client = inngest.Inngest(
    app_id="my-app",
)

@inngest_client.create_function(
    fn_id="send-signup-email", 
    trigger=inngest.TriggerEvent(event="app/user.created")
)
async def send_signup_email(ctx: inngest.Context):
    async def send_email():
        await sesclient.send_email(
            to=ctx.event.data["user_email"],
            subject="Welcome to Inngest!",
            message="..."
        )
    
    await ctx.step.run("send-the-user-a-signup-email", send_email)
    
    await ctx.step.sleep_until("wait-for-the-future", "2023-02-01T16:30:00")

    async def future_work():
        # Code here runs in the future automatically
        pass

    await ctx.step.run("do-some-work-in-the-future", future_work)
```

For more information on `step.sleep_until()` [read the reference](/docs-markdown/reference/python/steps/sleep-until).

## How it works

In both methods, **the function controls when it runs**.  You control the flow of your code by calling `sleep` or `sleepUntil` within your function directly,
instead of using the queue to manage your code's timing.  This keeps your logic together and makes your code easier to modify.

Inngest *stops the function from running* for whatever time is specified.  When you call `step.sleep` or `step.sleepUntil` the function automatically stops running any future work. The function then tells the Inngest executor that it should be re-invoked at a future time.  We re-call the function at the next step, skipping any previous work.  This is how we bypass serverless function time limits and work across server restarts or redeploys.


--------------------------------------------------------------------------------
title: "Errors & Retries"
source: "https://www.inngest.com/docs/guides/error-handling"
--------------------------------------------------------------------------------

# Errors & Retries

Inngest Functions are designed to handle errors or exceptions gracefully and will automatically retry after an error or exception. This adds an immediate layer of durability to your code, ensuring it survives transient issues like network timeouts, outages, or database locks.

Inngest Functions come with:

**Automatic Retries**: [Configurable with a custom retry policies to suit your specific use case.]('/docs-markdown/features/inngest-functions/error-retries/retries')

**Failure handlers**: [Utilize callbacks to handle all failing retries.]('/docs/features/inngest-functions/error-retries/failure-handlers')

**Rollbacks support**: [Each step within a function can have its own retry logic and be handled individually.]('/docs/features/inngest-functions/error-retries/rollbacks')

## Types of failure

Inngest helps you handle both **errors** and **failures**, which are defined differently.

An **error** causes a step to retry. Exhausting all retry attempts will cause that step to **fail**, which means the step will never be attempted again this run.

A **failed** step can be handled with native language features such as `try`/`catch`, but unhandled errors will cause the function to **fail**, meaning the run is marked as "Failed" in the Inngest UI and all future executions are cancelled.

See how to handle step failure by [performing rollbacks](/docs/features/inngest-functions/error-retries/rollbacks).

## Failures, Retries and Idempotency

Re-running a step upon error requires its code to be idempotent, which means that running the same code multiple times won't have any side effect.

For example, a step inserting a new user to the database is not idempotent while a step [upserting a user](https://www.cockroachlabs.com/blog/sql-upsert/) is.

Learn how to write idempotent steps that can be retried safely by reading ["Handling idempotency"](/docs-markdown/guides/handling-idempotency).


--------------------------------------------------------------------------------
title: "Fan-out (one-to-many)"
source: "https://www.inngest.com/docs/guides/fan-out-jobs"
--------------------------------------------------------------------------------

# Fan-out (one-to-many)

The fan-out pattern enables you to send a single event and trigger multiple functions in parallel (one-to-many). The key benefits of this approach are:

- **Reliability**: Logic from each function runs independently, meaning an issue with one function will not affect the other(s).
- **Performance**: As functions area run in parallel, all of the work will execute faster than running in sequence.

A use case for fan-out is, for example, when a user signs up for your product. In this scenario, you may want to:

1. Send a welcome email
2. Start a trial in Stripe
3. Add the user to your CRM
4. Add the user's email to your mailing list

The fan-out pattern is also useful in distributed systems where a single event is consumed by functions running in different applications.

## How to fan-out to multiple functions

#### TypeScript

Since Inngest is powered by events, implementing fan-out is as straightforward as defining multiple functions that use the same event trigger. Let's take the above example of user signup and implement it in Inngest.

First, set up a `/signup` route handler to send an event to Inngest when a user signs up:

```ts {{ filename: "app/routes/signup/route.ts" }}
import { inngest } from '../inngest/client';

export async function POST(request: Request) {
  // NOTE - this code is simplified for the example:
  const { email, password } = await request.json();
  const user = await createUser({ email, password });
  await createSession(user.id);

  // Send an event to Inngest
  await inngest.send({
    name: 'app/user.signup',
    data: {
      user: {
        id: user.id,
        email: user.email,
      },
    },
  });

  redirect('https://myapp.com/dashboard');
}
```

Now, with this event, any function using `"app/user.signup"` as its event trigger will be automatically invoked.

Next, define two functions: `sendWelcomeEmail` and `startStripeTrial`. As you can see below, both functions use the same event trigger, but perform different work.

```ts {{ filename: "inngest/functions.ts" }}
const sendWelcomeEmail = inngest.createFunction(
  { id: 'send-welcome-email' },
  { event: 'app/user.signup' },
  async ({ event, step }) => {
    await step.run('send-email', async () => {
      await sendEmail({ email: event.data.user.email, template: 'welcome');
    });
  }
)

const startStripeTrial = inngest.createFunction(
  { id: 'start-stripe-trial' },
  { event: 'app/user.signup' },
  async ({ event }) => {
    const customer = await step.run('create-customer', async () => {
      return await stripe.customers.create({ email: event.data.user.email });
    });
    await step.run('create-subscription', async () => {
      return await stripe.subscriptions.create({
        customer: customer.id,
        items: [{ price: 'price_1MowQULkdIwHu7ixraBm864M' }],
        trial_period_days: 14,
      });
    });
  }
)
```

You've now successfully implemented fan-out in our application. Each function will run independently and in parallel. If one function fails, the others will not be disrupted.

Other benefits of fan-out include:

- **Bulk Replay**: If a third-party API goes down for a period of time (for example, your email provider), you can use [Replay](/docs-markdown/platform/replay) to selectively re-run all functions that failed, without having to re-run all sign-up flow functions.
- **Testing**: Each function can be tested in isolation, without having to run the entire sign-up flow.
- **New features or refactors**: As each function is independent, you can add new functions or refactor existing ones without having to edit unrelated code.
- **Trigger functions in different codebases**: If you have multiple codebases, even using different programming languages (for example [Python](/docs-markdown/reference/python) or [Go](https://pkg.go.dev/github.com/inngest/inngestgo)), you can trigger functions in both codebases from a single event.

#### Go

Since Inngest is powered by events, implementing fan-out is as straightforward as defining multiple functions that use the same event trigger. Let's take the above example of user signup and implement it in Inngest.

First, set up a `/signup` route handler to send an event to Inngest when a user signs up:

```go {{ filename: "main.go" }}
import (
	"encoding/json"
	"log"
	"net/http"

	"github.com/inngest/inngestgo"
)

func main() {
	// Initialize the Inngest SDK client
	client, err := inngestgo.NewClient(inngestgo.ClientOpts{
		AppID: "core",
	})
	if err != nil {
		panic(err)
	}

	// Initialize your HTTP server
	mux := http.NewServeMux()

	// Handle signup route
	mux.HandleFunc("/signup", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		// Parse request body - in a real app you'd validate the input
		var user struct {
			Email string `json:"email"`
		}
		if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		// Send event to Inngest
		_, err := client.Send(r.Context(), inngestgo.Event{
			Name: "app/user.signup",
			Data: map[string]interface{}{
				"user": map[string]interface{}{
					"email": user.Email,
				},
			},
		})
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
	})

	// Start the server
	log.Fatal(http.ListenAndServe(":8080", mux))
}
```

Now, with this event, any function using `"app/user.signup"` as its event trigger will be automatically invoked.

Next, define two functions: `sendWelcomeEmail` and `startStripeTrial`. As you can see below, both functions use the same event trigger, but perform different work.

```go {{ filename: "inngest/functions.go" }}
func loadSendWelcomeEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "send-welcome-email",
		},
		inngestgo.EventTrigger("app/user.signup", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			_, err := step.Run(ctx, "send-email", func(ctx context.Context) (any, error) {
				return SendEmail(SendEmailInput{
					To:      input.Event.Data["user"].(map[string]interface{})["email"].(string),
					Subject: "welcome",
				})
			})
			return nil, err
		},
	)
}

func loadStartStripeTrialInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "start-stripe-trial",
		},
		inngestgo.EventTrigger("app/user.signup", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			customerID, err := step.Run(ctx, "create-customer", func(ctx context.Context) (any, error) {
				return CreateStripeAccount(&StripeCustomerParams{
					Email: input.Event.Data["user"].(map[string]interface{})["email"].(string),
				})
			})
			if err != nil {
				return nil, err
			}
			_, err = step.Run(ctx, "create-subscription", func(ctx context.Context) (any, error) {
				return CreateStripeSubscription(&StripeSubscriptionParams{
					Customer:        customerID.(string),
					TrialPeriodDays: 14,
				})
			})
			return nil, err
		},
	)
}
```

You've now successfully implemented fan-out in our application. Each function will run independently and in parallel. If one function fails, the others will not be disrupted.

Other benefits of fan-out include:

- **Bulk Replay**: If a third-party API goes down for a period of time (for example, your email provider), you can use [Replay](/docs-markdown/platform/replay) to selectively re-run all functions that failed, without having to re-run all sign-up flow functions.
- **Testing**: Each function can be tested in isolation, without having to run the entire sign-up flow.
- **New features or refactors**: As each function is independent, you can add new functions or refactor existing ones without having to edit unrelated code.
- **Trigger functions in different codebases**: If you have multiple codebases, even using different programming languages (for example [TypeScript](/docs-markdown/reference/typescript) or [Python](/docs-markdown/reference/python)), you can trigger functions in both codebases from a single event.

#### Python

Since Inngest is powered by events, implementing fan-out is as straightforward as defining multiple functions that use the same event trigger. Let's take the above example of user signup and implement it in Inngest.

First, set up a `/signup` route handler to send an event to Inngest when a user signs up:

```py {{ title: "Flask route" }}
import inngest
from flask import Flask, request, redirect

inngest_client = inngest.Inngest(app_id="my-app")
app = Flask(__name__)

@app.route("/signup", methods=["POST"])
async def signup():
    # NOTE - this code is simplified for the example:
    data = await request.get_json()
    email = data["email"]
    password = data["password"]

    user = await create_user(email=email, password=password)
    await create_session(user.id)

    # Send an event to Inngest
    await inngest_client.send(
        inngest.Event(
            name="app/user.signup",
            data={"id": user.id, "email": user.email},
        )
    )

    return redirect("https://myapp.com/dashboard")
```

```py {{ title: "FastAPI route" }}
import inngest
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse

inngest_client = inngest.Inngest(app_id="my-app")
app = FastAPI()

@app.post("/signup")
async def signup(request: Request):
    # NOTE - this code is simplified for the example:
    data = await request.json()
    email = data["email"]
    password = data["password"]

    user = await create_user(email=email, password=password)
    await create_session(user.id)

    # Send an event to Inngest
    await inngest_client.send(
        inngest.Event(
            name="app/user.signup",
            data={"id": user.id, "email": user.email},
        )
    )

    return RedirectResponse(url="https://myapp.com/dashboard")
```

Now, with this event, any function using `"app/user.signup"` as its event trigger will be automatically invoked.

Next, define two functions: `sendWelcomeEmail` and `startStripeTrial`. As you can see below, both functions use the same event trigger, but perform different work.

```py {{ filename: "inngest/functions.py" }}
@inngest_client.create_function(
    fn_id="send-welcome-email",
    trigger=inngest.TriggerEvent(event="app/user.signup"),
)
async def send_welcome_email(ctx: inngest.Context) -> None:
    await ctx.step.run("send-email", lambda: send_email(
        email=ctx.event.data["email"],
        template="welcome",
    ))

@inngest_client.create_function(
    fn_id="start-stripe-trial", 
    trigger=inngest.TriggerEvent(event="app/user.signup"),
)
async def start_stripe_trial(
    ctx: inngest.Context,
) -> None:
    customer = await ctx.step.run("create-customer", lambda: stripe.Customer.create(
        email=ctx.event.data["email"]
    ))
    
    await ctx.step.run("create-subscription", lambda: stripe.Subscription.create(
        customer=customer.id,
        items=[{"price": "price_1MowQULkdIwHu7ixraBm864M"}],
        trial_period_days=14
    ))
```

You've now successfully implemented fan-out in our application. Each function will run independently and in parallel. If one function fails, the others will not be disrupted.

Other benefits of fan-out include:

- **Bulk Replay**: If a third-party API goes down for a period of time (for example, your email provider), you can use [Replay](/docs-markdown/platform/replay) to selectively re-run all functions that failed, without having to re-run all sign-up flow functions.
- **Testing**: Each function can be tested in isolation, without having to run the entire sign-up flow.
- **New features or refactors**: As each function is independent, you can add new functions or refactor existing ones without having to edit unrelated code.
- **Trigger functions in different codebases**: If you have multiple codebases, even using different programming languages (for example [TypeScript](/docs-markdown/reference/typescript) or [Go](https://pkg.go.dev/github.com/inngest/inngestgo)), you can trigger functions in both codebases from a single event.

## Further reading

- [Sending events](/docs-markdown/events)
- [Invoking functions from within functions](/docs-markdown/guides/invoking-functions-directly)
- [Sending events from functions](/docs-markdown/guides/sending-events-from-functions)


--------------------------------------------------------------------------------
title: "Flow Control"
source: "https://www.inngest.com/docs/guides/flow-control"
--------------------------------------------------------------------------------

# Flow Control

Flow control is a critical part of building robust applications. It allows you to manage the flow of data and events through your application which can help you manage resources, prevent overloading systems, and ensure that your application is responsive and reliable.

There are several methods to manage flow control for each Inngest function. Learn about each method and how to use them in your functions:

**Concurrency**: [Limit the number of executing steps across your function runs. Ideal for limiting concurrent workloads by user, resource, or in general.]('/docs-markdown/guides/concurrency')

**Throttling**: [Limit the throughput of function execution over a period of time. Ideal for working around third-party API rate limits.]('/docs/guides/throttling')

**Rate Limiting**: [Prevent excessive function runs over a given time period by skipping events beyond a specific limit. Ideal for protecting against abuse.]('/docs/guides/rate-limiting')

**Debounce**: [Avoid unnecessary function invocations by de-duplicating events over a sliding time window. Ideal for preventing wasted work when a function might be triggered in quick succession.]('/docs/guides/debounce')

**Priority**: [Dynamically adjust the execution order of functions based on any data. Ideal for pushing critical work to the front of the queue.]('/docs/guides/priority')


--------------------------------------------------------------------------------
title: "Handling idempotency"
source: "https://www.inngest.com/docs/guides/handling-idempotency"
--------------------------------------------------------------------------------

# Handling idempotency

Ensuring that your code is idempotent is foundational to building reliable systems. Within Inngest, there are multiple ways to ensure that your functions are idempotent.

## What is idempotency?

Idempotency, by definition, describes an operation that can occur multiple times without changing the result beyond the initial execution. In the world of software, this means that a functions can be executed multiple times, but it will always have the same effect as being called once. An example of this is an "upsert."

## How to handle idempotency with Inngest

It should always be the aim to write code that is idempotent itself within your system or your Inngest functions, but there are also some features within Inngest that can help you ensure idempotency.

As Inngest functions are triggered by events, there are two main ways to ensure idempotency:

- [at the event level (*the producer*)](#at-the-event-level-the-producer) and/or
- [at the function level (*the consumer*)](#at-the-function-level-the-consumer)

## At the event level (the producer)

Each event that is received by Inngest will trigger any functions with that matching trigger. If an event is sent twice, Inngest will trigger the function twice. This is the default behavior as Inngest does not know if the event is the same event or a new event.

> **Callout:** Example: Using an e-commerce store as an example, a user can add the same t-shirt to their cart twice because they want to buy two (2 unique events). That same user may check out and pay for all items in their cart but click the "pay" button twice (2 duplicate events).

To prevent an event from being handled twice, you can set a unique event `id` when [sending the event](/docs-markdown/reference/events/send#inngest-send-event-payload-event-payload-promise). This `id` acts as an idempotency key **over a 24 hour period** and Inngest will check to see if that event has already been received before triggering another function.

```ts
const cartId = 'CGo5Q5ekAxilN92d27asEoDO';
await inngest.send({
  id: `checkout-completed-${cartId}`, // <-- This is the idempotency key
  name: 'cart/checkout.completed',
  data: {
    email: 'taylor@example.com',
    cartId: cartId
  }
})
```

```go {{ title: "Go" }}
cart_id := "CGo5Q5ekAxilN92d27asEoDO"
inngest.Send(context.Background(), inngestgo.Event{
  ID: fmt.Sprintf("checkout-completed-%s", cart_id), // <-- This is the idempotency key
  Name: "cart/checkout.completed",
  Data: map[string]any{"email": "taylor@example.com", "cart_id": cart_id},
})
```

```python {{ title: "Python" }}
cart_id = 'CGo5Q5ekAxilN92d27asEoDO'
await inngest.send({
  id: f'checkout-completed-{cart_id}', // <-- This is the idempotency key
  name: 'cart/checkout.completed',
  data: {
    email: 'taylor@example.com',
    cart_id: cart_id
  }
})
```

| Event ID                                      | Timestamp    | Function                  |
| --------------------------------------------- | ------------ | ------------------------- |
| `checkout-completed-CGo5Q5ekAxilN92d27asEoDO` | 08:00:00.000 | ‚úÖ Functions are triggered |
| `checkout-completed-CGo5Q5ekAxilN92d27asEoDO` | 08:00:00.248 | ‚ùå Nothing is triggered    |

As you can see in the above example, setting the `id` allows you to prevent duplicate execution on the producer side, where the event originates.

Some other key points to note:

- Event IDs will only be used to prevent duplicate execution for a 24 hour period. After 24 hours, the event will be treated as a new event and will trigger any functions with that trigger.
- Inngest will store the second event and it will be visible in your event history, but it will *not* trigger any functions.
- Events that fan-out to multiple functions will trigger each function as they normally would.

> **Callout:** Tip - If you are using Inngest's webhook transforms, you can set the id in the transform to ensure that the event is idempotent.

> **Callout:** Event idempotency is ignored by some features:DebouncingEvent batchingFunction pausing. While a function is paused, event idempotency is ignored. So if a replay is created after unpausing, it may have "skipped" runs that ignored event idempotency.

## At the function level (the consumer)

You might prefer to ensure idempotency at the function level or you may not be able to control the event that is being sent (from a webhook). The [function's `idempotency` config option](/docs-markdown/reference/functions/create#inngest-create-function-configuration-trigger-handler-inngest-function) allows you to do this.

Each function's `idempotency` key is defined as a [CEL expression](/docs-markdown/guides/writing-expressions) that is evaluated with the event payload's data. The expression is used to generate a unique string key which idempotently prevents duplicate execution of the function.

Each unique expression will only trigger one function execution **per 24 hour period**. After 24 hours, a new event that generates the same unique expression will trigger another function execution.

### Example

We'll use the same example of an e-commerce store to demonstrate how this works. We have an event here with no `id` set ([see above](#at-the-event-level-the-producer)), but we want to ensure that the `send-checkout-email` function is only triggered once for each `cartId` to prevent duplicate emails being sent.

```json {{ title: "Event payload"}}
{
  "name": "cart/checkout.completed",
  "data": {
    "email": "blake@example.com",
    "cartId": "s6CIMNqIaxt503I1gVEICfwp"
  },
  "ts": 1703275661157
}
```

```ts {{ title: "Function definition with idempotency key"}}
export const sendEmail = inngest.createFunction(
  {
    id: 'send-checkout-email',
    // This is the idempotency key
    idempotency: 'event.data.cartId',
    // Evaluates to: "s6CIMNqIaxt503I1gVEICfwp"
    // for the given event payload
  },
  { trigger: 'cart/checkout.completed' },
  async  ({ event, step }) => { /* ... */ }
})
```

### Writing CEL expressions

While CEL can do many things, we'll focus on how to use it to generate a unique string key for idempotency. The key things to know are:

- You can access any of the event payload's data using the `event` variable and dot-notation for nested properties.
- You can use the `+` operator to concatenate strings together.

Combining two or more properties together is a good way to ensure the level of uniqueness that you need. Here are couple of examples:

- **User signup:** You only want to send a welcome email once per user, so you'd set `idempotency` to `event.data.userId` in case there your API sends duplicate events.
- **Organization team invite:** A user may be part of multiple organizations in your app. You only want to send a team invite email once per user/organization combination, so you'd set `idempotency` to `event.data.userId + "-" + event.data.organizationId`.

For more information on writing CEL expressions, read [our guide](/docs-markdown/guides/writing-expressions).

> **Callout:** üí° If you want to control when a function is executed over a period of time you might prefer:rateLimit - Limit the number of function executions per period of timedebounce - Delay function execution for duplicate events over a period of time

### Idempotency keys and fan-out

One reason why you might want to use `idempotency` at the function level is if you have an `event` that fans-out to multiple functions. Let's take the following fan-out example:

| Function       | Event trigger             | How often        |
| -------------- | ------------------------- | ---------------- |
| Track requests | `ai/generation.requested` | Every time       |
| Run generation | `ai/generation.requested` | Once per request |

In this case, you would want to set `idempotency` on the "Run generation" function to ensure that it runs once, for example, for every unique prompt that is sent. You may want to do this as you don't want to re-run the same exact prompt and waste compute resources/credits. However, you still might want to track the number of requests that each user submitted, so you would not want to set `idempotency` on the "Track requests" function. You can see the code for both functions below.

**View the function code**

Both functions use the same event trigger, `ai/generation.requested` which contains a `promptHash` and a `userId` in the event payload.

```ts {{ title: "Track requests function" }}
const trackRequests = inngest.createFunction(
  { id: 'track-requests' },
  { event: 'ai/generation.requested' },
  async ({ event, step }) => {
    // Track the request
  }
)
```

```ts {{ title: "Run generation function" }}
const runGeneration = inngest.createFunction(
  {
    id: 'run-generation',
    // Given the event payload sends a hash of the prompt,
    // this will only run once per unique prompt per user
    // every 24 hours:
    idempotency: `event.data.promptHash + "-" + event.data.userId`
  },
  { event: 'ai/generation.requested' },
  async ({ event, step }) => {
    // Track the request
  }
)
```


--------------------------------------------------------------------------------
title: "Instrumenting GraphQL"
source: "https://www.inngest.com/docs/guides/instrumenting-graphql"
--------------------------------------------------------------------------------

# Instrumenting GraphQL

When building with GraphQL, you can give your event-driven application a kick-start by instrumenting every query and mutation, sending events when one is successfully executed.

We can do this using an [Envelop](https://envelop.dev/) plugin, `useInngest`, for [GraphQL Yoga](https://the-guild.dev/graphql/yoga-server) and servers or frameworks powered by Yoga, such as [RedwoodJS](https://www.redwoodjs.com/).

By instrumenting with the `useInngest` plugin:

- Get an immediate set of events to react to that automatically grows with your GraphQL API.
- No changes to your existing resolvers are ever needed.
- Utilise fine-grained control over what events are sent such as operations (queries, mutations, or subscriptions), introspection events, when GraphQL errors occur, if result data should be included, type and schema coordinate denylists, and more.
- Automatically capture context such as user data.

## Getting Started

```sh
npm install envelop-plugin-inngest # or yarn add
```

### Usage example

Using `useInngest` just requires that you have an Inngest client (see the [Quick start](/docs-markdown/getting-started/nextjs-quick-start)) set up with an appropriate event key (see [Creating an event key](https://www.inngest.com/docs-markdown/events/creating-an-event-key)).

Here's a single-file example of how to add the plugin.

```ts
import { useInngest } from "envelop-plugin-inngest";
import { createSchema, createYoga } from "graphql-yoga";
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "my-app" });

// Provide your schema
const yoga = createYoga({
  schema: createSchema({
    typeDefs: /* GraphQL */ `
      type Query {
        greetings: String!
      }
    `,
    resolvers: {
      Query: {
        greetings: () => "Hello World!",
      },
    },
  }),

  // Add the plugin to the server. RedwoodJS users can use the
  // `extraPlugins` option instead.
  plugins: [useInngest({ inngestClient: inngest })],
});

// Start the server and explore http://localhost:4000/graphql
const server = createServer(yoga);

server.listen(4000, () => {
  console.info("Server is running on http://localhost:4000/graphql");
});
```

### Output events

Once the plugin is installed, an event will be sent for all successful GraphQL operations, resulting in a ready-to-use set of events that you can react to immediately.

Here's an example event sent from a mutation to create a new item in a user's cart:

```json
{
  "name": "graphql/create-cart-item.mutation",
  "data": {
    "identifiers": [
      {
        "id": 27,
        "typename": "CartItem"
      }
    ],
    "operation": {
      "id": "create-cart-item",
      "name": "CreateCartItem",
      "type": "mutation"
    },
    "result": {
      "data": {
        "createCartItem": {
          "id": 27,
          "productId": "123"
        }
      }
    },
    "types": [
      "CartItem"
    ],
    "variables": {}
  },
  "id": "01GXXAQ1M0A1SFVGEHACRF4K1C"
}
```

### Reacting to events

We can react to this event by creating a new Inngest function with the event as the trigger.

```ts
inngest.createFunction(
  { id: "send-cart-alert" },
  { event: "graphql/create-cart-item.mutation" },
  async ({ event }) => {
    await sendSlackMessage(
      "#marketing",
      `Someone added product #${event.data.identifiers[0].id} to their cart!`
    );
  }
);
```

For more info on how to customize the events sent check out the [envelop-plugin-inngest](https://github.com/inngest/envelop-plugin-inngest) repository, or see [Writing functions](https://www.inngest.com/docs-markdown/functions) to learn how to react to these events in different ways.


--------------------------------------------------------------------------------
title: "Invoking functions directly"
source: "https://www.inngest.com/docs/guides/invoking-functions-directly"
--------------------------------------------------------------------------------

# Invoking functions directly

Inngest's `step.invoke()` function provides a powerful tool for calling functions directly within your event-driven system. It differs from traditional event-driven triggers, offering a more direct, RPC-like approach. This encourages a few key benefits:

- Allows functions to call and receive the result of other functions
- Naturally separates your system into reusable functions that can spread across process boundaries
- Allows use of synchronous interaction between functions in an otherwise-asynchronous event-driven architecture, making it much easier to manage functions that require immediate outcomes

## Invoking another function

#### TypeScript

> **Callout:** When should I invoke?Use step.invoke() in tasks that need specific settings like concurrency limits. Because it runs with its own configuration,
> distinct from the invoker's, you can provide a tailored configuration for each function.If you don't need to define granular configuration or if your function won't be reused across app boundaries, use step.run() for simplicity.

```ts
// Some function we'll call
const computeSquare = inngest.createFunction(
  { id: "compute-square" },
  { event: "calculate/square" },
  async ({ event }) => {
    return { result: event.data.number * event.data.number }; // Result typed as { result: number }
  }
);

// In this function, we'll call `computeSquare`
const mainFunction = inngest.createFunction(
  { id: "main-function" },
  { event: "main/event" },
  async ({ step }) => {
    const square = await step.invoke("compute-square-value", {
      function: computeSquare,
      data: { number: 4 }, // input data is typed, requiring input if it's needed
    });

    return `Square of 4 is ${square.result}.`; // square.result is typed as number
  }
);
```

In the above example, our `mainFunction` calls `computeSquare` to retrieve the resulting value. `computeSquare` can now be called from here or any other process connected to Inngest.

## Referencing another Inngest function

If a function exists in another app, you can create a reference that can be invoked in the same manner as the local `computeSquare` function above.

```ts
// @/inngest/computeSquare.ts
import { referenceFunction } from "inngest";
import { z } from "zod";

// Create a reference to a function in another application.
export const computeSquare = referenceFunction({
  appId: "my-python-app",
  functionId: "compute-square",
  // Schemas are optional, but provide types for your call if specified
  schemas: {
    data: z.object({
      number: z.number(),
    }),
    return: z.object({
      result: z.number(),
    }),
  },
});
```

```ts
import { computeSquare } from "@/inngest/computeSquare";

// square.result is typed as a number
const square = await step.invoke("compute-square-value", {
  function: computeSquare,
  data: { number: 4 }, // input data is typed, requiring input if it's needed
});
```

References can also be used to invoke local functions without needing to import them (and their dependencies) directly. This can be useful for frameworks like Next.js where edge and serverless handlers can be mixed together and require different sets of dependencies.

```ts
import { inngest, referenceFunction } from "inngest";
import { type computeSquare } from "@/inngest/computeSquare"; // Import only the type

const mainFunction = inngest.createFunction(
  { id: "main-function" },
  { event: "main/event" },
  async ({ step }) => {
    const square = await step.invoke("compute-square-value", {
      function: referenceFunction<typeof computeSquare>({
        functionId: "compute-square",
      }),
      data: { number: 4 }, // input data is still typed
    });

    return `Square of 4 is ${square.result}.`; // square.result is typed as number
  }
);
```

For more information on referencing functions, see [TypeScript -> Referencing Functions](/docs-markdown/functions/references).

#### Go

> **Callout:** When should I invoke?Use step.Invoke() in tasks that need specific settings like concurrency limits. Because it runs with its own configuration,
> distinct from the invoker's, you can provide a tailored configuration for each function.If you don't need to define granular configuration or if your function won't be reused across app boundaries, use step.Run() for simplicity.

```go
import (
	"context"
	"fmt"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

// Some function we'll call
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{Name: "compute-square"},
	inngestgo.EventTrigger("calculate/square", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		number, ok := input.Event.Data["number"].(float64)
		if !ok {
			return nil, fmt.Errorf("invalid number")
		}

		return map[string]any{
			"result": int(number * number),
		}, nil
	},
)

// In this function, we'll call the compute-square function
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{Name: "main-function"},
	inngestgo.EventTrigger("main/event", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		square, err := step.Invoke(ctx, "compute-square-value", &inngestgo.InvokeOpts{
			Function: "compute-square",
			Data: map[string]any{
				"number": 4,
			},
		})
		if err != nil {
			return nil, err
		}

		result := square.Data["result"].(int)
		return fmt.Sprintf("Square of 4 is %d.", result), nil
	},
)

```

In the above example, our `mainFunction` calls `computeSquare` to retrieve the resulting value. `computeSquare` can now be called from here or any other process connected to Inngest.

#### Python

> **Callout:** When should I invoke?Use step.invoke() in tasks that need specific settings like concurrency limits. Because it runs with its own configuration,
> distinct from the invoker's, you can provide a tailored configuration for each function.If you don't need to define granular configuration or if your function won't be reused across app boundaries, use step.run() for simplicity.

```py
import inngest
from src.inngest.client import inngest_client

# Some function we'll call
@inngest_client.create_function(
    fn_id="compute-square",
    trigger=inngest.TriggerEvent(event="calculate/square")
)
async def compute_square(ctx: inngest.Context):
    return {"result": ctx.event.data["number"] * ctx.event.data["number"]}  # Result typed as { result: number }

# In this function, we'll call compute_square
@inngest_client.create_function(
    fn_id="main-function",
    trigger=inngest.TriggerEvent(event="main/event")
)
async def main_function(ctx: inngest.Context):
    square = await ctx.step.invoke(
        "compute-square-value",
        function=compute_square,
        data={"number": 4}  # input data is typed, requiring input if it's needed
    )

    return f"Square of 4 is {square['result']}."  # square.result is typed as number
```

In the above example, our `mainFunction` calls `compute_square` to retrieve the resulting value. `compute_square` can now be called from here or any other process connected to Inngest.

## Creating a distributed system

You can invoke Inngest functions written in any language, hosted on different clouds.  For example, a TypeScript function on Vercel can invoke a Python function hosted in AWS.

By starting to define these blocks of functionality, you're creating a smart, distributed system with all of the benefits of event-driven architecture and without any of the hassle.

## Similar pattern: Fan-Out

A similar pattern to invoking functions directly is that of fan-out - [check out the guide here](/docs-markdown/guides/fan-out-jobs). Here are some key differences:

- Fan-out will trigger multiple functions simultaneously, whereas invocation will only trigger one
- Unlike invocation, fan-out will not receive the result of the invoked function
- Choose fan-out for parallel processing of independent tasks and invocation for coordinated, interdependent functions


--------------------------------------------------------------------------------
title: "Logging in Inngest"
source: "https://www.inngest.com/docs/guides/logging"
--------------------------------------------------------------------------------

# Logging in Inngest

Log handling can have some caveats when working with serverless runtimes.

One of the main problems is due to how serverless providers terminate after a function exits.
There might not be enough time for a logger to finish flushing, which results in logs being lost.

Another (opposite) problem is due to how Inngest handles memoization and code execution via HTTP calls to the SDK.
A log statement outside of `step` function could end up running multiple times, resulting in duplicated deliveries.

```ts {{ title: "example-fn.ts" }}
async ({ event, step }) => {
  console.log("something") // this can be run three times

  await step.run("fn", () => {
    console.log("something else") // this will always be run once
  })

  await step.run(...)
}
```

We provide a thin wrapper over existing logging tools, and export it to Inngest functions in order to mitigate these problems, so you, as the user, don't need to deal with them and things should work as you expect.

## Usage

A `logger` object is available within all Inngest functions as a handler argument. You can use it with the logger of your choice, or if absent, `logger` will default to use `console`.

```ts
inngest.createFunction(
  { id: "my-awesome-function" },
  { event: "func/awesome" },
  async ({ event, step, logger }) => { // <== logger is available as an argument
    logger.info("starting function", { metadataKey: "metadataValue" });

    const val = await step.run("do-something", () => {
      if (somethingBadHappens) logger.warn("something bad happened");
    });

    return { success: true, event };
  }
);
```

> **Tip:** We recommend using a logger library that supports a child logger .child() implementation which automatically adds function runtime metadata to your logs. Read more about enriched logs with function metadata for more details.

The exported logger provides the following interface methods:

```ts
export interface Logger {
  info(...args: any[]): void;
  warn(...args: any[]): void;
  error(...args: any[]): void;
  debug(...args: any[]): void;
}
```

These are very typical interfaces and are also on the [RFC5424 guidelines](https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1), so most loggers you choose should work without issues.

## Using your preferred logger

While `console.log` may be good enough for local development, other logging libraries provide more features that are suitable for production use.

The following examples use [winston][winston] for the logging library, including a basic example and an example with a Datadog transport.

```ts {{ title: "Winston basic example" }}
import { Inngest } from "inngest";
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  exitOnError: false,
  format: winston.format.json(),
  transports: [new winston.transports.Console()],
});

// Pass `logger` to the Inngest client, and this winston logger will be accessible within functions
export const inngest = new Inngest({
  id: "my-awesome-app",
  logger: logger,
  // ...
});
```

```ts {{ title: "Winston with Datadog transport" }}
import { Inngest } from "inngest";
import winston from "winston";

/// Assuming we're deploying to Vercel.
/// Other providers likely have their own pre-defined environment variables you can use.
const env = process.env.VERCEL_ENV || "development";
const ddTransportOps = {
  host: "http-intake.logs.datadoghq.com",
  path: `/api/v2/logs?dd-api-key=${process.env.DD_API_KEY}&ddsource=nextjs&service=inngest&ddtags=env:${env}`,
  ssl: true,
};

const logger = winston.createLogger({
  level: "info",
  exitOnError: false,
  format: winston.format.json(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.Http(ddTransportOps),
  ],
});

// Pass `logger` to the Inngest client, and this winston logger will be accessible within functions
export const inngest = new Inngest({
  id: "my-awesome-app",
  logger: logger,
  // ...
});
```

## Enriched logs with function metadata

If the logger library supports a child logger `.child()` implementation, the built-in middleware will utilize it to add function runtime metadata to your logs automatically:

- Function name
- Event name
- Run ID

```ts {{ title: "Example usage with Winston logger" }}
await step.run("summarize-content", async ({ step, logger }) => {
  logger.info("calling Claude", { max_tokens: 1000 });
});
```

```json {{ title: "Example log output" }}
{"eventName":"inngest/function.invoked","functionName":"Summarize content via GPT-4",
"level":"info","max_tokens":1000,"message":"Querying vector database",
"runID":"01KB7YQXYNPEX3XB257A3RQDRX"}
```

## Loggers supported

The following is a list of loggers we're aware of that work, but is not an exhaustive list:

- [Winston][winston] child logger support
- [Pino](https://github.com/pinojs/pino) child logger support
- [Bunyan](https://github.com/trentm/node-bunyan) child logger support
- [Roarr](https://github.com/gajus/roarr) child logger support
- [LogLevel](https://github.com/pimterry/loglevel)
- [Log4js](https://github.com/log4js-node/log4js-node)
- [npmlog](https://github.com/npm/npmlog) (doesn't have `.debug()` but has a way to add custom levels)
- [Tracer](https://github.com/baryon/tracer)
- [Signale](https://github.com/klaudiosinani/signale)

## Customizing the logger

The built-in logger is implemented using [middleware](/docs-markdown/features/middleware). You can create your own middleware to customize the logger to your needs. See the [logging middleware example](/docs-markdown/reference/middleware/examples#logging) for more details.

[winston]: https://github.com/winstonjs/winston


--------------------------------------------------------------------------------
title: "Mergent migration guide"
source: "https://www.inngest.com/docs/guides/mergent-migration"
--------------------------------------------------------------------------------

# Mergent migration guide

As Mergent transitions its focus, we recommend migrating your background jobs, workflows, and event-driven systems to Inngest, a modern developer platform purpose-built for reliable, scalable background functions and workflows.

When you migrate to Inngest, the execution still happens on your own servers (whether that's serverless or actual servers).  We manage the orchestration, queueing, and function state ‚Äî meaning migration is fast and easy.

This guide walks you through:

- [A quick introduction to Inngest](#why-migrate-to-inngest)
- [Migrating Mergent Tasks to Inngest](#migrating-tasks-to-inngest)
- [Migrating Schedules Tasks to Inngest](#migrating-schedules-to-inngest)
- [Deploying to production](#deploying-to-production)

## Why migrate to Inngest

Inngest is more than a Mergent alternative‚Ä¶ It's a next-generation workflow platform for modern developers, and it works everywhere ‚Äî whether you're running on serverless or servers.  Using Inngest, you get a powerful suite of tools out of the box, with minimal setup:

- **Durable functions and resumable workflows:** Define long-running, resumable workflows with simple async/await syntax. No state machines, context juggling, or queues to manage.
- **Built in retries, replay, idempotency, and flow control:** Automatic retries, step isolation, and state persistence ensure workflows don't break ‚Äî even during deploys or failures.
- **Local development & debugging tools:** Build and test locally with the Inngest Dev Server. Log, trace, and replay events for full observability.
- **Scalable by Default**: Inngest is built to handle hundreds of millions of runs, without managing new infrastructure.

## Migrating Tasks to Inngest

Migrating existing Mergent Tasks to Inngest only requires a few changes.

First, you'll change your Tasks HTTP handler, then your Tasks body, and finally your calls to the Mergent Tasks API.

**1. Create an Inngest client**

First, let's create an Inngest client that will be used to create and trigger Inngest functions:

```tsx
//src/inngest/client.ts
import { Inngest } from "inngest";

export const inngest = new Inngest({ id: "my-app" });
```

**2. Updating your Task handlers**

Like Mergent, Inngest will communicate with your application (where your Tasks run) over HTTP.

To do so, migrate the following Tasks handler:

```tsx
// pages/api/tasks.ts
import Mergent from "mergent";
import { sendEmail } from "@/mergent/tasks/sendEmail"

export default async function handler(req, res) {
  try {
    await sendEmail(req);
    // task was successful, respond with 200
    res.status(200).send("");
  } catch (err) {
    // task failed, respond with 500 so Mergent will retry
    res.status(500).send({ error: err });
  }
}
```

To this Inngest equivalent:

```tsx
// src/api/inngest/route.ts
import { serve } from "inngest/next";
import { inngest } from "@/inngest/client";

// Create an API that your Inngest functions
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    /* your Inngest functions will be passed here later! */
  ],
});

```

**3. Update your Task**

Let's now migrate an existing Mergent Task as an Inngest Function:

```tsx
// src/mergent/tasks/sendEmail.ts

async function sendEmail(req) {
  await sendEmail(req);
}
```

Wrap (*or extract to a new file if colocated to your Task handler*) your existing Task with `inngest.createFunction()` as follows:

```tsx
// src/inngest/functions/sendEmail.ts
import { inngest } from "@/inngest/client";

export const helloWorld = inngest.createFunction(
  { id: "send-email" },
  { event: "tasks/sendEmail" },
  async ({ event, step }) => {
    await step.run("Send daily email", async () => {
      await sendEmail(event.data.email);
    });
  },
);

```

You will notice some new concepts here:

- Inngest functions are **identified with a unique ID.**
- Inngest functions are **triggered by events** (see next section).
- Inngest functions get access to the `step` API, enabling you to **build durable workflows composed of [atomic and automatically retried steps](/docs-markdown/features/inngest-functions/steps-workflows).**

In our freshly migrated `sendEmail` task, any failure to send an email will be retried up to 4 times, [configurable via the Inngest function options](/docs-markdown/reference/functions/create).

Let's register this function by adding it to our Inngest serve handler:

```tsx
// src/api/inngest/route.ts
import { serve } from "inngest/next";
import { inngest } from "@/inngest/client";
import { myTask } from "@/inngest/functions/myTask";

// Create an API that your Inngest functions
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    myTask
  ],
});

```

**4. Migrate your Tasks API calls**

While Mergent Tasks are triggered using the [Create Tasks API endpoint](https://docs.mergent.co/api-reference/operations/create-task), Inngest Functions get triggered using events using the SDK.

Previously, our `sendEmail` Mergent Task was triggered as follows:

```tsx
const Mergent = require("mergent");

// set the Mergent API key
const mergent = new Mergent("...");

// create a task that will run in 5 minutes
// the URL should be set to the URL of your task handler
// if using JSON, don't forget to set the Content-Type header
mergent.tasks
  .create({
    request: {
      url: "...",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ hello: "world" }),
    },
    delay: { minutes: 5 },
  })
  .then((task) => console.log(task))
  .catch((error) => console.error(error));
```

Now, our `sendEmail` Inngest function gets triggered using `inngest.sendEvent()`:

```tsx
import { inngest } from "@/inngest/client";

await inngest.send({
  name: "tasks/sendEmail",
  data: {
    email: "testUser@example.com",
  },
});
```

Using events over direct HTTP invocation comes with many benefits, allowing you to:

- **Fan-out,** having one event trigger many functions
- **Replay events on failure**, in bulk
- **Wait for matching events,** in the middle of functions ([docs](/docs-markdown/features/inngest-functions/steps-workflows/wait-for-event))

**Triggering Inngest Functions via the UI**

Inngest Functions can also be triggered from the UI, either locally via the [Inngest Dev Server](/docs-markdown/local-development) or, [once deployed](https://www.notion.so/Mergent-co-migration-guide-1ddb64753bbd805990b2e03bcc6f82f0?pvs=21), via the Inngest Cloud by sending an event manually.

## Migrating Schedules to Inngest

Mergent Schedules are Tasks that run at a given interval, configured from the Mergent Dashboard.

To migrate existing Mergent Schedules to an Inngest Scheduled Function (CRON), perform the steps 1 (‚Äù*1. Create an Inngest client‚Äù*) and 2 (‚Äù*2. Update your Tasks handlers‚Äù*) ( from the ‚ÄúMigrate Tasks to Inngest‚Äù section.

Once your Inngest client is created and the Task HTTP handler is migrated to Inngest, transform your Mergent Scheduled task as follows:

```tsx
export const dailyReminder = async (req) => {
    await sendEmail(event.data.email)
);
```

The above example task has a Schedule configured to the Mergent Schedules Dashboard at `0 0 * * *` (every day at midnight).

Inngest enables you to configure your CRON interval directly from the code:

```tsx
export const dailyReminder = inngest.createFunction(
  { id: "daily-reminder" },
  { cron: "0 0 * * *" }, // Run daily at midnight UTC
  async ({ event, step }) => {
    await step.run("Send daily email", async () => {
      await sendEmail(event.data.email);
    });
  }
);
```

Note that, like any Inngest Function, Inngest Scheduled Functions can be triggered manually from the Functions tabs of the Inngest Cloud and Inngest Dev Server.

## **Deploy to Production**

Once you're ready, deploy your Inngest functions to your platform of choice (Vercel, Netlify, or a custom Node.js server). Inngest works seamlessly with serverless platforms and can also run inside any Express/Next.js app.  [Read the deployment docs here.](/docs-markdown/platform/deployment)


--------------------------------------------------------------------------------
title: "Multi-Step Functions"
source: "https://www.inngest.com/docs/guides/multi-step-functions"
--------------------------------------------------------------------------------

# Multi-Step Functions

Use Inngest's multi-step functions to safely coordinate events, delay execution for hours (or up to a year), retry [individual steps](/docs-markdown/learn/inngest-steps), and conditionally run code based on the result of previous steps and incoming events.

Critically, multi-step functions are written in code, not config, meaning you create readable, obvious functionality that's easy to maintain.

## Benefits of multi-step functions

Creating functions that utilize multiple steps enable you to:

- Running retriable blocks of code to maximum reliability.
- Pausing execution and waiting for an event matching rules before continuing.
- Pausing for an amount of time or until a specified time.

This approach makes building reliable and distributed code simple. By wrapping asynchronous actions such as API calls in retriable blocks, we can ensure reliability when coordinating across many services.

## How to write a multi-step function

#### TypeScript

Consider this simple [Inngest function](/docs-markdown/learn/inngest-functions) which sends a welcome email when a user signs up:

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "my-app" });

export default inngest.createFunction(
  { id: "activation-email" },
  { event: "app/user.created" },
  async ({ event }) => {
    await sendEmail({ email: event.user.email, template: "welcome" });
  }
);
```

This function comes with all of the benefits of Inngest: the code is reliable and retriable. If an error happens, you will recover the data. This works for a single-task functions.

However, there is a new requirement: if a user hasn't created a post on our platform within 24 hours of signing up, we should send the user another email. Instead of adding more logic to the handler, we can convert this function into a multi-step one.

### 1. Convert to a step function

First, let's convert this function into a multi-step function:

- Add a `step` argument to the handler in the Inngest function.
- Wrap `sendEmail()` call in a [`step.run()`](/docs-markdown/reference/functions/step-run) method.

```ts
export default inngest.createFunction(
  { id: "activation-email" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    await step.run("send-welcome-email", async () => {
      return await sendEmail({ email: event.user.email, template: "welcome" });
    });
  }
);
```

The main difference is that we've wrapped our `sendEmail()` call in a `step.run()` call. This is how we tell Inngest that this is an individual step in our function. This step can be retried independently, just like a single-step function would.

### 2. Add another step: wait for event

Once the welcome email is sent, we want to wait at most 24 hours for our user to create a post. If they haven't created one by then, we want to send them a reminder email.

Elsewhere in our app, an `app/post.created` event is sent whenever a user creates a new post. We could use it to trigger the second email.

To do this, we can use the [`step.waitForEvent()`](/docs-markdown/reference/functions/step-wait-for-event) method. This tool will wait for a matching event to be fired, and then return the event data. If the event is not fired within the timeout, it will return `null`, which we can use to decide whether to send the reminder email.

```ts
export default inngest.createFunction(
  { id: "activation-email" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    await step.run("send-welcome-email", async () => {
      return await sendEmail({ email: event.user.email, template: "welcome" });
    });

    // Wait for an "app/post.created" event
    const postCreated = await step.waitForEvent("wait-for-post-creation", {
      event: "app/post.created",
      match: "data.user.id", // the field "data.user.id" must match
      timeout: "24h", // wait at most 24 hours
    });
  }
);
```

Now we have a `postCreated` variable, which will be `null` if the user hasn't created a post within 24 hours, or the event data if they have.

### 3. Set conditional action

Finally, we can use the `postCreated` variable to send the reminder email if the user hasn't created a post. Let's add another block of code with `step.run()`:

```ts
export default inngest.createFunction(
  { id: "activation-email" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    await step.run("send-welcome-email", async () => {
      return await sendEmail({ email: event.user.email, template: "welcome" });
    });

    // Wait for an "app/post.created" event
    const postCreated = await step.waitForEvent("wait-for-post-creation", {
      event: "app/post.created",
      match: "data.user.id", // the field "data.user.id" must match
      timeout: "24h", // wait at most 24 hours
    });

    if (!postCreated) {
      // If no post was created, send a reminder email
      await step.run("send-reminder-email", async () => {
        return await sendEmail({
          email: event.user.email,
          template: "reminder",
        });
      });
    }
  }
);
```

That's it! We've now written a multi-step function that will send a welcome email, and then send a reminder email if the user hasn't created a post within 24 hours.

Most importantly, we had to write no config to do this. We can use all the power of JavaScript to write our functions and all the power of Inngest's tools to coordinate between events and steps.

#### Go

Consider this simple [Inngest function](/docs-markdown/learn/inngest-functions) which sends a welcome email when a user signs up:

```go
import (
	"context"

	"github.com/inngest/inngestgo"
)

func sendActivationEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "activation-email",
		},
		inngestgo.EventTrigger("app/user.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			if err := sendEmail(input.Event.Data["user"].(map[string]interface{})["email"].(string), "welcome"); err != nil {
				return nil, err
			}
			return nil, nil
		},
	)
}
```

This function comes with all of the benefits of Inngest: the code is reliable and retriable. If an error happens, you will recover the data. This works for a single-task functions.

However, there is a new requirement: if a user hasn't created a post on our platform within 24 hours of signing up, we should send the user another email. Instead of adding more logic to the handler, we can convert this function into a multi-step one.

### 1. Convert to a step function

First, let's convert this function into a multi-step function:

- Add a `github.com/inngest/inngestgo/step` import
- Wrap `sendEmail()` call in a [`step.Run()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Run) method.

```go
import (
	"context"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func sendActivationEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "activation-email",
		},
		inngestgo.EventTrigger("app/user.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			_, err := step.Run(ctx, "send-welcome-email", func(ctx context.Context) (any, error) {
				return nil, sendEmail(input.Event.Data["user"].(map[string]interface{})["email"].(string), "welcome")
			})
			if err != nil {
				return nil, err
			}
			return nil, nil
		},
	)
}
```

The main difference is that we've wrapped our `sendEmail()` call in a `step.run()` call. This is how we tell Inngest that this is an individual step in our function. This step can be retried independently, just like a single-step function would.

### 2. Add another step: wait for event

Once the welcome email is sent, we want to wait at most 24 hours for our user to create a post. If they haven't created one by then, we want to send them a reminder email.

Elsewhere in our app, an `app/post.created` event is sent whenever a user creates a new post. We could use it to trigger the second email.

To do this, we can use the [`step.WaitForEvent()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#WaitForEvent) method. This tool will wait for a matching event to be fired, and then return the event data. If the event is not fired within the timeout, it will return `nil`, which we can use to decide whether to send the reminder email.

```go
import (
	"context"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func sendActivationEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "activation-email",
		},
		inngestgo.EventTrigger("app/user.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			_, err := step.Run(ctx, "send-welcome-email", func(ctx context.Context) (any, error) {
				return nil, sendEmail(input.Event.Data["user"].(map[string]interface{})["email"].(string), "welcome")
			})
			if err != nil {
				return nil, err
			}

			// Wait for an "app/post.created" event
			postCreated, err := step.WaitForEvent[map[string]any](
				ctx,
				"wait-for-post-creation",
				step.WaitForEventOpts{
					Event:   "app/post.created",
					If:      StringPtr(`async.data.user.id == event.data.user.id`), // the field "data.user.id" must match
					Timeout: 24 * time.Hour,                                        // wait at most 24 hours
				},
			)
			if err != nil {
				return nil, err
			}

			return postCreated, nil
		},
	)
}
```

Now we have a `postCreated` variable, which will be `nil` if the user hasn't created a post within 24 hours, or the event data if they have.

### 3. Set conditional action

Finally, we can use the `postCreated` variable to send the reminder email if the user hasn't created a post. Let's add another block of code with `step.Run()`:

```go
import (
	"context"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func sendActivationEmailInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "activation-email",
		},
		inngestgo.EventTrigger("app/user.created", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			// Send welcome email
			_, err := step.Run(ctx, "send-welcome-email", func(ctx context.Context) (any, error) {
				return nil, sendEmail(input.Event.Data["user"].(map[string]interface{})["email"].(string), "welcome")
			})
			if err != nil {
				return nil, err
			}

			// Wait for post creation event
			postCreated, err := step.WaitForEvent[map[string]any](
				ctx,
				"wait-for-post-creation",
				step.WaitForEventOpts{
					Event:   "app/post.created",
					If:      StringPtr(`async.data.user.id == event.data.user.id`), // the field "data.user.id" must match
					Timeout: 24 * time.Hour,                                        // wait at most 24 hours
				},
			)
			if err != nil {
				return nil, err
			}

			// If no post was created, send reminder email
			if postCreated == nil {
				_, err := step.Run(ctx, "send-reminder-email", func(ctx context.Context) (any, error) {
					return nil, sendEmail(input.Event.Data["user"].(map[string]interface{})["email"].(string), "reminder")
				})
				if err != nil {
					return nil, err
				}
			}

			return nil, nil
		},
	)
}
```

That's it! We've now written a multi-step function that will send a welcome email, and then send a reminder email if the user hasn't created a post within 24 hours.

Most importantly, we had to write no config to do this. We can use all the power of JavaScript to write our functions and all the power of Inngest's tools to coordinate between events and steps.

#### Python

Consider this simple [Inngest function](/docs-markdown/learn/inngest-functions) which sends a welcome email when a user signs up:

```py
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="activation-email",
    trigger=inngest.TriggerEvent(event="app/user.created"),
)
async def fn(ctx: inngest.Context) -> None:
    await sendEmail({ email: ctx.event.user.email, template: "welcome" })
```

This function comes with all of the benefits of Inngest: the code is reliable and retriable. If an error happens, you will recover the data. This works for a single-task functions.

However, there is a new requirement: if a user hasn't created a post on our platform within 24 hours of signing up, we should send the user another email. Instead of adding more logic to the handler, we can convert this function into a multi-step one.

### 1. Convert to a step function

First, let's convert this function into a multi-step function:

- Add a `step` argument to the handler in the Inngest function.
- Wrap `sendEmail()` call in a [`step.run()`](/docs-markdown/reference/python/steps/run) method.

```py
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="activation-email",
    trigger=inngest.TriggerEvent(event="app/user.created"),
)
async def fn(ctx: inngest.Context) -> None:
    await ctx.step.run("send-welcome-email", lambda: sendEmail({
        "email": ctx.event.user.email,
        "template": "welcome"
    }))
```

The main difference is that we've wrapped our `sendEmail()` call in a `step.run()` call. This is how we tell Inngest that this is an individual step in our function. This step can be retried independently, just like a single-step function would.

### 2. Add another step: wait for event

Once the welcome email is sent, we want to wait at most 24 hours for our user to create a post. If they haven't created one by then, we want to send them a reminder email.

Elsewhere in our app, an `app/post.created` event is sent whenever a user creates a new post. We could use it to trigger the second email.

To do this, we can use the [`step.wait_for_event()`](/docs-markdown/reference/python/steps/wait-for-event) method. This tool will wait for a matching event to be fired, and then return the event data. If the event is not fired within the timeout, it will return `None`, which we can use to decide whether to send the reminder email.

```py
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="activation-email",
    trigger=inngest.TriggerEvent(event="app/user.created"),
)
async def fn(ctx: inngest.Context) -> None:
    await ctx.step.run("send-welcome-email", lambda: sendEmail({
        "email": ctx.event.user.email,
        "template": "welcome"
    }))

    # Wait for an "app/post.created" event
    post_created = await ctx.step.wait_for_event("wait-for-post-creation", {
        "event": "app/post.created",
        "match": "data.user.id",  # the field "data.user.id" must match
        "timeout": "24h",  # wait at most 24 hours
    })
```

Now we have a `postCreated` variable, which will be `None` if the user hasn't created a post within 24 hours, or the event data if they have.

### 3. Set conditional action

Finally, we can use the `postCreated` variable to send the reminder email if the user hasn't created a post. Let's add another block of code with `step.run()`:

```py
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="activation-email",
    trigger=inngest.TriggerEvent(event="app/user.created"),
)
async def fn(ctx: inngest.Context) -> None:
    await ctx.step.run("send-welcome-email", lambda: sendEmail({
        "email": ctx.event.user.email,
        "template": "welcome"
    }))

    # Wait for an "app/post.created" event
    post_created = await ctx.step.wait_for_event("wait-for-post-creation", {
        "event": "app/post.created",
        "match": "data.user.id",  # the field "data.user.id" must match
        "timeout": "24h",  # wait at most 24 hours
    })

    if not post_created:
        # If no post was created, send a reminder email
        await ctx.step.run("send-reminder-email", lambda: sendEmail({
            "email": ctx.event.user.email,
            "template": "reminder"
        }))
```

That's it! We've now written a multi-step function that will send a welcome email, and then send a reminder email if the user hasn't created a post within 24 hours.

Most importantly, we had to write no config to do this. We can use all the power of JavaScript to write our functions and all the power of Inngest's tools to coordinate between events and steps.

## Step Reference

#### TypeScript

You can read more about [Inngest steps](/docs-markdown/learn/inngest-steps) or jump directly to a step reference guide:

- [`step.run()`](/docs-markdown/reference/functions/step-run): Run synchronous or asynchronous code as a retriable step in your function.
- [`step.sleep()`](/docs-markdown/reference/functions/step-sleep): Sleep for a given amount of time.
- [`step.sleepUntil()`](/docs-markdown/reference/functions/step-sleep-until): Sleep until a given time.
- [`step.invoke()`](/docs-markdown/reference/functions/step-invoke): Invoke another Inngest function as a step, receiving the result of the invoked function.
- [`step.waitForEvent()`](/docs-markdown/reference/functions/step-wait-for-event): Pause a function's execution until another event is received.
- [`step.sendEvent()`](/docs-markdown/reference/functions/step-send-event): Send event(s) reliably within your function. Use this instead of `inngest.send()` to ensure reliable event delivery from within functions.

> **Callout:** Please note that each step is executed as a separate HTTP request. To ensure efficient and correct execution, place any non-deterministic logic (such as DB calls or API calls) within a step.run() call. Learn more.

## Gotchas

### My function is running twice

Inngest will communicate with your function multiple times throughout a single run and will use your use of tools to intelligently memoize state.

For this reason, placing business logic outside of a `step.run()` call is a bad idea, as this will be run every time Inngest communicates with your function.

### I want to run asynchronous code

`step.run()` accepts an `async` function, like so:

```ts
await step.run("do-something", async () => {
  // your code
});
```

Each call to `step.run()` is a single retriable step - a lightweight transaction.  Therefore, each step should have a single side effect. For example, the below code is problematic:

```ts
await step.run("create-alert", async () => {
  const alertId = await createAlert();
  await sendAlertLinkToSlack(alertId);
});
```

If `createAlert()` succeeds but `sendAlertLinkToSlack()` fails, the code will be retried and an alert will be created every time the step is retried.

Instead, we should split out asynchronous actions into multiple steps so they're retried independently.

```ts
const alertId = await step.run("create-alert", () => createAlert());

await step.run("send-alert-link", () => sendAlertLinkToSlack(alertId));
```

### My variable isn't updating

Because Inngest communicates with your function multiple times, memoising state as it goes, code within calls to `step.run()` is not called on every invocation.

Make sure that any variables needed for the overall function are *returned* from calls to `step.run()`:

```ts
// This is the right way to set variables within step.run :)
const userId = await step.run("get-user", () => getRandomUserId());

console.log(userId); // 123
```

For comparison, here are **two examples of malfunctioning code** (if you're using steps to update variables within the function's closure):

```ts
// THIS IS WRONG! step.run() only runs once and is skipped for future
// steps, so userID will not be defined.
let userId;

// Do NOT do this! Instead, return data from step.run()
await step.run("get-user", async () => {
  userId = await getRandomUserId();
});

console.log(userId); // undefined
```

### `sleepUntil()` isn't working as expected

Make sure to only to use `sleepUntil()` with dates that will be static across the various calls to your function.

Always use `sleep()` if you'd like to wait a particular time from *now*.

```ts
// ‚ùå Bad
const tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);
await step.sleepUntil("wait-until-tomorrow", tomorrow);

// ‚úÖ Good
await step.sleep("wait-a-day", "1 day");
```

```ts
// ‚úÖ Good
const userBirthday = await step.run("get-user-birthday", async () => {
  const user = await getUser();
  return user.birthday; // Date
});

await sleepUntil("wait-for-user-birthday", userBirthday);
```

### Unexpected loop behavior

When using loops within functions, it is recommended to treat each iteration as it's own step or steps.

When [functions are run](/docs-markdown/learn/how-functions-are-executed), the function handler is re-executed from the start for each new step and previously completed steps are memoized. This means that iterations of loops will be run every re-execution, but code encapsulated within `step.run()` will not re-run.

If code within a loop is not encapsulated within a step, it will re-run multiple times, which can lead to confusing behavior, debugging, or [logging](/docs-markdown/guides/logging). This is why it is recommended to encapsulate non-deterministic code within a `step.run()` when working with loops.

Learn more about [working with loops in Inngest](/docs-markdown/guides/working-with-loops).

#### Go

You can read more about [Inngest steps](/docs-markdown/learn/inngest-steps) or jump directly to a step reference guide:

- [`step.Run()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Run): Run synchronous or asynchronous code as a retriable step in your function.
- [`step.Sleep()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Sleep): Sleep for a given amount of time.
- [`step.Invoke()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#Invoke): Invoke another Inngest function as a step, receiving the result of the invoked function.
- [`step.WaitForEvent()`](https://pkg.go.dev/github.com/inngest/inngestgo@v0.7.4/step#WaitForEvent): Pause a function's execution until another event is received.

> **Callout:** Please note that each step is executed as a separate HTTP request. To ensure efficient and correct execution, place any non-deterministic logic (such as DB calls or API calls) within a step.Run() call. Learn more.

## Gotchas

### My function is running twice

Inngest will communicate with your function multiple times throughout a single run and will use your use of tools to intelligently memoize state.

For this reason, placing business logic outside of a `step.Run()` call is a bad idea, as this will be run every time Inngest communicates with your function.

### Unexpected loop behavior

When using loops within functions, it is recommended to treat each iteration as it's own step or steps.

When [functions are run](/docs-markdown/learn/how-functions-are-executed), the function handler is re-executed from the start for each new step and previously completed steps are memoized. This means that iterations of loops will be run every re-execution, but code encapsulated within `step.Run()` will not re-run.

If code within a loop is not encapsulated within a step, it will re-run multiple times, which can lead to confusing behavior, debugging, or [logging](/docs-markdown/guides/logging). This is why it is recommended to encapsulate non-deterministic code within a `step.Run()` when working with loops.

Learn more about [working with loops in Inngest](/docs-markdown/guides/working-with-loops).

#### Python

You can read more about [Inngest steps](/docs-markdown/learn/inngest-steps) or jump directly to a step reference guide:

- [`step.run()`](/docs-markdown/reference/python/steps/run): Run synchronous or asynchronous code as a retriable step in your function.
- [`step.sleep()`](/docs-markdown/reference/python/steps/sleep): Sleep for a given amount of time.
- [`step.sleep_until()`](/docs-markdown/reference/python/steps/sleep-until): Sleep until a given time.
- [`step.invoke()`](/docs-markdown/reference/python/steps/invoke): Invoke another Inngest function as a step, receiving the result of the invoked function.
- [`step.wait_for_event()`](/docs-markdown/reference/python/steps/wait-for-event): Pause a function's execution until another event is received.
- [`step.send_event()`](/docs-markdown/reference/python/steps/send-event): Send event(s) reliably within your function. Use this instead of `inngest.send()` to ensure reliable event delivery from within functions.

> **Callout:** Please note that each step is executed as a separate HTTP request. To ensure efficient and correct execution, place any non-deterministic logic (such as DB calls or API calls) within a step.run() call. Learn more.

## Gotchas

### My function is running twice

Inngest will communicate with your function multiple times throughout a single run and will use your use of tools to intelligently memoize state.

For this reason, placing business logic outside of a `step.run()` call is a bad idea, as this will be run every time Inngest communicates with your function.

### `sleep_until()` isn't working as expected

Make sure to only to use `sleep_until()` with dates that will be static across the various calls to your function.

Always use `sleep()` if you'd like to wait a particular time from *now*.

```py
# ‚ùå Bad
tomorrow = datetime.now() + timedelta(days=1)
await ctx.step.sleepUntil("wait-until-tomorrow", tomorrow);

# ‚úÖ Good
await ctx.step.sleep("wait-a-day", "1 day");
```

```py
# ‚úÖ Good
user_birthday = await ctx.step.run("get-user-birthday", async () => {
  user = await get_user();
  return user.birthday; # Date
});

await ctx.step.sleep_until("wait-for-user-birthday", user_birthday);
```

### Unexpected loop behavior

When using loops within functions, it is recommended to treat each iteration as it's own step or steps.

When [functions are run](/docs-markdown/learn/how-functions-are-executed), the function handler is re-executed from the start for each new step and previously completed steps are memoized. This means that iterations of loops will be run every re-execution, but code encapsulated within `step.run()` will not re-run.

If code within a loop is not encapsulated within a step, it will re-run multiple times, which can lead to confusing behavior, debugging, or [logging](/docs-markdown/guides/logging). This is why it is recommended to encapsulate non-deterministic code within a `step.run()` when working with loops.

Learn more about [working with loops in Inngest](/docs-markdown/guides/working-with-loops).

## Further reading

More information on multi-step functions:

- Docs guide: [working with loops in Inngest](/docs-markdown/guides/working-with-loops).
- Blog post: ["Building an Event Driven Video Processing Workflow with Next.js, tRPC, and Inngest
  "](/blog/nextjs-trpc-inngest)
- Blog post: ["Running chained LLMs with TypeScript in production"](/blog/running-chained-llms-typescript-in-production)
- Blog post: [building Truckload](/blog/mux-migrating-video-collections), a tool for heavy video migration between hosting platforms, from Mux.
- Blog post: building *banger.show*'s [video rendering pipeline](/blog/banger-video-rendering-pipeline).
- [Email sequence examples](/docs-markdown/examples/email-sequence) implemented with Inngest.
- [Customer story: Soundcloud](/customers/soundcloud): building scalable video pipelines with Inngest to streamline dynamic video generation.


--------------------------------------------------------------------------------
title: "Multiple triggers & wildcards"
source: "https://www.inngest.com/docs/guides/multiple-triggers"
--------------------------------------------------------------------------------

# Multiple triggers & wildcards

Inngest functions can be configured to trigger on multiple events or schedules.

Using multiple triggers is useful for running the same logic for a wide array of events, or
ensuring something also runs on a schedule, for example running an integrity
check every morning, or when requested using an event.

Multiple triggers can be configured using an [list of triggers](#multiple-triggers), or [wildcard event triggers](#wildcard-event-triggers).

## Multiple triggers

Functions support up to 10 unique triggers. This allows you to explicitly match multiple events, or schedules. Multiple schedules that overlap will be de-duplicated - Learn more about [overlapping crons](#overlapping-crons).

```ts {{ title: "TypeScript" }}
inngest.createFunction(
  { id: "resync-user-data" },
  [
    { event: "user.created" },
    { event: "user.updated" },
    { cron: "0 5 * * *" }, // Every morning at 5am
  ],
  async ({ event, step }) => {
    // ...
  },
);
```

```go {{ title: "Go" }}
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{Name: "resync-user-data"},
	inngestgo.MultipleTriggers{
		inngestgo.EventTrigger("user.created", nil),
		inngestgo.EventTrigger("user.updated", nil),
		inngestgo.CronTrigger("0 5 * * *"),
	},
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// ...
		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest_client.create_function(
    fn_id="resync-user-data",
    trigger=[
        inngest.TriggerEvent(event="user.created"),
        inngest.TriggerEvent(event="user.updated"),
        inngest.TriggerCron(cron="0 5 * * *")
    ],
)
def my_handler(ctx: inngest.Context) -> None:
     # ...
```

## Wildcard event triggers

Event triggers can be configured using wildcards to match multiple events. This is useful for matching entire groups of events for cases like forwarding events to another system, like an real-time ETL.

Wildcards can be used after any `/` or `.` character to match entire groups of events. Here are some examples:

- `app/*` matches any event with the `app` prefix, like `app/user.created` and `app/blog.post.published`.
- `app/user.*` matches any event with the `app/user.` prefix, like `app/user.created` and `app/user.updated`.
- `app/blog.post.*` matches any event with the `app/blog.post.` prefix, like `app/blog.post.published`.

> **Info:** Wildcards cannot be used following any characters other than / and . or in the middle of a pattern, so mid-word wildcards like app/user.update\* and app/blog.\*.published are not supported.

### Defining types for wildcard triggers

To define types for wildcard triggers, you need to explicitly define

```ts
type WildcardEvents = {
  "app/blog.post.*": {
    name: "app/blog.post.created" | "app/blog.post.published";
    data: {
      postId: string;
      authorId: string;
      createdAt: string;
    } | {
      postId: string;
      authorId: string;
      publishedAt: string;
    }
  }
}
const inngest = new Inngest({
  id: "my-app",
  schemas: new EventSchemas().fromRecord<WildcardEvents>()
});

inngest.createFunction(
  { id: "blog-updates-to-slack" },
  { event: "app/blog.post.*" },
  async ({ event, step }) => {
    // ...
  },
);
```

## Determining event types

In the handler for a function with multiple triggers, the event that triggered
the function can be determined using the `event.name` property.

```ts {{ title: "TypeScript" }}
async ({ event }) => {
  //      ^? type event: EventA | EventB | InngestScheduledEvent | InngestFnInvoked
  if (event.name === "a") {
    // `event` is type narrowed to only the `a` event
  } else if (event.name === "b") {
    // `event` is type narrowed to only the `b` event
  } else {
    // `event` is type narrowed to only the `inngest/function.invoked` event
  }
}
```

```go {{ title: "Go" }}
func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
	switch input.Event.Name {
	case "a":
		// Handle event A
	case "b":
		// Handle event B
	case "inngest/function.invoked":
		// Handle function invoked event
	}
	return nil, nil
},
```

Note that batches of `events` can contain many different events; you will need
to assert the shape of each event in a batch individually.

## Overlapping crons

If your function defines multiple cron triggers, the schedules may sometimes overlap. For example, a cron `0 * * * *` that runs every hour and a cron `*/30 * * * *` that runs every half hour would overlap at the start of each hour.

Only one cron job will be run for each given second, so in this case above, one cron would run every half hour.


--------------------------------------------------------------------------------
title: "Function Pausing"
source: "https://www.inngest.com/docs/guides/pause-functions"
--------------------------------------------------------------------------------

# Function Pausing

Inngest allows you to pause a function indefinitely. This is a powerful feature that can be useful, for example, if you are planning a maintenance window or if a user reports a bug and you want to stop processing events until you've fixed it.

## When a function is paused

It's important to understand what happens when a function is paused.

**No data will be lost.** Inngest will continue receiving and storing your events, but the events will not trigger the paused function. The function will be marked as "skipped" on the event's page in Inngest Cloud.

**You can resume the function at any time.** No deployment or sync is required to resume your function. After you resume the function, new events will trigger it as usual.

**Events received while the function was paused will not be reprocessed automatically** after you resume the function. Use [Replay](/docs-markdown/platform/replay) to process events that were received while the function was paused.

**Paused functions do not count toward your plan's concurrency limit.** Note that events received while a function is paused are still subject to your plan's history limit.

## How to pause a function

Navigate to the function's dashboard in Inngest Cloud and select the "Pause" option in the "All actions" menu from a function's dashboard.

![The Pause option within the "All actions" menu on a function's dashboard.](/assets/docs-markdown/platform/function-dashboard-actions-2025-05-05.png)

### Handling running invocations

When you pause a function, no new events will trigger it. You can choose what to do with any currently-running invocations of the function:

- **"Pause immediately, then cancel after 7 days:"** No further steps will be executed while the function is paused. If you resume the function within 7 days, these invocations will continue with the next step. Otherwise, they will be canceled. (This is the default behavior.)
- **"Cancel immediately:"** All currently-running invocations of the function will be canceled. They will not continue running or restart when you resume the function.

In both cases, all running invocations will complete their current step before being paused or canceled. Inngest cannot interrupt your function mid-step.

![Options for handling running invocations when pausing a function.](/assets/docs-markdown/platform/pause/pause-modal-2025-05-05.png)

## Resuming a function

To resume a paused function, navigate to the function's page in Inngest Cloud and select the "Resume" option in the "All actions" menu from a function's dashboard.

![The Resume option within the "All actions" menu on a function's dashboard.](/assets/docs-markdown/platform/pause/resume-function-2025-05-05.png)

The function will immediately begin processing events received after you resume it.

## Replaying skipped events

After resuming a paused function, you may wish to replay the runs for that function that would otherwise have run while it was paused.  To do so:

1. Navigate to the function's dashboard
2. Select the "Replay" option in the "All actions" menu.
3. Select an appropriate date window and enable the "Skipped" status.
4. If you wish to replay runs that were canceled when you paused the function, select the "Canceled" status as well.

You'll see a preview of the number of runs to be replayed:

![Creating a replay for skipped function runs.](/assets/docs-markdown/platform/pause/replay-modal-2025-05-05.png)

Remember that your plan's history limit still applies to events received while a function is paused. This means that if, for example, you're using Inngest's free plan, you will only be able to replay events from the last 3 days, regardless of how long your function was paused.

See our [Replay guide](/docs-markdown/platform/replay) for more information.


--------------------------------------------------------------------------------
title: "Priority"
source: "https://www.inngest.com/docs/guides/priority"
--------------------------------------------------------------------------------

# Priority

Priority allows you to dynamically execute some runs ahead or behind others based on any data. This allows you to prioritize some jobs ahead of others without the need for a separate queue. Some use cases for priority include:

- Giving higher priority based on a user's subscription level, for example, free vs. paid users.
- Ensuring that critical work is executed before other work in the queue.
- Prioritizing certain jobs during onboarding to give the user a better first-run experience.

## How to configure priority

```ts
export default inngest.createFunction(
  {
    id: "ai-generate-summary",
    priority: {
      // For enterprise accounts, a given function run will be prioritized
      // ahead of functions that were enqueued up to 120 seconds ago.
      // For all other accounts, the function will run with no priority.
      run: "event.data.account_type == 'enterprise' ? 120 : 0",
    },
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
    // This function will be prioritized based on the account type
  }
);
```

```go {{ title: "Go" }}
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "ai-generate-summary",
		Priority: &inngest.ConfigPriority{
			Run: inngestgo.StrPtr("event.data.account_type == 'enterprise' ? 120 : 0"),
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// This function will be prioritized based on the account type
		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest.create_function(
  id="ai-generate-summary",
  priority=inngest.Priority(
    run="event.data.account_type == 'enterprise' ? 120 : 0",
  ),
  trigger=inngest.Trigger(event="ai/summary.requested")
)
async def ai_generate_summary(ctx: inngest.Context):
    # This function will be prioritized based on the account type
```

### Configuration reference

- `run` - A dynamic factor [expression](/docs-markdown/guides/writing-expressions), that evaluates to seconds, to prioritize the function by. Returning a positive number will increase that priority ahead of other jobs already in the queue. Returning a negative number will delay the function run's jobs by the given value in seconds.

## How priority works

Functions are scheduled in a priority queue based on the time they should run. By default, all functions are enqueued at the current time (a factor of `0`). If a function has `priority` configured, Inngest evaluates the `run` expression for each new function run based on the input event's data. The `run` expression should return a factor, in seconds, (positive or negative) to adjust the priority of the function run.

Expressions that return a **positive** number will **increase the priority** of the function run ahead of other jobs already in the queue by the given value in seconds. The function will be run ahead of other jobs that were enqueued up to that many seconds ago. For example, if a function run is scheduled with a factor of `120`, it will run ahead of any jobs enqueued in the last 120 seconds, given that they are still in the queue and have not completed.

Expressions that return a **negative** number will **delay** the function run by the given value in seconds.

### Practical example

Given we have three jobs in the queue, each which was enqueued at the following times:

```plaintext
Jobs:          [A,        B,        C       ]
Priority/Time: [12:00:10, 12:00:40, 12:02:10]
```

If the current time is `12:02:30`, and two new jobs are enqueued with the following `run` factors:

```plaintext
- Job X: factor 0
- Job Y: factor 120
```

Then Job Y will run ahead of Job X. Job Y will also run before any jobs scheduled 120 seconds beforehand. The queue will look like this:

```plaintext
Jobs:          [A,        Y,        B,        C,        X     ]
Priority/Time: [12:00:10, 12:00:30, 12:00:40, 12:02:10, 12:02:30]
                          ‚îÇ                             ‚îÇ
                          ‚îî 12:02:30 - 120s = 12:00:30  ‚îî 12:02:30 - 0s = 12:02:30
```

Job Y was successfully prioritized by a factor of `120` seconds ahead of other jobs in the queue.

## Combining with concurrency

Prioritization is most useful when combined with a flow control option that limits throughput, such as [concurrency](/docs-markdown/guides/concurrency). Jobs often wait in the queue when limiting throughput, so prioritization allows you to control the order in which jobs are executed in that backlog.

## Limitations

- The highest priority is `600` (seconds).
- The lowest priority is `-600` (seconds).
- Not compatible with [batching](/docs-markdown/guides/batching).

## Further reference

- [TypeScript SDK Reference](/docs-markdown/reference/functions/run-priority)
- [Python SDK Reference](/docs-markdown/reference/python/functions/create#configuration)


--------------------------------------------------------------------------------
title: "Rate limiting"
source: "https://www.inngest.com/docs/guides/rate-limiting"
--------------------------------------------------------------------------------

# Rate limiting

Rate limiting is a *hard limit* on how many function runs can start within a time period. Events that exceed the rate limit are *skipped* and do not trigger functions to start. This prevents excessive function runs over a given time period. Some use cases for rate limiting include:

- Preventing abuse of your system.
- Reducing frequency of data synchronization functions.
- Skipping noisy or duplicate [webhook](/docs-markdown/platform/webhooks) events.

## How to configure rate limiting

```ts {{ title: "TypeScript" }}
export default inngest.createFunction(
  {
    id: "synchronize-data",
    rateLimit: {
      limit: 1,
      period: "4h",
      key: "event.data.company_id",
    },
  },
  { event: "intercom/company.updated" },
  async ({ event, step }) => {
    // This function will be rate limited
    // It will only run once per 4 hours for a given event payload with matching company_id
  }
);
```

```go {{ title: "Go" }}
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "synchronize-data",
		RateLimit: &inngestgo.ConfigRateLimit{
			Limit:  1,
			Period: 4 * time.Hour,
			Key:    inngestgo.StrPtr("event.data.company_id"),
		},
	},
	inngestgo.EventTrigger("intercom/company.updated", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// This function will be rate limited to 1 run per 4 hours for a given event payload with matching company_id
		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest.create_function(
  id="synchronize-data",
  rate_limit=inngest.RateLimit(
    limit=1,
    period=datetime.timedelta(hours=4),
    key="event.data.company_id",
  ),
  trigger=inngest.Trigger(event="intercom/company.updated")
)
async def synchronize_data(ctx: inngest.Context):
    # This function will be rate limited to 1 run per 4 hours for a given event payload with matching company_id
```

### Configuration reference

- `limit` - The maximum number of functions to run in the given time period.
- `period` - The time period of which to set the limit. The period begins when the first matching event is received.
- `key` - An optional [expression](/docs-markdown/guides/writing-expressions) using event data to apply each limit too. Each unique value of the `key` has its own limit, enabling you to rate limit function runs by any particular key, like a user ID.

> **Callout:** Any events received in excess of your limit are ignored. This means this is not the right approach if you need to process every single event sent to Inngest. Consider using throttle instead.

## How rate limiting works

Each time an event is received that matches your function's trigger, it is evaluated prior to executing your function. If `rateLimit` is configured, Inngest uses the `limit` and `period` options to only execute a maximum number of functions during that period.

Inngest's rate limiting implementation uses the [‚ÄúGeneric Cell Rate Algorithm‚Äù](https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm) (GCRA). To *overly simplify* how this works, Inngest will use the `limit` and `period` options to create "buckets" of time in which your function can execute *once*.

```
limit / period = bucket time window
```

For example, this means that for a `limit: 10` and `period: '60m'` (60 minutes), the bucket time window will be 6 minutes. Any event triggering the function "fills up" the bucket for that time window and any additional events are ignored until the bucket's time window is reset. The algorithm (GCRA) is more sophisticated than this, but at the basic level - `rateLimit` ensures that you'll only run the max `limit` number of items over the `period` that you specify.

> **Callout:** Events that are ignored by the function will continue to be stored by Inngest.

**How the rate limit is applied with a consistent rate of events received**

**How the rate limit is applied with sporadic events received**

**How the rate limit is applied when limit is set to 1**

### Using a `key`

When a `key` is added, a separate limit is applied for each unique value of the `key` expression. For example, if your `key` is set to `event.data.customer_id`, each customer would have their individual rate limit applied to functions run meaning different users might have the same function run in same bucket time window, but two runs will not happen for the same `event.data.customer_id`. Read [our guide to writing expressions](/docs/guides/writing-expressions) for more information.

**Note** - To prevent duplicate events from triggering your function more than once in a 24 hour period, use [the `idempotency` option](/docs-markdown/guides/handling-idempotency#at-the-function-level-the-consumer) which is the equivalent to setting `rateLimit` with a `key`, a `limit` of `1`  and `period` of `24hr`.

## Limitations

- The maximum rate limit `period` is 24 hours.

## Further reference

- [Rate limiting vs Throttling](/docs-markdown/guides/throttling#throttling-vs-rate-limiting)
- [TypeScript SDK Reference](/docs-markdown/reference/functions/rate-limit)
- [Python SDK Reference](/docs-markdown/reference/python/functions/create#configuration)


--------------------------------------------------------------------------------
title: "Integrate email events with Resend webhooks"
source: "https://www.inngest.com/docs/guides/resend-webhook-events"
--------------------------------------------------------------------------------

# Integrate email events with Resend webhooks

[Resend webhooks](https://resend.com/docs/dashboard/webhooks/introduction) can be used to build functionality into your application based on changes in the email status. In this guide, you will learn:

- What webhook events are offered by Resend.
- How to set up Inngest to receive Resend webhook events.
- How to define Inngest functions in your application using Resend events.
- How to build a dynamic drip marketing campaign which responds to a user's behavior.

To follow this guide, you need a [Resend](https://resend.com/) and [Inngest](/) accounts and have Inngest [set up](/docs-markdown/getting-started/nextjs-quick-start) in your codebase.

## Resend webhooks

Resend uses webhooks to push real-time notifications to your application about the emails you're sending. It offers the following event types:

- `email.sent` - the API request was successful and Resend will attempt to deliver the message to the recipient's mail server.
- `email.bounced` - the recipient's mail server permanently rejected the email.
- `email.delivery_delayed` - the email couldn't be delivered to the recipient's mail server for example, because the recipient's inbox is full, or when the receiving email server experiences a transient issue.
- `email.delivered` - Resend successfully delivered the email to the recipient's mail server.
- `email.complained` - the recipient marked the delivered email as spam.
- `email.opened` - the recipient's opened the email.
- `email.clicked` - the recipient's clicked on an email link.

These events can be used to build responsive behavior based on changes in the email status. For example, you could use these events in scenarios such as:

- If an email bounced, remove the address from the mailing list or flag it in the database.
- Create a dynamic marketing drip campaign based on the recipient behavior.
- Build incident or retention report for your email campaigns.

### Building with Resend webhooks

You can manage webhook events directly in your backend through an endpoint or you could use a tool like [Inngest](/docs) which ensures reliable execution of functions in your codebase. Inngest comes with functionalities such as:

- a built-in queue to execute longer-running functions reliably
- [Controlling concurrency](/docs-markdown/guides/concurrency) to handle spikes without overwhelming your API or database.
- Executing multiple functions from a single event ([fan-out jobs](/docs-markdown/guides/fan-out-jobs)).
- Implementing [delayed code execution](/docs-markdown/guides/multi-step-functions) after a specified period.
- [Debouncing events](/docs-markdown/reference/functions/debounce) to minimize duplicate processing.

In short, using Inngest makes your application more resilient, scalable, and easier to recover from an incident.

## Receiving Resend webhook events in Inngest

Let's now connect Resend with Inngest.

1. Set up the Inngest webhook. To do so, in Inngest Cloud, navigate to **[Manage ‚Üí Webhooks](https://app.inngest.com/env/production/manage/webhooks)** page and click on **Create Webhook** button on the right.

![Inngest Cloud website on an the empty Webhooks page.](/assets/docs-markdown/guides/resend-webhook-events/inngest-1-no-webhooks.png)

1. In the modal window, specify the name of the webhook (for example, ‚ÄúResend‚Äù):

![Modal window with instruction: "Create a New Webhook". "Resend" is chosen as a name for the new webhook.](/assets/docs-markdown/guides/resend-webhook-events/inngest-2-new-webhook.png)

You will now see your webhook page with the webhook URL at the top:

![A webhook page on Inngest Cloud.](/assets/docs-markdown/guides/resend-webhook-events/inngest-3-webhook-page.png)

1. Paste the following [transform function](/docs-markdown/platform/webhooks#defining-a-transform-function) into the **Transform Event** area:

```jsx
function transform(evt, headers = {}, queryParams = {}) {
  return {
    // Add a prefix to the name of the event
    name: `resend/${evt.type}`,
    data: evt.data,
   };
};
```

The transform function will translate the incoming data to be compatible with the Inngest event payload format, as well as prefix all events with `resend/`.

Next, click **Save Transformed Changes** button to save this function.

![A webhook page on Inngest Cloud featuring Transform Event view.](/assets/docs-markdown/guides/resend-webhook-events/inngest-4-transform-function.png)

Your Inngest webhook is set up!

1. Go back to the top of the page and copy your webhook URL.

![Top of the webhook page on Inngest Cloud featuring the webhook URL](/assets/docs-markdown/guides/resend-webhook-events/inngest-4-screen-with-url.png)

1. Now navigate to the [webhooks](https://resend.com/webhooks) page in the Resend dashboard. Click on the **Add webhook** button:

![An empty webhook page on the Resend dashboard with a message: "You haven't configured any webhooks yet"](/assets/docs-markdown/guides/resend-webhook-events/resend-1-webhooks-empty-page.png)

1. In the modal, paste the Inngest webhook URL and choose which events you want to listen to -- tick all of them for now.

![A form in a modal window with a field to paste a webhook URL and a list of possible events to listen to.](/assets/docs-markdown/guides/resend-webhook-events/resend-2-webhooks-subscription.png)

Your webhook will be created but there will be no webhook events yet.

![The webhook page on the Resend dashboard now featuring one connected webhook. A message reads: "No webhook events yet"](/assets/docs-markdown/guides/resend-webhook-events/resend-3-no-webhook-events.png)

1. To see your webhook in action, [send a test email](https://resend.com/emails) and see the webhook events recorded:

![The webhook page on the Resend dashboard now featuring one connected webhook and two events.](/assets/docs-markdown/guides/resend-webhook-events/resend-5-webhook-details.png)

Your Resend webhook is set up ü•≥

1. Now check your Inngest dashboard to see the **[Events](https://app.inngest.com/env/production/events)** page in Inngest Cloud:

![Events tab in Inngest Cloud featuring two events from Resend](/assets/docs-markdown/guides/resend-webhook-events/inngest-5-event-screen.png)

Congratulations! Now you have Resend events coming into Inngest. Next, you will use the Resend events you've received in Inngest to trigger functions in your application's codebase.

## Writing your first Inngest function

*Please note that this example assumes that you are using TypeScript and Next.js, and that you have already added Inngest to your project, but if you're using Inngest for the first time, you can follow the [Quickstart guide](/docs-markdown/getting-started/nextjs-quick-start) to get it set up.*

With Inngest set up in your codebase, you can write a function that is triggered every time a specific event arrives. For example, if an email sent to an user bounces, you can mark the user's email invalid in your database:

```tsx
import db from "./database";

const invalidateUserEmail = inngest.createFunction(
  { id: 'invalidate-user-email' },
  { event: 'resend/email.bounced' },
  async ({ event }) => {
    const email = event.data.to[0];
    const user = await db.users.byEmail(email);
    if (user) {
      user.email_status = "invalid";
      await db.users.update(user);
    }
  }
)
```

Now that you've seen how to handle Resend events in your application, let's look at a more advanced example.

## Creating a function to send email

Suppose that you want want to send user a welcome email when they sign up to your application.

First, create a helper function called `sendEmail` by adapting the example from the [Resend Next.js Quickstart](https://resend.com/docs-markdown/send-with-nextjs):

```tsx
// resend.ts

import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY);

export async function sendEmail(
  to: string,
  subject: string,
  content: React.ReactElement
) {
  const { data, error } = await resend.emails.send({
    from: 'Acme <noreply@acme.dev>',
    to: [to],
    subject,
    react: content
  });

  if (error) {
    throw error;
  }

	return data;
};

```

Now you're able to send emails! Let's put this new function to use.

The below example assumes that your application receives a `app/signup.completed` event when a new user signs up:

```tsx

import { sendEmail } from "./resend";

const sendWelcomeEmail = inngest.createFunction(
  { id: 'send-welcome-email' },
  { event: 'app/signup.completed' },
  async ({ event }) => {
	  const { user } = event.data;
    await sendEmail(user.email, "Welcome to Acme", (
      <div>
        <h1>Welcome to ACME, {user.firstName}</h1>
      </div>
    ));
  }
)
```

Now that we've mastered the basics of sending email with Resend from an Inngest function, you can build even more complex functionality.

## Sending a delayed follow-up email

Every Inngest function handler comes with an additional [`step` object](/docs-markdown/reference/functions/step-sleep-until) which provides tools to create more fine-grained functions. Using `step.run` allows you to encapsulate specific code that will be automatically retried ensuring that issues with one part of your function don't force the entire function to re-run. Additionally, [other tools like `step.sleep`](/docs-markdown/reference/functions/step-sleep) are available to extend your app's functionality.

The code below sends a welcome email, then uses `step.sleep` to wait for three days before sending another email offering a free trial:

```tsx
const sendOnboardingEmails = inngest.createFunction(
  { id: 'onboarding-emails' },
  { event: 'app/signup.completed' },
  async ({ event, step }) => { // ‚Üê step is available in the handler's arguments
    const { user } = event.data
	  const { email, first_name } = user

    await step.run('welcome-email', async () => {
      await sendEmail(email, "Welcome to ACME", (
        <div>
          <h1>Welcome to ACME, {firstName}</h1>
        </div>
      ));
    })

   // wait 3 days before second email
   await step.sleep('wait-3-days', '3 days')

   await step.run('trial-offer-email', async () => {
     await sendEmail(email, "Free ACME Pro trial", (
        <div>
          <h1>Hello {firstName}, try our Pro features for 30 days for free</h1>
        </div>
      ));
    })
  }
)
```

This is handy, but we can do better. Since Resend sends you webhook events when emails are delivered, opened and clicked, you can build dynamic email campaigns tailored to each user's needs.

## Creating a dynamic drip campaign

Let's say you want to create the following campaign:

- Send every user a welcome email when they join.
- If a `resend/email.clicked` event is received (meaning the user has engaged with your email), wait a day and then follow-up with pro user tips meant for highly engaged users.
- Otherwise, wait for up to 3 days and then send them the default trial offer, but only if the user hasn't already upgraded their plan in the meantime.

```tsx
const signupDripCampaign = inngest.createFunction(
  { id: "signup-drip-campaign" },
  { event: "app/signup.completed" },
  async ({ event, step }) => {
    const { user } = event.data;
    const { email, first_name } = user
    const welcome = "Welcome to ACME";

    const { id: emailId } = await step.run("welcome-email", async () => {
      return await sendEmail(
        email,
        welcome,
        <div>
          <h1>Welcome to ACME, {user.firstName}</h1>
        </div>
      );
    });

    // Wait up to 3 days for the user open the email and click any link in it
    const clickEvent = await step.waitForEvent("wait-for-engagement", {
      event: "resend/email.clicked",
			if: `async.data.email_id == ${emailId}`,
      timeout: "3 days",
    });

    // if the user clicked the email, send them power user tips
    if (clickEvent) {
      await step.sleep("delay-power-tips-email", "1 day");
      await step.run("send-power-user-tips", async () => {
        await sendEmail(
          email,
          "Supercharge your ACME experience",
          <h1>
            Hello {firstName}, here are tips to get the most out of ACME
          </h1>
        );
      });

      // wait one more day before sending the trial offer
      await step.sleep("delay-trial-email", "1 day");
    }

    // check that the user is not already on the pro plan
    const dbUser = db.users.byEmail(email);

    if (dbUser.plan !== "pro") {
      // send them a free trial offer
      await step.run("trial-offer-email", async () => {
        await sendEmail(
          email,
          "Free ACME Pro trial",
          <h1>
            Hello {firstName}, try our Pro features for 30 days for free
          </h1>
        );
      });
    }
  }
);
```

Voil√†! You've created a dynamic marketing drip campaign where subsequent emails are informed by your user's behavior.

## Testing webhook events using the Inngest Dev Server

During local development with Inngest, you can use the Inngest Dev Server to run and test your functions on your own machine. To start the server, in your project directory run the following command:

```bash
npx --ignore-scripts=false inngest-cli@latest dev
```

In your browser open [http://localhost:8288](http://localhost:8288/) to see the development UI.

To forward and quickly test events from Inngest Cloud to your Dev Server, head over to [Inngest Cloud](https://app.inngest.com/env/production/events). Choose **Events** tab from the nav bar. Select any individual event, choose **Logs** from the sidebar, and then select the **Send to Dev Server**.

![Events tab in Inngest Cloud. The code area includes a button: "Send to the Dev Server"](/assets/docs-markdown/guides/resend-webhook-events/inngest-6-cloud-dev-server.png)

You'll now see the event in the Inngest Dev Server's **Stream** tab alongside any functions that it triggered.

![Stream tab in Inngest Dev Server featuring an event](/assets/docs-markdown/guides/resend-webhook-events/inngest-7-event-stream-1.png)

From here you can select the event, replay it to re-run any functions or edit and replay to edit the event payload to test different types of events.

![Details of a Resend event](/assets/docs-markdown/guides/resend-webhook-events/inngest-8-event-details.png)

## Conclusion

Congratulations! You've now learned how to use Inngest to create functions that use Resend webhook events.


--------------------------------------------------------------------------------
title: "Crons (Scheduled Functions)"
source: "https://www.inngest.com/docs/guides/scheduled-functions"
--------------------------------------------------------------------------------

# Crons (Scheduled Functions)

You can create scheduled jobs using cron schedules within Inngest natively.  Inngest's cron schedules also support timezones, allowing you to schedule work in whatever timezone you need work to run in.

#### TypeScript

You can create scheduled functions that run in any timezone using the SDK's [`createFunction()`](/docs-markdown/reference/functions/create):

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "signup-flow" });

// This weekly digest function will run at 12:00pm on Friday in the Paris timezone
export const prepareWeeklyDigest = inngest.createFunction(
  { id: "prepare-weekly-digest" },
  { cron: "TZ=Europe/Paris 0 12 * * 5" },
  async ({ step }) => {
    // Load all the users from your database:
    const users = await step.run(
      "load-users",
      async () => await db.load("SELECT * FROM users")
    );

    // üí° Since we want to send a weekly digest to each one of these users
    // it may take a long time to iterate through each user and send an email.

    // Instead, we'll use this scheduled function to send an event to Inngest
    // for each user then handle the actual sending of the email in a separate
    // function triggered by that event.

    // ‚ú® This is known as a "fan-out" pattern ‚ú®

    // 1Ô∏è‚É£ First, we'll create an event object for every user return in the query:
    const events = users.map((user) => {
      return {
        name: "app/send.weekly.digest",
        data: {
          user_id: user.id,
          email: user.email,
        },
      };
    });

    // 2Ô∏è‚É£ Now, we'll send all events in a single batch:
    await step.sendEvent("send-digest-events", events);

    // This function can now quickly finish and the rest of the logic will
    // be handled in the function below ‚¨áÔ∏è
  }
);

// This is a regular Inngest function that will send the actual email for
// every event that is received (see the above function's inngest.send())

// Since we are "fanning out" with events, these functions can all run in parallel
export const sendWeeklyDigest = inngest.createFunction(
  { id: "send-weekly-digest-email" },
  { event: "app/send.weekly.digest" },
  async ({ event }) => {
    // 3Ô∏è‚É£ We can now grab the email and user id from the event payload
    const { email, user_id } = event.data;

    // 4Ô∏è‚É£ Finally, we send the email itself:
    await email.send("weekly_digest", email, user_id);

    // üéá That's it! - We've used two functions to reliably perform a scheduled
    // task for a large list of users!
  }
);
```

#### Go

You can create scheduled functions that run in any timezone using the SDK's [`CreateFunction()`](https://pkg.go.dev/github.com/inngest/inngestgo#CreateFunction):

```go
package main

import (
	"context"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func init() {
	// This weekly digest function will run at 12:00pm on Friday in the Paris timezone
	inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{Name: "prepare-weekly-digest"},
		inngestgo.CronTrigger("TZ=Europe/Paris 0 12 * * 5"),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			// Load all the users from your database:
			users, err := step.Run(ctx, "load-users", func(ctx context.Context) ([]*User, error) {
				return loadUsers()
			})
			if err != nil {
				return nil, err
			}

			// üí° Since we want to send a weekly digest to each one of these users
			// it may take a long time to iterate through each user and send an email.

			// Instead, we'll use this scheduled function to send an event to Inngest
			// for each user then handle the actual sending of the email in a separate
			// function triggered by that event.

			// ‚ú® This is known as a "fan-out" pattern ‚ú®

			// 1Ô∏è‚É£ First, we'll create an event object for every user return in the query:
			events := make([]inngestgo.Event, len(users))
			for i, user := range users {
				events[i] = inngestgo.Event{
					Name: "app/send.weekly.digest",
					Data: map[string]interface{}{
						"user_id": user.ID,
						"email":   user.Email,
					},
				}
			}

			// 2Ô∏è‚É£ Now, we'll send all events in a single batch:
			err = step.SendMany(ctx, "send-digest-events", events)
			if err != nil {
				return nil, err
			}

			// This function can now quickly finish and the rest of the logic will
			// be handled in the function below ‚¨áÔ∏è
			return nil, nil
		},
	)

	// This is a regular Inngest function that will send the actual email for
	// every event that is received (see the above function's inngest.send())

	// Since we are "fanning out" with events, these functions can all run in parallel
	inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{Name: "send-weekly-digest-email"},
		inngestgo.EventTrigger("app/send.weekly.digest", nil),
		func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
			// 3Ô∏è‚É£ We can now grab the email and user id from the event payload
			email := input.Event.Data["email"].(string)
			userID := input.Event.Data["user_id"].(string)

			// 4Ô∏è‚É£ Finally, we send the email itself:
			err := email.Send("weekly_digest", email, userID)
			if err != nil {
				return nil, err
			}

			// üéá That's it! - We've used two functions to reliably perform a scheduled
			// task for a large list of users!
			return nil, nil
		},
	)
}
```

#### Python

You can create scheduled functions that run in any timezone using the SDK's [`create_function()`](/docs-markdown/reference/python/functions/create):

```py
from inngest import Inngest

inngest_client = Inngest(app_id="signup-flow")

# This weekly digest function will run at 12:00pm on Friday in the Paris timezone
@inngest_client.create_function(
    fn_id="prepare-weekly-digest",
    trigger=inngest.TriggerCron(cron="TZ=Europe/Paris 0 12 * * 5")
)
async def prepare_weekly_digest(ctx: inngest.Context) -> None:
    # Load all the users from your database:
    users = await ctx.step.run(
        "load-users",
        lambda: db.load("SELECT * FROM users")
    )

    # üí° Since we want to send a weekly digest to each one of these users
    # it may take a long time to iterate through each user and send an email.

    # Instead, we'll use this scheduled function to send an event to Inngest
    # for each user then handle the actual sending of the email in a separate
    # function triggered by that event.

    # ‚ú® This is known as a "fan-out" pattern ‚ú®

    # 1Ô∏è‚É£ First, we'll create an event object for every user return in the query:
    events = [
        {
            "name": "app/send.weekly.digest",
            "data": {
                "user_id": user.id,
                "email": user.email,
            }
        }
        for user in users
    ]

    # 2Ô∏è‚É£ Now, we'll send all events in a single batch:
    await ctx.step.send_event("send-digest-events", events)

    # This function can now quickly finish and the rest of the logic will
    # be handled in the function below ‚¨áÔ∏è

# This is a regular Inngest function that will send the actual email for
# every event that is received (see the above function's inngest.send())

# Since we are "fanning out" with events, these functions can all run in parallel
@inngest_client.create_function(
    fn_id="send-weekly-digest-email",
    trigger=inngest.TriggerEvent(event="app/send.weekly.digest")
)
async def send_weekly_digest(ctx: inngest.Context) -> None:
    # 3Ô∏è‚É£ We can now grab the email and user id from the event payload
    email = ctx.event.data["email"]
    user_id = ctx.event.data["user_id"]

    # 4Ô∏è‚É£ Finally, we send the email itself:
    await email.send("weekly_digest", email, user_id)

    # üéá That's it! - We've used two functions to reliably perform a scheduled
    # task for a large list of users!
```

> **Callout:** üëâ Note: You'll need to serve these functions in your Inngest API for the functions to be available to Inngest.

On the free plan, if your function fails 20 times consecutively it will automatically be paused.


--------------------------------------------------------------------------------
title: "Sending events from functions"
source: "https://www.inngest.com/docs/guides/sending-events-from-functions"
--------------------------------------------------------------------------------

# Sending events from functions

In some workflows or pipeline functions, you may want to broadcast events from within your function to trigger *other* functions. This pattern is useful when:

- You want to decouple logic into separate functions that can be re-used across your system
- You want to send an event to [fan-out](/docs-markdown/guides/fan-out-jobs) to multiple other functions
- Your function is handling many items that you want to process in parallel functions
- You want to [cancel](/docs-markdown/guides/cancel-running-functions) another function
- You want to send data to another function [waiting for an event](/docs-markdown/reference/functions/step-wait-for-event)

If your function needs to handle the result of another function, or wait until that other function has completed, you should use [direct function invocation](/docs-markdown/guides/invoking-functions-directly) instead.

## How to send events from functions

#### TypeScript

To send events from within functions, you will use [`step.sendEvent()`](/docs-markdown/reference/functions/step-send-event). This method takes a single event, or an array of events. The example below uses an array of events.

This is an example of a [scheduled function](/docs-markdown/guides/scheduled-functions) that sends a weekly activity email to all users.

First, the function fetches all users, then it maps over all users to create a `"app/weekly-email-activity.send"` event for each user, and finally it sends all events to Inngest.

```ts
import { GetEvents, Inngest } from "inngest";

const inngest = new Inngest({ id: "signup-flow" });
type Events = GetEvents<typeof inngest>;

export const loadCron = inngest.createFunction(
  { id: "weekly-activity-load-users" },
  { cron: "0 12 * * 5" },
  async ({ event, step }) => {
    // Fetch all users
    const users = await step.run("fetch-users", async () => {
      return fetchUsers();
    });

    // For each user, send us an event.  Inngest supports batches of events
    // as long as the entire payload is less than 512KB.
    const events = users.map<Events["app/weekly-email-activity.send"]>(
      (user) => {
        return {
          name: "app/weekly-email-activity.send",
          data: {
            ...user,
          },
          user,
        };
      }
    );

    // Send all events to Inngest, which triggers any functions listening to
    // the given event names.
    await step.sendEvent("fan-out-weekly-emails", events);

    // Return the number of users triggered.
    return { count: users.length };
  }
);
```

Next, create a function that listens for the `"app/weekly-email-activity.send"` event. This function will be triggered for each user that was sent an event in the previous function.

```ts
export const sendReminder = inngest.createFunction(
  { id: "weekly-activity-send-email" },
  { event: "app/weekly-email-activity.send" },
  async ({ event, step }) => {
    const data = await step.run("load-user-data", async () => {
      return loadUserData(event.data.user.id);
    });

    await step.run("email-user", async () => {
      return sendEmail(event.data.user, data);
    });
  }
);
```

Each of these functions will run in parallel and individually retry on error, resulting in a faster, more reliable system.

> **Callout:** üí° Tip: When triggering lots of functions to run in parallel, you will likely want to configure concurrency limits to prevent overloading your system. See our concurrency guide for more information.

### Why `step.sendEvent()` vs. `inngest.send()`?

By using [`step.sendEvent()`](/docs-markdown/reference/functions/step-send-event) Inngest's SDK can automatically add context and tracing which ties events to the current function run. If you use [`inngest.send()`](/docs-markdown/reference/events/send), the context around the function run is not present.

#### Go

To send events from within functions, you  will use [`step.Send()`](https://pkg.go.dev/github.com/inngest/inngestgo/step#Send) or [`step.SendMany()`](https://pkg.go.dev/github.com/inngest/inngestgo/step#SendMany)

This is an example of a [scheduled function](/docs-markdown/guides/scheduled-functions) that sends a weekly activity email to all users.

First, the function fetches all users, then it maps over all users to create a `"app/weekly-email-activity.send"` event for each user, and finally it sends all events to Inngest.

```go
import (
	"context"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadCronInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "weekly-activity-load-users",
		},
		inngestgo.CronTrigger("0 12 * * 5"),
		func(ctx context.Context, input inngestgo.Input[any]) (any, error) {
			// Fetch all users
			users, err := step.Run(ctx, "fetch-users", func(ctx context.Context) ([]User, error) {
				return fetchUsers()
			})
			if err != nil {
				return nil, err
			}

			// For each user, send us an event. Inngest supports batches of events
			// as long as the entire payload is less than 512KB.
			events := make([]inngestgo.Event, len(users))
			for i, user := range users {
				events[i] = inngestgo.Event{
					Name: "app/weekly-email-activity.send",
					Data: map[string]interface{}{
						"user": user,
					},
				}
			}

			// Send all events to Inngest, which triggers any functions listening to
			// the given event names.
			_, err = step.SendMany(ctx, "send-events", events)
			if err != nil {
				return nil, err
			}

			// Return the number of users triggered
			return map[string]any{
				"count": len(users),
			}, nil
		},
	)
}
```

Next, create a function that listens for the `"app/weekly-email-activity.send"` event. This function will be triggered for each user that was sent an event in the previous function.

```go
import (
	"context"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

type User struct {
	ID string
}

type Data struct {
	User User
}

func loadSendReminderInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID: "weekly-activity-send-email",
		},
		inngestgo.EventTrigger("app/weekly-email-activity.send", nil),
		func(ctx context.Context, input inngestgo.Input[Data]) (any, error) {
			data, err := step.Run(ctx, "load-user-data", func(ctx context.Context) (any, error) {
				return loadUserData(input.Event.Data.User.ID)
			})
			if err != nil {
				return nil, err
			}

			_, err = step.Run(ctx, "email-user", func(ctx context.Context) (any, error) {
				return SendEmail(SendEmailInput{
					To:      input.Event.Data.User.ID,
					Subject: "Welcome to Inngest!",
					Message: GenerateWelcomeEmailForUser(data),
				})
			})
			if err != nil {
				return nil, err
			}

			return nil, nil
		},
	)
}
```

Each of these functions will run in parallel and individually retry on error, resulting in a faster, more reliable system.

> **Callout:** üí° Tip: When triggering lots of functions to run in parallel, you will likely want to configure concurrency limits to prevent overloading your system. See our concurrency guide for more information.

#### Python

To send events from within functions, you will use [`step.send_event()`](/docs-markdown/reference/python/steps/send-event). This method takes a single event, or an array of events. The example below uses an array of events.

This is an example of a [scheduled function](/docs-markdown/guides/scheduled-functions) that sends a weekly activity email to all users.

First, the function fetches all users, then it maps over all users to create a `"app/weekly-email-activity.send"` event for each user, and finally it sends all events to Inngest.

```py
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="weekly-activity-load-users",
    trigger=inngest.TriggerCron(cron="0 12 * * 5")
)
async def load_cron(ctx: inngest.Context):
    # Fetch all users
    async def fetch():
        return await fetch_users()
    
    users = await ctx.step.run("fetch-users", fetch)

    # For each user, send us an event. Inngest supports batches of events
    # as long as the entire payload is less than 512KB.
    events = []
    for user in users:
        events.append(
            inngest.Event(
                name="app/weekly-email-activity.send",
                data={
                    **user,
                    "user": user
                }
            )
        )

    # Send all events to Inngest, which triggers any functions listening to
    # the given event names.
    await ctx.step.send_event("fan-out-weekly-emails", events)

    # Return the number of users triggered.
    return {"count": len(users)}
```

Next, create a function that listens for the `"app/weekly-email-activity.send"` event. This function will be triggered for each user that was sent an event in the previous function.

```py
@inngest_client.create_function(
    fn_id="weekly-activity-send-email",
    trigger=inngest.TriggerEvent(event="app/weekly-email-activity.send")
)
async def send_reminder(ctx: inngest.Context):
    async def load_data():
        return await load_user_data(ctx.event.data["user"]["id"])
    
    data = await ctx.step.run("load-user-data", load_data)

    async def send():
        return await send_email(ctx.event.data["user"], data)
    
    await ctx.step.run("email-user", send)
```

Each of these functions will run in parallel and individually retry on error, resulting in a faster, more reliable system.

> **Callout:** üí° Tip: When triggering lots of functions to run in parallel, you will likely want to configure concurrency limits to prevent overloading your system. See our concurrency guide for more information.

### Why `step.send_event()` vs. `inngest.send()`?

By using [`step.send_event()`](/docs-markdown/reference/python/steps/send-event) Inngest's SDK can automatically add context and tracing which ties events to the current function run. If you use [`inngest.send()`](/docs-markdown/reference/python/client/send), the context around the function run is not present.

## Parallel functions vs. parallel steps

Another technique similar is running multiple steps in parallel (read the [step parallelism guide](/docs-markdown/guides/step-parallelism)). Here are the key differences:

- Both patterns run code in parallel
- With parallel steps, you can access the output of each step, whereas with the above example, you cannot
- Parallel steps have limit of 1,000 steps, though you can trigger as many functions as you'd like using the send event pattern
- Decoupled functions can be tested and [replayed](/docs-markdown/platform/replay) separately, whereas parallel steps can only be tested as a whole
- You can retry individual functions easily if they permanently fail, whereas if a step permanently fails (after retrying) the function itself will fail and terminate.

## Sending events vs. invoking

A related pattern is invoking external functions directly instead of just triggering them with an event. See the [Invoking functions directly](/docs-markdown/guides/invoking-functions-directly) guide. Here are some key differences:

- Sending events from functions is better suited for parallel processing of independent tasks and invocation is better for coordinated, interdependent functions
- Sending events can be done in bulk, whereas invoke can only invoke one function at a time.
- Sending events can be combined with [fan-out](/docs-markdown/guides/fan-out-jobs) to trigger multiple functions from a single event
- Unlike invocation, sending events will not receive the result of the invoked function


--------------------------------------------------------------------------------
title: "Singleton Functions  &#x20;"
source: "https://www.inngest.com/docs/guides/singleton"
--------------------------------------------------------------------------------

# Singleton Functions  &#x20;

Singleton Functions enable you to ensure that only a single run of your function (*or a set of specific function runs, based on specific event properties*) is happening at a time.

> **Callout:** Singleton Functions are available in the TypeScript SDK starting from version 3.39.0.

## When to use Singleton Functions

Singleton Functions are useful when you want to ensure that only a single instance of a function is running at a time, for example:

- A third-party data synchronization workflow
- A compute- or time-intensive function that should not be run multiple times at the same time (ex: AI processing)

### Singleton compared to concurrency:

While [Concurrency](/docs-markdown/guides/concurrency) set to `1` ensures that only a single step of a given function is running at a time, Singleton Functions ensure that only a single run of a given function is happening at a time.

### Singleton compared to Rate Limiting:

[Rate Limiting](/docs-markdown/guides/rate-limiting) is similar to Singleton Functions, but it is designed to limit the number of runs started within a time period, whereas Singleton Functions are designed to ensure that only a single run of a function occurs over a given time window.

Rate Limiting is useful for controlling the rate of execution of a function, while Singleton Functions are useful for ensuring that only a single run of a function occurs over a given time window.

## How it works

Singleton Functions are configured using the `singleton` property in the function definition.

The following `data-sync` function demonstrates singleton behavior scoped to individual users. Depending on the `mode`, new runs will either be skipped or will cancel the existing run:

```ts
const dataSync = inngest.createFunction({
    id: "data-sync",
    singleton: {
      key: "event.data.user_id",
      mode: "skip",
    }  
  },
  { event: "data-sync.start" },
  async ({ event }) => {
    // ...
  },
);
```

Refer to the [reference documentation](/docs-markdown/reference/functions/singleton) for more details.

### Using a `key`

When a `key` is added, the unique runs rule is applied for each unique value of the `key` expression. For example, if your `key` is set to `event.data.user_id`,
each user would have their individual singleton rule applied to functions runs, ensuring that only a single run of the function is happening at a time for each user. Read [our guide to writing expressions](/docs-markdown/guides/writing-expressions) for more information.

### Two modes: Skip vs Cancel

Singleton Functions can be configured to either skip the new run or cancel the existing run and start a new one.

The `mode` property configures the behavior of the Singleton Function:

- `"skip"` - Skips the new run if another run is already executing.
- `"cancel"` - Cancels the existing run and starts the new one.

> **Callout:** Cancel mode behavior: Triggering multiple function runs with the same key in very rapid succession may result in some runs being skipped rather than cancelled, similar to a debounce effect. This prevents excessive cancellation overhead when events are triggered in quick bursts.

#### When should I use "cancel" mode vs "skip" mode?

Use `"skip"` mode when you want to prevent duplicate work and preserve the currently running function. Use `"cancel"` mode when you want to ensure the most recent event is always processed, even if it means cancelling an in-progress run.

```ts {{ title: "Skip mode" }}
const dataSync = inngest.createFunction({
    id: "data-sync",
    singleton: {
      key: "event.data.user_id",
      mode: "skip",
    }  
  },
  { event: "data-sync.start" },
  async ({ event }) => {
    const userId = event.data.user_id;
    
    // This long-running sync process will not be interrupted
    // If another sync is triggered for this user, it will be skipped
    const data = await syncUserDataFromExternalAPI(userId);
    const processed = await processLargeDataset(data);
    await updateDatabase(processed);
  },
);
```

```ts {{ title: "Cancel mode" }}
const latestDataSync = inngest.createFunction({
    id: "latest-data-sync",
    singleton: {
      key: "event.data.user_id",
      mode: "cancel",
    }  
  },
  { event: "data-sync.start" },
  async ({ event }) => {
    const userId = event.data.user_id;
    
    // If a newer sync is triggered, this run will be cancelled
    // ensuring only the most recent data is processed
    const payload = await fetchLatestUserData(userId);
    await applyRealTimeUpdates(payload);
  },
);
```

## Compatibility with other flow control features

Singleton Functions can be combined with other flow control features, with the following considerations:

| Flow control                                         | Compatibility | Considerations                                                                                                            |
| ---------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------- |
| [Debounce](/docs-markdown/guides/debounce)           | ‚úÖ             | Can be used together without issues.                                                                                      |
| [Rate limiting](/docs-markdown/guides/rate-limiting) | ‚úÖ             | Similar functionality but rate limiting operates over a predefined time window rather than function execution duration.   |
| [Throttling](/docs-markdown/guides/throttling)       | ‚úÖ             | Similar functionality but throttling enqueues events over time rather than discarding/canceling them.                     |
| [Concurrency](/docs-markdown/guides/concurrency)     | ‚ùå             | Singleton functions implicitly have a concurrency of 1. A concurrency setting can be set but should be used with caution. |
| [Batching](/docs-markdown/guides/batching)           | ‚ùå             | Singleton isn't compatible with batching; function registration will fail if both are set.                                |

## FAQ

### How does Singleton Functions work with retries?

If a singleton function fails and is retrying, it should still skip new incoming runs.


--------------------------------------------------------------------------------
title: "Step parallelism"
source: "https://www.inngest.com/docs/guides/step-parallelism"
--------------------------------------------------------------------------------

# Step parallelism

- If you‚Äôre using a serverless platform to host, code will run in true parallelism similar to multi-threading (without shared state)
- Each step will be individually retried

### Platform support

**Parallelism works across all providers and platforms**.  True parallelism is supported for serverless functions;  if you‚Äôre using a single Express server you‚Äôll be splitting all parallel jobs amongst a single-threaded node server.

## Running steps in parallel

You can run steps in parallel via `Promise.all()`:

- Create each step via [`step.run()`](/docs-markdown/reference/functions/step-run) without awaiting, which returns an unresolved promise.
- Await all steps via `Promise.all()`. This triggers all steps to run in parallel via separate executions.

A common use case is to split work into chunks:

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "signup-flow" });

export const fn = inngest.createFunction(
  { id: "post-payment-flow" },
  { event: "stripe/charge.created" },
  async ({ event, step }) => {
    // These steps are not `awaited` and run in parallel when Promise.all
    // is invoked.
    const sendEmail = step.run("confirmation-email", async () => {
      const emailID = await sendEmail(event.data.email);
      return emailID;
    });

    const updateUser = step.run("update-user", async () => {
      return db.updateUserWithCharge(event);
    });

    // Run both steps in parallel.  Once complete, Promise.all will return all
    // parallelized state here.
    //
    // This ensures that all steps complete as fast as possible, and we still have
    // access to each step's data once they're complete.
    const [emailID, updates] = await Promise.all([sendEmail, updateUser]);

    return { emailID, updates };
  }
);
```

When each step is finished, Inngest will aggregate each step's state and re-invoke the function with all state available.

### Step parallelism in Python

Inngest supports parallel steps regardless of whether you're using asynchronous or synchronous code. For both approaches, you can use `step.parallel`:

#### async - with `inngest.Step` and `await ctx.group.parallel()`

```py
@client.create_function(
  fn_id="my-fn",
  trigger=inngest.TriggerEvent(event="my-event"),
)
async def fn(ctx: inngest.Context) -> None:
  user_id = ctx.event.data["user_id"]

  (updated_user, sent_email) = await ctx.group.parallel(
    (
      lambda: step.run("update-user", update_user, user_id),
      lambda: step.run("send-email", send_email, user_id),
    )
  )
```

#### sync - with `inngest.StepSync` and `group.parallel()`

```py
@client.create_function(
  fn_id="my-fn",
  trigger=inngest.TriggerEvent(event="my-event"),
)
def fn(ctx: inngest.ContextSync) -> None:
  user_id = ctx.event.data["user_id"]

  (updated_user, sent_email) = ctx.group.parallel(
    (
      lambda: ctx.step.run("update-user", update_user, user_id),
      lambda: ctx.step.run("send-email", send_email, user_id),
    )
  )
```

## Optimizing parallel step performance

By default, parallel steps require 2 requests per step to your application. If you have many parallel steps (e.g., hundreds), this can lead to:

- High number of HTTP requests to your application
- Increased ingress bandwidth
- Higher CPU usage from request parsing

The `optimizeParallelism` feature reduces this to just 1 request per parallel step, significantly improving performance for functions with many parallel operations.

### TypeScript: Opt-in via function configuration

In TypeScript, you can enable optimized parallelism by adding `optimizeParallelism: true` to your function configuration:

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "my-app" });

export const fn = inngest.createFunction(
  { 
    id: "process-batch",
    optimizeParallelism: true  // Enable optimized parallelism
  },
  { event: "batch/process" },
  async ({ event, step }) => {
    // These parallel steps will now use only 1 request each instead of 2
    const results = await Promise.all(
      event.data.items.map((item, i) =>
        step.run(`process-${i}`, () => processItem(item))
      )
    );
    
    return results;
  }
);
```

**Important considerations:**

- **`Promise.race` behavior**: When using optimized parallelism, `Promise.race` will wait for all parallel steps to complete before returning the first result. This differs from the standard JavaScript behavior where it returns immediately when the first promise resolves. A future `group.race()` API may address this.

- **Sequential steps in parallel groups**: Steps that run sequentially within different parallel branches may not execute in the order you expect. For example:

```ts
const stepOrder: string[] = [];

export const fn = inngest.createFunction(
  { id: "fn-1", optimizeParallelism: true },
  { event: "event-1" },
  async ({ step }) => {
    await Promise.all([
      (async () => {
        await step.run("fast.1", async () => {
          stepOrder.push("fast.1");
        });
        await step.run("fast.2", async () => {
          stepOrder.push("fast.2");
        });
      })(),
      (async () => {
        await step.run("slow.1", async () => {
          await sleep(1000);
          stepOrder.push("slow.1");
        });
        await step.run("slow.2", async () => {
          await sleep(1000);
          stepOrder.push("slow.2");
        });
      })(),
    ]);

    // With optimizeParallelism: ['fast.1', 'slow.1', 'fast.2', 'slow.2']
    // Without optimizeParallelism: ['fast.1', 'fast.2', 'slow.1', 'slow.2']
  }
);
```

### Python: Optimized by default with opt-out

Python always uses optimized parallelism by default, as it doesn't have an equivalent to `Promise.race` to worry about. However, you can opt out at the group level if you need sequential steps within parallel groups to run independently.

Use the `parallel_mode` parameter to control this behavior:

```py
import inngest
import asyncio

@inngest_client.create_function(
    fn_id="my-fn",
    trigger=inngest.TriggerEvent(event="my-event"),
)
async def fn(ctx: inngest.Context) -> None:
    async def fast_group() -> None:
        await ctx.step.run("a", lambda: asyncio.sleep(1))
        await ctx.step.run("b", lambda: asyncio.sleep(1))

    async def slow_group() -> None:
        await ctx.step.run("x", lambda: asyncio.sleep(10))
        await ctx.step.run("y", lambda: asyncio.sleep(10))

    # Using RACE mode makes steps run in expected order: a, b, x, y
    await ctx.group.parallel(
        (fast_group, slow_group), 
        parallel_mode=inngest.ParallelMode.RACE
    )
```

**Without specifying `parallel_mode`**, the steps will run in the order: `a`, `x`, `b`, `y` (optimized mode). Everything is still correct, but step `b` doesn't run until step `x` completes.

**With `parallel_mode=inngest.ParallelMode.RACE`**, the steps run in the expected order: `a`, `b`, `x`, `y`, but with the performance trade-off of more requests.

## Chunking jobs

A common use case is to chunk work. For example, when using OpenAI's APIs you might need to chunk a user's input and run the API on many chunks, then aggregate all data:

```ts
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "signup-flow" });

export const fn = inngest.createFunction(
  { id: "summarize-text" },
  { event: "app/text.summarize" },
  async ({ event, step }) => {
    const chunks = splitTextIntoChunks(event.data.text);

    const summaries = await Promise.all(
      chunks.map((chunk, index) =>
        step.run(`summarize-chunk-${index}`, () => summarizeChunk(chunk))
      )
    );

    await step.run("summarize-summaries", () => summarizeSummaries(summaries));
  }
);
```

This allows you to run many independent steps, wait until they're all finished, then fetch the results from all steps within a few lines of code. Doing this in a traditional system would require creating many jobs, polling the status of all jobs, and manually combining state.

## Limitations

Currently, the total data returned from **all** steps must be under 4MB (eg. a single step can return a max of. 4MB, or 4 steps can return a max of 1MB each).  Functions are also limited to a maximum of 1,000 steps.

## Parallelism vs fan-out

Another technique similar to parallelism is fan-out ([read the guide here](/docs-markdown/guides/fan-out-jobs)):  when one function sends events to trigger other functions.  Here are the key differences:

- Both patterns run jobs in parallel
- You can access the output of steps ran in parallel within your function, whereas with fan-out you cannot
- Parallelism has a limit of 1,000 steps, though you can create as many functions as you'd like using fan-out
- You can replay events via fan-out, eg. to test functions locally
- You can retry individual functions easily if they permanently fail, whereas if a step permanently fails (after retrying) the function itself will fail and terminate.
- Fan-out splits functionality into different functions, using step functions keeps all related logic in a single, easy to read function


--------------------------------------------------------------------------------
title: "Throttling"
source: "https://www.inngest.com/docs/guides/throttling"
--------------------------------------------------------------------------------

# Throttling

Throttling allows you to specify how many function runs can start within a time period. When the limit is reached, new function runs over the throttling limit will be *enqueued for the future*. Throttling is FIFO (first in first out). Some use cases for throttling include:

- Evenly distributing function execution over time to reduce spikes.
- Working around third-party API rate limits.

## How to configure throttling

```ts {{ title: "TypeScript" }}
inngest.createFunction(
  {
    id: "unique-function-id",
    throttle: {
      limit: 1,
      period: "5s",
      burst: 2,
      key: "event.data.user_id",
    },
  }
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
  }
);
```

```go {{ title: "Go" }}
inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "unique-function-id",
		Throttle: &inngestgo.ConfigThrottle{
			Limit:  1,
			Period: 5 * time.Second,
			Key:    inngestgo.StrPtr("event.data.user_id"),
			Burst:  2,
		},
	},
	inngestgo.EventTrigger("ai/summary.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// This function will be throttled to 1 run per 5 seconds for a given event payload with matching user_id,
		// while the one-time burst allows 2 extra runs to start within 5 seconds, after which no more runs are accepted for 5 seconds.
		return nil, nil
	},
)
```

```py {{ title: "Python" }}
@inngest.create_function(
  id="unique-function-id",
  throttle=inngest.Throttle(
    limit=1,
    period=datetime.timedelta(seconds=5),
    key="event.data.user_id",
    burst=2,
  ),
  trigger=inngest.Trigger(event="ai/summary.requested")
)
async def synchronize_data(ctx: inngest.Context):
    # This function will be throttled to 1 run per 5 seconds for a given event payload with matching user_id
    # while the one-time burst allows 2 extra runs to start within 5 seconds, after which no more runs are accepted for 5 seconds.
```

You can configure throttling on each function using the optional `throttle` parameter.  The options directly control the generic cell rate algorithm parameters used within the queue.

### Configuration reference

- `limit`: The total number of runs allowed to start within the given `period`.
- `period`: The period within the limit will be applied.
- `burst`: The number of runs allowed to start in the given window in a single burst on top of `limit`.
- `key`: An optional expression which returns a throttling key using event data. This allows you to apply unique throttle limits specific to a user.

> **Callout:** GCRA breaks down the provided period into smaller windows based on the limit.
> Without bursts, GCRA will admit a single request for every window. Inngest may attempt to start multiple pending function runs in a short time window, so to guarantee maximum throughput, we start limit + burst function runs in each window, which allows all requests to start within the configured period.This is required as background jobs do not arrive at the same rate as the events triggering them.

**Configuration information**

- Using throttle ensures that within a window of the given `period`, at most `limit + burst` runs may start.
- Period must be between `1s` and `7d`, or between 1 second and 7 days. The minimum granularity is one second.
- Throttling is currently applied per function. Two functions with the same key have two separate limits.
- Every request is evenly weighted and counts as a single unit in the rate limiter.

## How throttling works

Throttling uses the [generic cell rate algorithm (GCRA)](https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm) to limit function run *starts* directly in the queue. When you send an event or invoke a function that specifies throttling configuration, Inngest checks the function's throttle limit to see if there's capacity:

- If there's capacity, the function run starts as usual.
- If there is no capacity, the function run will begin when there's capacity in the future.

Note that throttling only applies to function run starts.  It does not apply to steps within a function.  This allows you to regulate how often functions begin work, *without* worrying about how many steps are in a function, or if steps run in parallel.  To limit how many steps can execute at once, use [concurrency controls](/docs-markdown/guides/concurrency).

Throttling is [FIFO (first in first out)](https://en.wikipedia.org/wiki/FIFO_\(computing_and_electronics\)), so the first function run to be enqueued will be the first to start when there's capacity.

## Throttling vs Concurrency

**Concurrency** limits the *number of executing steps across your function runs*.  This allows you to manage the total capacity of your functions.

**Throttling** limits the number of *new function runs* being started.  It does not limit the number of executing steps.  For example, with a throttling limit of 1 per minute, only one run will start in a single minute.  However, that run may execute hundreds of steps, as throttling does not limit steps.

## Throttling vs Rate Limiting

Rate limiting also specifies how many functions can start within a time period.  However, in Inngest rate limiting ignores function runs over the limit and does not enqueue them for future work. Throttling will enqueue runs over the limit for the future.

Rate limiting is *lossy* and provides hard limits on function runs, while throttling delays function runs over the limit until there‚Äôs capacity, smoothing spikes.

## Tips

- Configure [start timeouts](/docs-markdown/features/inngest-functions/cancellation/cancel-on-timeouts) to prevent large backlogs with throttling

## Further reference

- [TypeScript SDK Reference](/docs-markdown/reference/functions/create#throttle)
- [Python SDK Reference](/docs-markdown/reference/python/functions/create#configuration)


--------------------------------------------------------------------------------
title: "Trigger your code from Retool"
source: "https://www.inngest.com/docs/guides/trigger-your-code-from-retool"
--------------------------------------------------------------------------------

# Trigger your code from Retool

Internal tools are a pain to build and maintain. Fortunately, [Retool](https://retool.com/) has helped tons of companies reduce the burden. Retool primarily focuses on building dashboards and forms and it integrates well with several databases and cloud APIs.

Often though, there are actions that your support or customer success team needs to perform that are too complex for Retool built-in features. You may have even written some of necessary code in your application, but you can't easily run it from Retool.

## The problem

Let's say you have an integration built in your application and you backend code imports a bunch of data from that third party. The third party API or your backend may have went down for a few hours and you may have missing data for certain user. When someone reaches out to support, you may need to re-run that import script to backfill the missing data.

We're going to walk through how you can do this so your team can trigger important scripts right from your Retool app. This guide assumes you have a basic experience building forms with Retool (*If you don't, check out [this great guide](https://docs.retool.com/docs-markdown/create-forms-using-form-component)*).

## The plan

The goal is to enable your team to trigger a script anytime they click a button in Retool. To achieve this we will:

1. Create a Retool button that sends an event to Inngest
2. Write an Inngest function that uses our existing script
3. Configure that function to run when our event is received
4. See how it works end to end

## Sending an event from Retool

To send data from Retool, we'll need to set up a ‚Äú[Resource](https://docs.retool.com/docs-markdown/resources)‚Äù first. On your Resources tab in Retool, click ‚ÄúCreate New‚Äù then select ‚ÄúResource.‚Äù Then select ‚ÄúRest API.‚Äù Now jump over to the Inngest Cloud dashboard and [create a new Event Key in the Inngest dashboard](/docs-markdown/events/creating-an-event-key). Copy your brand new key and in the Retool dashboard, prefix your key with the Inngest Event API URL and path: `https://inn.gs/e/`

```shell
https://inn.gs/e/<INNGEST-EVENT-KEY>
```

Your new resource will look like this. When it does, click ‚ÄúCreate resource.‚Äù

![Inngest Retool resource screenshot](/assets/guides/trigger-your-code-from-retool/retool-resource.png)

Now, let's head to the Retool app that you want to add the button form to. Let's say you have already built out the following form called `runBackfillForm` with a single input called `userId` and a submit button:

![Retool form screenshot](/assets/guides/trigger-your-code-from-retool/retool-form.png)

Next, create a new ‚ÄúResource query‚Äù from the ‚ÄúCode‚Äù panel at the bottom left (use the + button). Let's name our new query `sendBackfillRequested` and select our new ‚ÄúInngest‚Äù resource from the drop down. Update the ‚ÄúAction type‚Äù to a `POST` request. In the ‚ÄúBody‚Äù section, we need add the data that we want to send to Inngest. Inngest events require a name and some data as JSON. It's useful to prefix your event names to group them, here we'll call our event `"retool/backfill.requested"` and we'll pass the user id from the form and for future auditing purposes, the email of the current Retool user on your team:

```json
{ "user_id": "{{runBackfillForm.data.userId}}", "agent_id": "{{current_user.email}}" }
```

At the end, your resource query will look like this. Let's save it then click ‚ÄúRun‚Äù to test it.

![Retool resource query screenshot](/assets/guides/trigger-your-code-from-retool/retool-resource-query.png)

In the Inngest Cloud dashboard's ‚ÄúEvents‚Äù tab, you should see a brand new `retool/backfill.requested` event. Click on the event and you should be able to select the payload that we just sent.

![Inngest Cloud dashboard view event payload](/assets/guides/trigger-your-code-from-retool/inngest-view-event-payload.gif)

Now that we've verified the data is sent over to Inngest, you can attach the resource query as an event handler to the submit button. Select the ‚ÄúDefault‚Äù interaction type and click ‚Äú+ Add‚Äù to select our resource query `sendBackfillRequested`. For fun, you can add an `isFetching` to show loading.

![Retool form submit button event handler](/assets/guides/trigger-your-code-from-retool/retool-resource-query.png)

We're halfway there - with this in place any agent from our team can trigger this event as needed.

## Writing our Inngest function

Using [the Inngest SDK](/features/sdk?ref=retool-guide) you can define your Inngest function and it's event trigger in one file. We'll create a directory called `inngest` in our project root:

```
mkdir -p inngest
```

Now we'll create a file in this directory for our function - `runBackfillForUser.js`. This will be our Inngest function which will import our existing backfill code, use the `user_id` from the event payload to run that code, and return a http status code in our response to tell Inngest [if it should be retried or not](/docs-markdown/functions/retries?ref=retool-guide).

```ts {{ title: "runBackfillForUser.ts" }}
import { runBackfillForUser } from "../lib/backfill-scripts";
import { inngest } from "./client";

export default inngest.createFunction(
  { id: "run-backfill-for-user" }, // The name displayed in the Inngest dashboard
  { event: "retool/backfill.requested" }, // The event triggger
  async ({ event }) => {
    const result = await runBackfillForUser(event.data.user_id);

    return {
      status: result.ok ? 200 : 500,
      message: `Ran backfill for user ${event.data.user_id}`,
    };
  }
);
```

```ts {{ title: "client.ts" }}
import { Inngest } from "inngest";

export const inngest = new Inngest({ id: "my-app" })
```

That's our function - now, we just need to serve our function.

### Serving our function

You need to serve your function to enable Inngest to remotely and securely invoke your function via HTTP.

For this guide, we'll explain how to do this with an existing [Express.js](https://expressjs.com/) application. Inngest's default [`serve()`](/docs-markdown/reference/serve) handler can be imported and passed to Express.js' `app.use` or `router.use`. You can get your Inngest signing key from [the Inngest dashboard](https://app.inngest.com/env/production/manage/signing-key).

```js
import { serve } from "inngest/express"
import runBackfillForUser from "../inngest/runBackfillForUser"

app.use("/api/inngest", serve("My API", process.env.INNGEST_SIGNING_KEY, [
  runBackfillForUser,
]))
// your existing routes...
app.get("/api/whatever", ...)
app.post("/api/something_else", ...)
```

## Deploying your function

By serving your functions via HTTP, you don't need to deploy your code to Inngest Cloud or set up a new deployment process. After you deploy your code, you need to visit the Inngest dashboard to sync your app. This allows Inngest to discover and remotely execute your functions.

üëâ You can read how to do this in our Working with apps guide.

After syncing your app, your new function should appear in the Functions tab of the Inngest Cloud dashboard:

![Inngest Cloud dashboard view deployed function](/assets/guides/trigger-your-code-from-retool/inngest-deployed-function.png)

## Bringing it all together

Now that our code is pushed to production and we've set the secrets that we need, let's test it end to end.

![Retool submit form](/assets/guides/trigger-your-code-from-retool/retool-submit-form.gif)

And a few seconds later in the Inngest cloud dashboard:

![Inngest cloud dashboard view function output](/assets/guides/trigger-your-code-from-retool/inngest-view-function-output.gif)

Fantastic. We've now used our Retool form to trigger a backfill script on-demand with no infrastructure required to setup. Every time your support team needs to trigger this script, they can do it and ensure your users are happy.

## Over to you

You now know how to get some existing code from your application shipped to Inngest and triggered right from Retool with a full audit trail of who triggered it, for what user and full logs. There was no need to set up a more complex infrastructure with a queue or new endpoint on your production API - Just push your code to Inngest and send an event from Retool - done and dusted.


--------------------------------------------------------------------------------
title: "Build workflows configurable by your users"
source: "https://www.inngest.com/docs/guides/user-defined-workflows"
--------------------------------------------------------------------------------

# Build workflows configurable by your users

Users today are demanding customization and integrations from every product. Your users may want your product to support custom workflows to automate key user actions.
Leverage our [Workflow Kit](/docs-markdown/reference/workflow-kit) to add powerful user-defined workflows features to your product.

Inngest's Workflow Kit ships as a full-stack package ([`@inngest/workflow-kit`](https://npmjs.com/package/@inngest/workflow-kit)), aiming to simplify the development of user-defined workflows on both the front end and back end:

## Use case: adding AI automation to a Next.js CMS application

**"Clone or deploy this use case"**: [This use case is available a open-source Next.js demo on GitHub.]('https://github.com/inngest/workflow-kit/tree/main/examples/nextjs-blog-cms#readme')

Our  Next.js CMS application features the following `blog_posts` table:

| Column name | Column type | Description                                |
| ----------- | ----------- | ------------------------------------------ |
| id          | `bigint`    |                                            |
| title       | `text`      | *The title of the blog post*               |
| subtitle    | `text`      | *The subtitle of the blog post*            |
| status      | `text`      | *"draft" or "published"*                   |
| markdown    | `text`      | *The content of the blog post as markdown* |
| created\_at | `timestamp` |                                            |

> **Callout:** You will find a ready-to-use database seed in the repository.

We would like to provide the following AI automation tasks to our users:

**Review tasks**

- Add a Table of Contents: *a task leveraging OpenAI to insert a Table of Contents in the blog post*
- Perform a grammar review: *a task leveraging OpenAI to perform some grammar fixes*

**Social content tasks**

- Generate LinkedIn posts: *a task leveraging OpenAI to generate some Tweets*
- Generate Twitter posts: *a task leveraging OpenAI to generate a LinkedIn post*

Our users will be able to combine those tasks to build their custom workflows.

### 1. Adding the tasks definition to the application

After [installing and setup Inngest](/docs-markdown/getting-started/nextjs-quick-start?ref=docs-guide-user-defined-workflows) in our Next.js application, we will create the following [Workflow Actions definition](/docs-markdown/reference/workflow-kit/actions) file:

```ts {{ title: "lib/inngest/workflowActions.ts" }}
import { type PublicEngineAction } from "@inngest/workflow-kit";

export const actions: PublicEngineAction[] = [
  {
    kind: "add_ToC",
    name: "Add a Table of Contents",
    description: "Add an AI-generated ToC",
  },
  {
    kind: "grammar_review",
    name: "Perform a grammar review",
    description: "Use OpenAI for grammar fixes",
  },
  {
    kind: "wait_for_approval",
    name: "Apply changes after approval",
    description: "Request approval for changes",
  },
  {
    kind: "apply_changes",
    name: "Apply changes",
    description: "Save the AI revisions",
  },
  {
    kind: "generate_linkedin_posts",
    name: "Generate LinkedIn posts",
    description: "Generate LinkedIn posts",
  },
  {
    kind: "generate_tweet_posts",
    name: "Generate Twitter posts",
    description: "Generate Twitter posts",
  },
];

```

**Learn more about Workflow Actions**: [Explore how Workflow actions get declared as PublicEngineAction and EngineAction.](/docs-markdown/reference/workflow-kit/actions)

### 2. Updating our database schema

To enable our users to configure the workflows, we will create the following `workflows` table.

The `workflows` tables stores the [Workflow instance object](/docs/reference/workflow-kit/workflow-instance) containing how the user ordered
the different selected [Workflow actions](/docs-markdown/reference/workflow-kit/actions). Other columns are added to store extra properties specific to
our application such as: the automation name and description, the event triggering the automation and its status (`enabled`).

| Colunm name | Column type | Description                                                                                        |
| ----------- | ----------- | -------------------------------------------------------------------------------------------------- |
| id          | `bigint`    |                                                                                                    |
| name        | `text`      | *The name of the automation*                                                                       |
| description | `text`      | *A short description of the automation*                                                            |
| workflow    | `jsonb`     | *A [Workflow instance object](/docs-markdown/reference/workflow-kit/workflow-instance)*            |
| enabled     | `boolean`   |                                                                                                    |
| trigger     | `text`      | *The name of the [Inngest Event](/docs-markdown/features/events-triggers) triggering the workflow* |
| created\_at | `timestamp` |                                                                                                    |

Once the `workflows` table created, we will add two [workflow instances](/docs-markdown/reference/workflow-kit/workflow-instance) records:

- *"When a blog post is published"*: Getting a review from AI
- *"When a blog post is moved to review"*: Actions performed to optimize the distribution of blog posts

using the following SQL insert statement:

```sql
INSERT INTO "public"."workflows" ("id", "created_at", "workflow", "enabled", "trigger", "description", "name") VALUES
	(2, '2024-09-14 20:19:41.892865+00', NULL, true, 'blog-post.published', 'Actions performed to optimize the distribution of blog posts', 'When a blog post is published'),
	(1, '2024-09-14 15:46:53.822922+00', NULL, true, 'blog-post.updated', 'Getting a review from AI', 'When a blog post is moved to review');
```

> **Callout:** You will find a ready-to-use database seed in the repository.

### 3. Adding the Workflow Editor page

With our workflow actions definition and `workflows` table ready, we will create a new Next.js Page featuring the Workflow Editor.

First, we will add a new [Next.js Page](https://nextjs.org/docs-markdown/app/building-your-application/routing/pages) to load the worklow and render the Editor:

```tsx {{ title: "app/automation/[id]/page.tsx" }}
import { AutomationEditor } from "@/components/automation-editor";
import { createClient } from "@/lib/supabase/server";
import { notFound } from "next/navigation";

export const runtime = "edge";

export default async function Automation({
  params,
}: {
  params: { id: string };
}) {
  const supabase = createClient();
  const { data: workflow } = await supabase
    .from("workflows")
    .select("*")
    .eq("id", params.id!)
    .single();
  if (workflow) {
    return <AutomationEditor workflow={workflow} />;
  } else {
    notFound();
  }
}

```

The `<AutomationEditor>` component is then rendered with the following required properties:

- `workflow={}`:  [workflow instance](/docs-markdown/reference/workflow-kit/workflow-instance) loaded from the database along side
- `event={}`: the name of the event triggering the workflow
- `availableActions={}`: [actions](/docs-markdown/reference/workflow-kit/actions#passing-actions-to-the-react-components-public-engine-action) that the user can select to build its automation

```tsx {{ title: "src/components/automation-editor.ts" }}
import { useState } from "react";
import { Editor, Provider, Sidebar } from "@inngest/workflow-kit/ui";

import { actions } from "@/inngest/workflowActions";
import { type Workflow } from "@/lib/supabase/types";

import "@inngest/workflow-kit/ui/ui.css";
import "@xyflow/react/dist/style.css";

export const AutomationEditor = ({ workflow }: { workflow: Workflow }) => {
  const [workflowDraft, updateWorkflowDraft] =
    useState<typeof workflow>(workflow);

  return (
    <Provider
      key={workflowDraft?.id}
      workflow={workflowDraft?.workflow}
      trigger={{
        event: {
          name: workflowDraft.trigger,
        },
      }}
      availableActions={actions}
      onChange={(updated) => {
        updateWorkflowDraft({
          ...workflowDraft,
          workflow: updated,
        });
      }}
    >
      <Editor>
        <Sidebar position="right"/>
      </Editor>
    </Provider>
  );
};
```

[`<Provider>`](/docs-markdown/reference/workflow-kit/components-api) is a [Controlled Component](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components), relying on the `workflow={}` object to update its UI.

Every change performed by the user will trigger the `onChange={}` callback to be called. This callback should update the object passed to the
`workflow={}` prop and can be used to also implement an auto save mechanism.

> **Callout:** The complete version of the \<AutomationEditor> is available on GitHub.

Navigating to `/automation/1` renders tht following Workflow Editor UI using our workflow actions:

![workflow-kit-announcement-video-loop.gif](/assets/docs-markdown/reference/workflow-kit/workflow-demo.gif)

### 4. Implementing the Workflow Actions handlers

Let's now implement the logic our automation tasks by creating a new file in `lib/inngest` and starting with the "Add a Table of Contents" workflow action:

```tsx {{ title: "lib/inngest/workflowActionHandlers.ts" }}
import OpenAI from "openai";
import { type EngineAction, type WorkflowAction } from "@inngest/workflow-kit";

import { type BlogPost } from "../supabase/types";

import { loadBlogPost } from "../loaders/blog-post";
import { createClient } from "../supabase/server";
import { actions } from "./workflowActions";

export const actions: EngineAction[] = [
  {
    // Add a Table of Contents
    ...actionsDefinition[0],
    handler: async ({ event, step, workflowAction }) => {
      const supabase = createClient();

      const blogPost = await step.run("load-blog-post", async () =>
        loadBlogPost(event.data.id)
      );

      const aiRevision = await step.run("add-toc-to-article", async () => {
        const openai = new OpenAI({
          apiKey: process.env["OPENAI_API_KEY"], // This is the default and can be omitted
        });

        const prompt = `
        Please update the below markdown article by adding a Table of Content under the h1 title. Return only the complete updated article in markdown without the wrapping "\`\`\`".

        Here is the text wrapped with "\`\`\`":
        \`\`\`
        ${getAIworkingCopy(workflowAction, blogPost)}
        \`\`\`
        `;

        const response = await openai.chat.completions.create({
          model: process.env["OPENAI_MODEL"] || "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: "You are an AI that make text editing changes.",
            },
            {
              role: "user",
              content: prompt,
            },
          ],
        });

        return response.choices[0]?.message?.content || "";
      });

      await step.run("save-ai-revision", async () => {
        await supabase
          .from("blog_posts")
          .update({
            markdown_ai_revision: aiRevision,
            status: "under review",
          })
          .eq("id", event.data.id)
          .select("*");
      });
    },
    }
  },
];
```

This new file adds the `handler` property to the existing *"Add a Table of Contents"* action.

A [workflow action `handler()`](/docs-markdown/reference/workflow-kit/actions#handler-function-argument-properties) has a similar signature to Inngest's function handlers, receiving two key arguments: `event` and [`step`](/docs-markdown/reference/functions/create#step).

Our *"Add a Table of Contents"* leverages Inngest's [step API](/docs-markdown/reference/functions/step-run) to create reliable and retriable steps generating and inserting a Table of Contents.

> **Callout:** The complete implementation of all workflow actions are available on GitHub.

### 5. Creating an Inngest Function

With all the workflow action handlers of our automation tasks [implemented](https://github.com/inngest/workflow-kit/blob/main/examples/nextjs-blog-cms/lib/inngest/workflowActionHandlers.ts),
we can create a [`Engine`](/docs-markdown/reference/workflow-kit/engine) instance and pass it to a dedicated [Inngest Function](/docs-markdown/features/inngest-functions) that will run the automation when the `"blog-post.updated"` and `"blog-post.published"` events will be triggered:

```tsx {{ title: "lib/inngest/workflow.ts" }}
import { Engine } from "@inngest/workflow-kit";

import { loadWorkflow } from "../loaders/workflow";
import { inngest } from "./client";
import { actionsWithHandlers } from "./workflowActionHandlers";

const workflowEngine = new Engine({
  actions: actionsWithHandlers,
  loader: loadWorkflow,
});

export default inngest.createFunction(
  { id: "blog-post-workflow" },
  // Triggers
  // - When a blog post is set to "review"
  // - When a blog post is published
  [{ event: "blog-post.updated" }, { event: "blog-post.published" }],
  async ({ event, step }) => {
    // When `run` is called, the loader function is called with access to the event
    await workflowEngine.run({ event, step });
  }
);

```

### Going further

This guide demonstrated how quickly and easily user-defined workflows can be added to your product when using our [Workflow Kit](/docs-markdown/reference/workflow-kit).

**"Step-by-step tutorial of setting up this demo"**: [This use case is available a open-source Next.js demo on GitHub.]('https://github.com/inngest/workflow-kit/tree/main/examples/nextjs-blog-cms#readme')


--------------------------------------------------------------------------------
title: "Working with Loops in Inngest"
source: "https://www.inngest.com/docs/guides/working-with-loops"
--------------------------------------------------------------------------------

# Working with Loops in Inngest

In Inngest each step in your function is executed as a separate HTTP request.  This means that for every step in your function, the function is re-entered, starting from the beginning, up to the point where the next step is executed. This [execution model](/docs-markdown/learn/how-functions-are-executed) helps in managing retries, timeouts, and ensures robustness in distributed systems.

This page covers how to implement loops in your Inngest functions and avoid common pitfalls.

## Simple function example

#### TypeScript

Let's start with a simple example to illustrate the concept:

```javascript
inngest.createFunction(
  { id: "simple-function" },
  { event: "test/simple.function" },
  async ({ step }) => {
    console.log("hello");

    await step.run("a", async () => { console.log("a") });
    await step.run("b", async () => { console.log("b") });
    await step.run("c", async () => { console.log("c") });
  }
);
```

In the above example, you will see "hello" printed four times, once for the initial function entry and once for each step execution (`a`, `b`, and `c`).

```bash {{ title: "‚úÖ How Inngest executes the code" }}

# This is how Inngest executes the code above:

<run start>
"hello"

"hello"
"a"

"hello"
"b"

"hello"
"c"
<run complete>
```

```bash {{ title: "‚ùå Common incorrect misconception" }}

# This is a common assumption of how Inngest executes the code above.
# It is not correct.

<run start>

"hello"
"a"
"b"
"c"

<run complete>
```

Any non-deterministic logic (like database calls or API calls) must be placed inside a `step.run` call to ensure it is executed correctly within each step.

With this in mind, here is how the previous example can be fixed:

```ts
inngest.createFunction(
  { id: "simple-function" },
  { event: "test/simple.function" },
  async ({ step }) => {
    await step.run("hello", () => { console.log("hello") });

    await step.run("a", async () => { console.log("a") });
    await step.run("b", async () => { console.log("b") });
    await step.run("c", async () => { console.log("c") });
  }
);

// hello
// a
// b
// c
```

Now, "hello" is printed only once, as expected.

#### Go

Let's start with a simple example to illustrate the concept:

```go
import (
    "fmt"
    "github.com/inngest/inngestgo"
    "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "simple-function"},
	inngestgo.EventTrigger("test/simple.function", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		fmt.Println("hello")

		_, err := step.Run(ctx, "a", func(ctx context.Context) (any, error) {
			fmt.Println("a")
			return nil, nil
		})
		if err != nil {
			return nil, err
		}

		_, err = step.Run(ctx, "b", func(ctx context.Context) (any, error) {
			fmt.Println("b")
			return nil, nil
		})
		if err != nil {
			return nil, err
		}

		_, err = step.Run(ctx, "c", func(ctx context.Context) (any, error) {
			fmt.Println("c")
			return nil, nil
		})
		if err != nil {
			return nil, err
		}

		return nil, nil
	},
)
```

In the above example, you will see "hello" printed four times, once for the initial function entry and once for each step execution (`a`, `b`, and `c`).

```bash {{ title: "‚úÖ How Inngest executes the code" }}

# This is how Inngest executes the code above:

<run start>
"hello"

"hello"
"a"

"hello"
"b"

"hello"
"c"
<run complete>
```

```bash {{ title: "‚ùå Common incorrect misconception" }}

# This is a common assumption of how Inngest executes the code above.
# It is not correct.

<run start>

"hello"
"a"
"b"
"c"

<run complete>
```

Any non-deterministic logic (like database calls or API calls) must be placed inside a `step.run` call to ensure it is executed correctly within each step.

With this in mind, here is how the previous example can be fixed:

```go
import (
    "fmt"
    "github.com/inngest/inngestgo"
    "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{ID: "simple-function"},
	inngestgo.EventTrigger("test/simple.function", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		if _, err := step.Run(ctx, "hello", func(ctx context.Context) (any, error) {
			fmt.Println("hello")
			return nil, nil
		}); err != nil {
			return nil, err
		}

		if _, err := step.Run(ctx, "a", func(ctx context.Context) (any, error) {
			fmt.Println("a")
			return nil, nil
		}); err != nil {
			return nil, err
		}

		if _, err := step.Run(ctx, "b", func(ctx context.Context) (any, error) {
			fmt.Println("b")
			return nil, nil
		}); err != nil {
			return nil, err
		}

		if _, err := step.Run(ctx, "c", func(ctx context.Context) (any, error) {
			fmt.Println("c")
			return nil, nil
		}); err != nil {
			return nil, err
		}

		return nil, nil
	},
)

// hello
// a 
// b
// c
```

Now, "hello" is printed only once, as expected.

#### Python

Let's start with a simple example to illustrate the concept:

```python
@inngest_client.create_function(
    fn_id="simple-function",
    trigger=inngest.TriggerEvent(event="test/simple.function")
)
async def simple_function(ctx: inngest.Context):
    print("hello")

    async def step_a():
        print("a")
    await ctx.step.run("a", step_a)

    async def step_b():
        print("b") 
    await ctx.step.run("b", step_b)

    async def step_c():
        print("c")
    await ctx.step.run("c", step_c)
```

In the above example, you will see "hello" printed four times, once for the initial function entry and once for each step execution (`a`, `b`, and `c`).

```bash {{ title: "‚úÖ How Inngest executes the code" }}

# This is how Inngest executes the code above:

<run start>
"hello"

"hello"
"a"

"hello"
"b"

"hello"
"c"
<run complete>
```

```bash {{ title: "‚ùå Common incorrect misconception" }}

# This is a common assumption of how Inngest executes the code above.
# It is not correct.

<run start>

"hello"
"a"
"b"
"c"

<run complete>
```

Any non-deterministic logic (like database calls or API calls) must be placed inside a `step.run` call to ensure it is executed correctly within each step.

With this in mind, here is how the previous example can be fixed:

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    id="simple-function",
    trigger=inngest.TriggerEvent(event="test/simple.function")
)
async def simple_function(ctx: inngest.Context):
    await ctx.step.run("hello", lambda: print("hello"))

    await ctx.step.run("a", lambda: print("a"))
    await ctx.step.run("b", lambda: print("b")) 
    await ctx.step.run("c", lambda: print("c"))

# hello
# a
# b
# c
```

Now, "hello" is printed only once, as expected.

## Loop example

#### TypeScript

Here's [an example](/blog/import-ecommerce-api-data-in-seconds) of an Inngest function that imports all products from a Shopify store into a local system. This function iterates over all pages combining all products into a single array.

```typescript
export default inngest.createFunction(
  { id: "shopify-product-import"},
  { event: "shopify/import.requested" },
  async ({ event, step }) => {
    const allProducts = []
    let cursor = null
    let hasMore = true

    // Use the event's "data" to pass key info like IDs
    // Note: in this example is deterministic across multiple requests
    // If the returned results must stay in the same order, wrap the db call in step.run()
    const session = await database.getShopifySession(event.data.storeId)

    while (hasMore) {
      const page = await step.run(`fetch-products-${pageNumber}`, async () => {
        return await shopify.rest.Product.all({
          session,
          since_id: cursor,
        })
      })
      // Combine all of the data into a single list
      allProducts.push(...page.products)
      if (page.products.length === 50) {
        cursor = page.products[49].id
      } else {
        hasMore = false
      }
    }

    // Now we have the entire list of products within allProducts!
  }
)
```

In the example above, each iteration of the loop is managed using `step.run()`, ensuring that **all non-deterministic logic (like fetching products from Shopify) is encapsulated within a step**. This approach guarantees that if the request fails, it will be retried automatically, in the correct order. This structure aligns with Inngest's execution model, where each step is a separate HTTP request, ensuring robust and consistent loop behavior.

Note that in the example above `getShopifySession` is deterministic across multiple requests (and it's added to all API calls for authorization). If the returned results must stay in the same order, wrap the database call in `step.run()`.

Read more about this use case in the [blog post](/blog/import-ecommerce-api-data-in-seconds).

#### Go

Here's an example of an Inngest function that imports all products from a Shopify store into a local system. This function iterates over all pages combining all products into a single array.

```go
_, err := inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		Name: "shopify-product-import",
	},
	inngestgo.EventTrigger("shopify/import.requested", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		var allProducts []shopify.Product
		var cursor *string
		hasMore := true

		// Use the event's "data" to pass key info like IDs
		// Note: in this example is deterministic across multiple requests
		// If the returned results must stay in the same order, wrap the db call in step.run()
		session, err := database.GetShopifySession(input.Event.Data["storeId"].(string))
		if err != nil {
			return err
		}

		for hasMore {
			if page, err := step.Run(ctx, fmt.Sprintf("fetch-products-%v", cursor), func(ctx context.Context) ([]shopify.Product, error) {
				return shopify.Product.All(&shopify.ProductListOptions{
					Session: session,
					SinceID: cursor,
				})
			}); err != nil {
				return err, nil
			}

			// Combine all of the data into a single list
			allProducts = append(allProducts, page.Products...)

			if len(page.Products) == 50 {
				id := page.Products[49].ID
				cursor = &id
			} else {
				hasMore = false
			}
		}

		// Now we have the entire list of products within allProducts!
		return nil, nil
	},
)
```

In the example above, each iteration of the loop is managed using `step.Run()`, ensuring that **all non-deterministic logic (like fetching products from Shopify) is encapsulated within a step**. This approach guarantees that if the request fails, it will be retried automatically, in the correct order. This structure aligns with Inngest's execution model, where each step is a separate HTTP request, ensuring robust and consistent loop behavior.

Note that in the example above `getShopifySession` is deterministic across multiple requests (and it's added to all API calls for authorization). If the returned results must stay in the same order, wrap the database call in `step.Run()`.

Read more about this use case in the [blog post](/blog/import-ecommerce-api-data-in-seconds).

#### Python

Here's an example of an Inngest function that imports all products from a Shopify store into a local system. This function iterates over all pages combining all products into a single array.

```python
@inngest.create_function(
    id="shopify-product-import",
    trigger=inngest.TriggerEvent(event="shopify/import.requested")
)
async def shopify_product_import(ctx: inngest.Context):
    all_products = []
    cursor = None
    has_more = True

    # Use the event's "data" to pass key info like IDs
    # Note: in this example is deterministic across multiple requests
    # If the returned results must stay in the same order, wrap the db call in step.run()
    session = await database.get_shopify_session(ctx.event.data["store_id"])

    while has_more:
        page = await ctx.step.run(f"fetch-products-{cursor}", lambda: shopify.Product.all(
            session=session,
            since_id=cursor
        ))
        # Combine all of the data into a single list
        all_products.extend(page.products)
        if len(page.products) == 50:
            cursor = page.products[49].id
        else:
            has_more = False

    # Now we have the entire list of products within all_products!
```

In the example above, each iteration of the loop is managed using `step.run()`, ensuring that **all non-deterministic logic (like fetching products from Shopify) is encapsulated within a step**. This approach guarantees that if the request fails, it will be retried automatically, in the correct order. This structure aligns with Inngest's execution model, where each step is a separate HTTP request, ensuring robust and consistent loop behavior.

Note that in the example above `get_shopify_session` is deterministic across multiple requests (and it's added to all API calls for authorization). If the returned results must stay in the same order, wrap the database call in `step.run()`.

Read more about this use case in the [blog post](/blog/import-ecommerce-api-data-in-seconds).

## Best practices: implementing loops in Inngest

To ensure your loops run correctly within [Inngest's execution model](/docs-markdown/learn/how-functions-are-executed):

### 1. Treat each loop iterations as a single step

In a typical programming environment, loops maintain their state across iterations. In Inngest, each step re-executes the function from the beginning to ensure that only the failed steps will be re-tried. To handle this, treat each loop iteration as a separate step. This way, the loop progresses correctly, and each iteration builds on the previous one.

### 2. Place non-deterministic logic inside steps

Place non-deterministic logic (like API calls, database queries, or random number generation) inside `step.run` calls. This ensures that such operations are executed correctly and consistently within each step, preventing repeated execution with each function re-entry.

### 3. Use sleep effectively

When using `step.sleep` inside a loop, ensure it is combined with structuring the loop to handle each iteration as a separate step. This prevents the function from appearing to restart and allows for controlled timing between iterations.

## Next steps

- Docs explanation: [Inngest execution model](/docs-markdown/learn/how-functions-are-executed).
- Docs guide: [multi-step functions](/docs-markdown/guides/multi-step-functions).
- Blog post: ["How to import 1000s of items from any E-commerce API in seconds with serverless functions"](/blog/import-ecommerce-api-data-in-seconds).


--------------------------------------------------------------------------------
title: "Writing expressions"
source: "https://www.inngest.com/docs/guides/writing-expressions"
--------------------------------------------------------------------------------

# Writing expressions

Expressions are used in a number of ways for configuring your functions. They are used for:

- Defining keys based on event properties for [concurrency](/docs-markdown/functions/concurrency), [rate limiting](/docs-markdown/reference/functions/rate-limit), [debounce](/docs-markdown/reference/functions/debounce), or [idempotency](/docs-markdown/guides/handling-idempotency)
- Conditionally matching events for [wait for event](/docs-markdown/reference/functions/step-wait-for-event), [cancellation](/docs-markdown/guides/cancel-running-functions), or the [function trigger's `if` option](/docs-markdown/reference/functions/create#trigger)
- Returning values for function [run priority](/docs-markdown/reference/functions/run-priority)

All expressions are defined using the [Common Expression Language (CEL)](https://github.com/google/cel-go). CEL offers simple, fast, non-turing complete expressions. It allows Inngest to evaluate millions of expressions for all users at scale.

## Types of Expressions

Within the scope of Inngest, expressions should evaluate to either a boolean or a value:

- **Booleans** - Any expression used for conditional matching should return a boolean value. These are used in wait for event, cancellation, and the function trigger's `if` option.
- **Values** - Other expressions can return any value which might be used as keys (for example, concurrency, rate limit, debounce or [idempotency keys](/docs-markdown/guides/handling-idempotency)) or a dynamic value (for example, run priority).

## Variables

- `event` refers to the event that triggered the function run, in every case.
- `async` refers to a new event in `step.waitForEvent` and [cancellation](/docs-markdown/guides/cancel-running-functions).  It's the incoming event which is matched asynchronously.  This is only present when matching new events in a function run.

## Examples

Most expressions are given the `event` payload object as the input. Expressions that match additional events (for example, wait for event, cancellation) will also have the `async` object for the matched event payload. To learn more, consult this [reference of all the operators available in CEL](https://github.com/google/cel-spec/blob/master/doc/langdef.md#list-of-standard-definitions).

### Boolean Expressions

```js
// Match a field to a string
"event.data.billingPlan == 'enterprise'"

// Number comparison
"event.data.amount > 1000"

// Combining multiple conditions
"event.data.billingPlan == 'enterprise' && event.data.amount > 1000"
"event.data.billingPlan != 'pro' || event.data.amount < 300"

// Compare the function trigger with an inbound event (for wait for event or cancellation)
"event.data.userId == async.data.userId"

// Alternatively, you can use JavaScript string interpolation for wait for event
`${userId} == async.data.userId` // => "user_1234 == async.data.userId"
```

### Value Expressions

#### Keys

```js
// Use the user's id as a concurrency key
"event.data.id" // => "1234"

// Concatenate two strings together to create a unique key
`event.data.userId + "-" + event.type` // => "user_1234-signup"
```

#### Dynamic Values

```js
// Return a 0 priority if the billing plan is enterprise, otherwise return 1800
`event.data.billingPlan == 'enterprise' ? 0 : 1800`

// Return a value based on multiple conditions
`event.data.billingPlan == 'enterprise' && event.data.requestNumber < 10 ? 0 : 1800`
```

## Tips

- Use `+` to concatenate strings
- Use `==` for equality checks
- You can use single `'` or double quotes `"` for strings, but we recommend sticking with one for code consistency
- When working with the TypeScript SDK, write expressions within backticks `` ` `` to use quotes in your expression or use JavaScript's string interpolation.
- Use ternary operators to return default values
- When using the or operator (`||`), CEL will always return a boolean. This is different from JavaScript, where the or operator returns the value of the statement left of the operator if truthy. Use the ternary operator (`?`) instead of `||` for conditional returns.

> **Info:** Please note that while CEL supports a wide range of helpers and macros, Inngest only supports a subset of these to ensure a high level of performance and reliability.

## Testing out expressions

You can test out expressions on [Undistro's CEL Playground](https://playcel.undistro.io/). It's a great way to quickly test out more complex expressions, especially with conditional returns.


--------------------------------------------------------------------------------
title: "Improve Performance"
source: "https://www.inngest.com/docs/improve-performance"
--------------------------------------------------------------------------------

# Improve Performance

Inngest offers two complementary approaches to reduce latency in your functions: **Checkpointing** for faster step execution, and **Connect** for persistent, low-latency connections between your app and Inngest.

***

## Checkpointing

Checkpointing is a performance optimization for Inngest functions that executes steps eagerly rather than waiting on internal orchestration.

### Differences in Execution Models

The [Inngest default execution model](/docs-markdown/learn/how-functions-are-executed) is a complete handoff to the Inngest Platform, where an HTTP request is performed to store the execution state upon each step completion, leading to inter-step latency.

Checkpointing uses the SDK to orchestrate steps and run them on the client side, resulting in the immediate execution of subsequent synchronous steps (ex, `step.run()`) in a function. As steps execute, checkpointing requests are sent to Inngest to keep track of progress when an async step is met (ex, `step.sleep()`).

With the standard execution model, Inngest orchestrates your function by making network round-trips between each step. This is reliable, but adds latency.

Checkpointing flips this: the SDK orchestrates steps on the client-side (*on your server*) and executes them immediately. As steps completed, checkpoint messages are sent to Inngest to track progress. The result is dramatically lower latency ‚Äî ideal for real-time AI workflows.

### Failures and Retries

What happens when something goes wrong? If a step fails and needs to retry, the execution engine falls back to standard orchestration to handle it properly. You get speed when things work, and safety when they don't.

### Checkpointing Setup

#### TypeScript

To enable checkpointing:

1. Install `inngest@3.51.0` or higher
2. Set `checkpointing: true` on your Inngest client

```ts
import { Inngest } from "inngest";

export const inngest = new Inngest({
  id: "my-app",
  checkpointing: true,
});
```

#### Go

To enable checkpointing:

1. Install the checkpoint package:

```shell
go get github.com/inngest/inngestgo/pkg/checkpoint
```

2. Set `Checkpoint` on your function options:

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/pkg/checkpoint"
)

_, err := inngestgo.CreateFunction(
  client,
  inngestgo.FunctionOpts{
    ID:         "my-function",
    Name:       "My Function",
    Checkpoint: checkpoint.ConfigSafe,
  },
  // ... triggers and handler
)
```

Read [the detailed checkpointing guide](/docs-markdown/setup/checkpointing) for more information.

***

## Connect

The `connect` API allows your app to create an outbound persistent connection to Inngest (*workers-style approach*). This is another way to reduce latency ‚Äî by keeping a WebSocket connection open rather than making HTTP requests for each step.

### Performance Benefits

Compared to the standard [`serve`](/docs-markdown/learn/serving-inngest-functions) approach, `connect` offers:

- **Lowest latency** ‚Äî Persistent connections eliminate the overhead of establishing new HTTP connections for each step.
- **Simpler long running steps** ‚Äî Step execution is not bound by platform HTTP timeouts.
- **Elastic horizontal scaling** ‚Äî Easily add more capacity by running additional workers.
- **Ideal for container runtimes** ‚Äî Deploy on Kubernetes or ECS without the need of a load balancer for inbound traffic.

### How It Works

The `connect` API establishes a persistent WebSocket connection to Inngest. Each connection can handle executing multiple functions and steps concurrently. Each app can create multiple connections to Inngest enabling horizontal scaling.

Key features include:

- **Automatic re-connections** ‚Äî The connection will automatically reconnect if it is closed.
- **Graceful shutdown** ‚Äî The connection gracefully shuts down when the app receives a termination signal (`SIGTERM`). New steps won't be accepted, but existing steps are allowed to complete.
- **Worker-level maximum concurrency (Coming soon)** ‚Äî Each worker can configure the maximum number of concurrent steps it can handle, allowing Inngest to distribute load across multiple workers.

> **Info:** WebSocket connection and HTTP fallback ‚Äî While a WebSocket connection is open, the worker sends and receives all step results via WebSocket. When the connection closes, the worker falls back to the HTTP API to send any remaining step results.

### Getting Started with Connect

For full setup instructions, requirements, deployment guides, and lifecycle management, see the [Connect documentation](/docs-markdown/setup/connect).


--------------------------------------------------------------------------------
title: "Durable Endpoints&#x20;"
source: "https://www.inngest.com/docs/learn/durable-endpoints"
--------------------------------------------------------------------------------

# Durable Endpoints&#x20;

Durable Endpoints let you build or transform your API into fault-tolerant endpoints simply by wrapping your critical logic into [durable steps](/docs-markdown/learn/inngest-steps).

Durable Endpoints behave like normal endpoints. The mental model stays the same: request, response. But each step brings you tracing, observability, and retry logic from the point of failure.

## When to use Durable Endpoints

**You have endpoints that fail partway through.** Any endpoint with multiple steps where failure at step 3 means steps 1 and 2 were wasted work. Instead of writing try/catch logic everywhere or hoping for the best, simply wrap your code in steps and let failures resume from where they left off.

**You want observability without the setup.** If you want visibility into your endpoints without configuring a bunch of external services, Durable Endpoints give you that instantly.

**You're already using Inngest.** You can add durability to other endpoints without refactoring everything into a workflow or thinking heavily about event logic.

## Quick Start

If you have a traditional endpoint:

```typescript {{ title: "Next.js" }}
import { NextRequest } from "next/server";

export const POST = async (req: NextRequest) => {
  const { userId, data } = await req.json();
  
  const user = await db.users.find(userId);
  const enriched = { ...data, account: user.accountId };

  const result = await processData(enriched);

  await sendNotification(userId, result);

  return Response.json({ success: true, result });
};
```

```typescript {{ title: "Bun" }}
Bun.serve({
  port: 3000,
  routes: {
    "/process": async (req) => {
      const { userId, data } = await req.json();

      const user = await db.users.find(userId);
      enriched = { ...data, account: user.accountId };

      const result = await processData(enriched);

      await sendNotification(userId, result);

      return new Response(JSON.stringify({ success: true, result }));
    },
  },
});
```

Create an Inngest client:

```typescript {{ title: "Next.js" }}
import { Inngest } from "inngest";
import { endpointAdapter } from "inngest/next";

const inngest = new Inngest({
  id: "my-app",
  endpointAdapter,
});
```

```typescript {{ title: "Bun" }}
import { Inngest } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({
  id: "my-app",
  endpointAdapter,
});
```

Then, wrap your API endpoint with `inngest.endpoint` and move your endpoint's critical logic into `step.run` blocks:

```typescript {{ title: "Next.js" }}
import { step } from "inngest";
import { inngest } from "@/inngest/client";
import { NextRequest } from "next/server";

export const POST = inngest.endpoint(async (req: NextRequest) => {
  const { userId, data } = await req.json();

  // Step 1: Validate and enrich the data
  const enriched = await step.run("enrich-data", async () => {
    const user = await db.users.find(userId);
    return { ...data, account: user.accountId };
  });

  // Step 2: Process the enriched data
  const result = await step.run("process", async () => {
    return await processData(enriched);
  });

  // Step 3: Send notification
  await step.run("notify", async () => {
    await sendNotification(userId, result);
  });

  return Response.json({ success: true, result });
});
```

```typescript {{ title: "Bun" }}
import { Inngest, step } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({ id: "my-app", endpointAdapter });

Bun.serve({
  port: 3000,
  routes: {
    "/process": inngest.endpoint(async (req) => {
      const { userId, data } = await req.json();

      // Step 1: Validate and enrich the data
      const enriched = await step.run("enrich-data", async () => {
        const user = await db.users.find(userId);
        return { ...data, account: user.accountId };
      });

      // Step 2: Process the enriched data
      const result = await step.run("process", async () => {
        return await processData(enriched);
      });

      // Step 3: Send notification
      await step.run("notify", async () => {
        await sendNotification(userId, result);
      });

      return new Response(JSON.stringify({ success: true, result }));
    }),
  },
});
```

If `process` fails, the endpoint will retry from that step. `enrich-data` won't re-run.

**Read the [Durable Endpoint TypeScript SDK Reference](/docs-markdown/reference/typescript/durable-endpoints) for more detailed usage information.**

### Using Steps

Durable Endpoints support all the same step methods as Inngest functions. See the [Steps documentation](/docs-markdown/learn/inngest-steps) for the full reference:

- [`step.run()`](/docs-markdown/learn/inngest-steps#step-run): Reliably execute the provided block by retrying upon failure
- [`step.sleep()`](/docs-markdown/learn/inngest-steps#step-sleep): Pause execution for a duration
- [`step.waitForEvent()`](/docs-markdown/learn/inngest-steps#step-wait-for-event-step-wait-for-event): Wait for an external event

## Requesting a Durable Endpoint

Durable Endpoints behave like regular API endpoints on the success path. You can request them from your front-end (*or back-end*) using `fetch()` or your favorite query or http library:

However, when a failure triggers retries, a Durable Endpoint returns a redirect to a dedicated endpoint on Inngest Cloud to poll the final result.

Here is a snippet handling both the direct result and the redirected result after retries:

```typescript
function handleError(error) {
  // ...
}

async function handleResult(result) {
  const result = await res.json()
  // ...
}

fetch(`/api/your-durable-endpoint`)
  .then((res) => {
    if (res.redirected) {
      // follow the redirect
      fetch(res.url)
        .then(handleResult)
        .catch(handleError);
    } else {
      handleResult(res)
    }
  })
  .catch(handleError);
```

> **Callout:** As the Durable Endpoint redirects the request to a dedicated endpoint on Inngest's Cloud, fetch() cannot simply follow this redirect for you (CORS policy).
> Instead, you need to get the redirect URL (res.url) and trigger a new fetch() request.

## SDK Support

| SDK        | Support | Version                         |
| ---------- | ------- | ------------------------------- |
| TypeScript | ‚úÖ Beta  | >= 3.x (with `endpointAdapter`) |
| Go         | ‚úÖ       | >= v0.14.0                      |

## Limitations

Durable Endpoints is currently in beta. The following limitations apply:

- **Flow control is not supported** ‚Äî Features like concurrency limits and rate limiting are not available for Durable Endpoints
- **POST body is not yet supported** ‚Äî Prefer using query strings for passing data. POST body support is coming soon
- **Standard HTTP responses only** ‚Äî Durable Endpoints should return a standard HTTP response, not an SSE stream

## Examples

The [Durable Endpoints example page](/docs-markdown/examples/durable-endpoints) provides practical pattern examples such as parallel steps.

The following demos are also available to check out and run locally with the Inngest Dev Server:

**"Explore the full Trip Booker example"**: [Clone this example locally to run it and explore the full source code.](https://github.com/inngest/inngest-js/tree/main/examples/durable-endpoints-trip-booker#readme)

**"Explore the full DeepResearch demo"**: [Explore a more advanced example with a DeepResearch interface entirely built with Durable Endpoints.](https://github.com/inngest/inngest-js/tree/main/examples/durable-endpoints-deepresearch#readme)

## Further Reference

- [Durable Endpoint - TypeScript SDK Reference](/docs-markdown/reference/typescript/durable-endpoints)
- [Steps Overview](/docs-markdown/learn/inngest-steps)


--------------------------------------------------------------------------------
title: "Glossary"
source: "https://www.inngest.com/docs/learn/glossary"
--------------------------------------------------------------------------------

# Glossary

This glossary serves as a quick reference for key terminology used in Inngest's documentation. The terms are organized alphabetically.

## Batching

Batching is one of the methods offered by Inngest's [Flow Control](#flow-control). It allows you to process multiple events in a single batch function to improve efficiency and reduce system load. By handling high volumes of data in batches, you can optimize performance, minimize processing time, and reduce costs associated with handling individual events separately. Read more about [Batching](https://www.inngest.com/docs-markdown/guides/batching).

## Concurrency Management

Concurrency management is one of the methods offered by Inngest's [Flow Control](#flow-control). It involves controlling the number of [steps](#inngest-step) executing simultaneously within a [function](#inngest-function). It prevents system overload by limiting how many processes run at once, which can be set at various levels such as globally, per-function, or per-user. This ensures efficient resource use and system stability, especially under high load conditions. Read more about [Concurrency Management](/docs-markdown/guides/concurrency).

## Debouncing

Debouncing is one of the methods offered by Inngest's [Flow Control](#flow-control). It prevents a [function](#inngest-function) from being executed multiple times in rapid succession by ensuring it is only triggered after a specified period of inactivity. This technique helps to eliminate redundant function executions caused by quick, repeated events, thereby optimizing performance and reducing unnecessary load on the system. It is particularly useful for managing user input events and other high-frequency triggers. Read more about [Debouncing](/docs-markdown/guides/debounce).

## Durable Execution

Durable Execution ensures that functions are fault-tolerant and resilient by handling failures and interruptions gracefully. It uses automatic retries and state persistence to allow [functions](#inngest-function) to continue running from the point of failure, even if issues like network failures or timeouts occur. This approach enhances the reliability and robustness of applications, making them capable of managing even complex and long-running workflows. Read more about [Durable Execution](/docs-markdown/learn/how-functions-are-executed).

## Fan-out Function

A fan-out function (also known as "fan-out job") in Inngest is designed to trigger multiple [functions](#inngest-function) simultaneously from a single [event](#inngest-event). This is particularly useful when an event needs to cause several different processes to run in parallel, such as sending notifications, updating databases, or performing various checks. Fan-out functions enhance the efficiency and responsiveness of your application by allowing concurrent execution of tasks, thereby reducing overall processing time and enabling complex workflows. Read more about [Fan-out Functions](/docs-markdown/guides/fan-out-jobs).

## Flow Control

Flow control in Inngest encompasses rate, throughput, priority, timing, and conditions of how functions are executed in regard to events. It helps optimize the performance and reliability of workflows by preventing bottlenecks and managing the execution order of tasks with tools like [steps](#inngest-step). Read more about [Flow Control](/docs-markdown/guides/flow-control).

## Function Replay

Function replay allows developers to rerun failed functions from any point in their execution history. This is useful for debugging and correcting errors without needing to manually re-trigger events, thus maintaining workflow integrity and minimizing downtime. Read more about [Function Replay](/docs-markdown/platform/replay).

## Idempotency

Idempotency is one of the methods offered by Inngest's [Flow Control](#flow-control). It guarantees that multiple identical requests have the same effect as a single request, preventing unintended side effects from repeated executions. By handling idempotency, you can avoid issues such as duplicate transactions or repeated actions, ensuring that your workflows remain accurate and dependable. Read more about [Handling idempotency](/docs-markdown/guides/handling-idempotency).

## Inngest App

Inngest apps are higher-level constructs that group multiple [functions](#inngest-function) and configurations under a single entity. An Inngest app can consist of various functions that work together to handle complex workflows and business logic. This abstraction helps in organizing and managing related functions and their configurations efficiently within the Inngest platform. Read more about [Inngest Apps](/docs-markdown/apps/cloud).

## Inngest Client

The Inngest client is a component that interacts with the Inngest platform. It is used to define and manage [functions](#inngest-function), send [events](#inngest-event), and configure various aspects of the Inngest environment. The client serves as the main interface for developers to integrate Inngest's capabilities into their applications, providing methods to create functions, handle events, and more. Read more about [Inngest Client](/docs-markdown/reference/client/create).

## Inngest Cloud

Inngest Cloud (also referred to as "Inngest UI" or inngest.com) is the managed service for running and managing your [Inngest functions](#inngest-function). It comes with multiple environments for developing, testing, and production. Inngest Cloud handles tasks like state management, retries, and scalability, allowing you to focus on building your application logic. Read more about [Inngest Cloud](/docs-markdown/platform/environments).

## Inngest Dev Server

The Inngest Dev Server provides a local development environment that mirrors the production setup. It allows developers to test and debug their [functions](#inngest-function) locally, ensuring that code behaves as expected before deployment. This tool significantly enhances the development experience by offering real-time feedback and simplifying local testing. Read more about [Inngest Dev Server](/docs-markdown/local-development).

## Inngest Event

An event is a trigger that initiates the execution of a [function](#inngest-function). Events can be generated from various sources, such as user actions or external services (third party webhooks or API requests). Each event carries data that functions use to perform their tasks. Inngest supports handling these events seamlessly. Read more about [Events](/docs-markdown/events).

## Inngest Function

Inngest functions are the fundamental building blocks of the Inngest platform,
which enable developers to run reliable background logic, from background jobs to complex workflows. They provide robust tools for retrying, scheduling, and coordinating complex sequences of operations. They are composed of [steps](#inngest-step) that can run independently and be retried in case of failure. Inngest functions are powered by [Durable Execution](#durable-execution), ensuring reliability and fault tolerance, and can be deployed on any platform, including serverless environments. Read more about [Inngest Functions](/docs-markdown/learn/inngest-functions).

## Inngest Step

In Inngest, a "step" represents a discrete, independently retriable unit of work within a [function](#inngest-function). Steps enable complex workflows by breaking down a function into smaller, manageable blocks, allowing for automatic retries and state persistence. This approach ensures that even if a step fails, only that task is retried, not the entire function. Read more about [Inngest Steps](/docs-markdown/learn/inngest-steps).

## Priority

Priority is one of the methods offered by Inngest's [Flow Control](#flow-control). It allows you to assign different priority levels to [functions](#inngest-function), ensuring that critical tasks are executed before less important ones. By setting priorities, you can manage the order of execution, improving the responsiveness and efficiency of your workflows. This feature is essential for optimizing resource allocation and ensuring that high-priority operations are handled promptly. Read more about [Priority](/docs-markdown/guides/priority).

## Rate Limiting

Rate limiting is one of the methods offered by Inngest's [Flow Control](#flow-control). It controls the frequency of [function](#inngest-function) executions over a specified period to prevent overloading the system. It helps manage API calls and other resources by setting limits on how many requests or processes can occur within a given timeframe, ensuring system stability and fair usage. Read more about [Rate Limiting](/docs-markdown/guides/rate-limiting).

## SDK

The Software Development Kit (SDK) is a collection of tools, libraries, and documentation that allows developers to easily integrate and utilize Inngest's features within their applications. The SDK simplifies the process of creating, managing, and executing functions, handling events, and configuring workflows. It supports multiple programming languages and environments, ensuring broad compatibility and ease of use. Currently, Inngest offers SDKs for TypeScript, Python, and Go. Read more about [Inngest SDKs](/docs-markdown/reference).

## Step Memoization

Step memoization in Inngest refers to the technique of storing the results of steps so they do not need to be re-executed if already completed. This optimization enhances performance and reliability by preventing redundant computations and ensuring that each step's result is consistently available for subsequent operations. Read more about [Step Memoization](/docs-markdown/learn/how-functions-are-executed#secondary-executions-memoization-of-steps).

## Throttling

Throttling is one of the methods offered by Inngest's [Flow Control](#flow-control). It controls the rate at which [functions](#inngest-function) are executed to prevent system overload. By setting limits on the number of executions within a specific timeframe, throttling ensures that resources are used efficiently and helps maintain the stability and performance of your application. It can be configured on a per-user or per-function basis, allowing for flexible and precise control over execution rates. Read more about [Throttling](/docs-markdown/guides/throttling).

## Next Steps

- Explore Inngest through our [Quick Start](/docs-markdown/getting-started/nextjs-quick-start?ref=docs-glossary).
- Learn about [Inngest Functions](/docs-markdown/learn/inngest-functions).
- Learn about [Inngest Steps](/docs-markdown/learn/inngest-steps).
- Understand how [Inngest functions are executed](/docs-markdown/learn/how-functions-are-executed).


--------------------------------------------------------------------------------
title: "How Inngest functions are executed: Durable Execution"
source: "https://www.inngest.com/docs/learn/how-functions-are-executed"
--------------------------------------------------------------------------------

# How Inngest functions are executed: Durable Execution

One of the core features of Inngest is Durable Execution. Durable Execution allows your functions to be fault-tolerant and resilient to failures. The end result is that your code, and therefore, your overall application, is more reliable.

This page covers what Durable Execution is, how it works, and how it works with Inngest functions.

## What is Durable Execution?

Durable Execution is a fault-tolerant approach to executing code that is achieved by handling failures and interruptions gracefully with automatic retries and state persistence. This means that your code can continue to run even if there are issues like network failures, timeouts, infrastructure outages, and other transient errors.

Key aspects of Durable Execution include:

- **State persistance** - Function state is persisted outside of the function execution context. This enables function execution to be resumed from the point of failure on the same *or* different infrastructure.
- **Fault-tolerance** - Errors or exceptions are caught by the execution layer and are automatically retried. Retry behavior can be customized to handle the accepted number of retries and handle different types of errors.

In practice, Durable Execution is implemented in the form of "durable functions," sometimes also called "durable workflows." Durable functions can throw errors or exceptions and automatically retry, resuming execution from the point of failure. Durable functions are designed to be long-running and stateful, meaning that they can persist state across function invocations and retries.

## How Inngest functions work

Inngest functions are durable: they throw errors or exceptions, automatically retry from the point of failure, and can be stateful and long-running.

Inngest functions use "**Steps**" to define the execution flow of a function. Each step:

- Is a unit of work that can be run and retried independently.
- Captures any error or exception thrown within it.
- Will not be re-executed if it has already been successfully executed.
- Returns state (*data*) that can be used by subsequent steps.
- Can be executed in parallel or sequentially, depending on the function's configuration.

Complex functions can consist of many steps. This allows a long-running function to be broken down into smaller, more manageable units of work. As each step is retried independently, and the function can be resumed from the point of failure, avoiding unnecessary re-execution of work.

In comparison, some Durable Execution systems modify the runtime environment to persist state or interrupt errors or exceptions. Inngest SDKs are written using standard language primitives, which enables Inngest functions to run in any environment or runtime - including serverless environments - without modification.

### How steps are executed

Inngest functions are defined with a series of steps that define the execution flow of the function. Each step is defined with a unique ID and a function that defines the work to be done. The data returned can be used by subsequent steps.

Inngest functions execute incrementally, *step by step*. As a function is executed, the results of each step are returned to Inngest and persisted in a managed function state store. The steps that successfully executed are [*memoized*](https://en.wikipedia.org/wiki/Memoization). The function then resumes, skipping any steps that have already been completed and the SDK injects the data returned by the previous step into the function.

> **Callout:** Each step in your function is executed as a separate HTTP request. Any non-deterministic logic (such as DB calls or API calls) must be placed within a step.run() call to ensure it executes efficiently and correctly in the context of the execution model.

Let's look at an example of a function and walk through how it is executed:

```typescript
const fn = inngest.createFunction(
  { id: "import-contacts" },
  { event: "contacts/csv.uploaded" },
  // The function handler:
  async ({ event, step }) => {
    const rows = await step.run("parse-csv", async () => {
      return await parseCsv(event.data.fileURI);
    });

    const normalizedRows = await step.run("normalize-raw-csv", async () => {
      const normalizedColumnMapping = getNormalizedColumnNames();
      return normalizeRows(rows, normalizedColumnMapping);
    });

    const results = await step.run("input-contacts", async () => {
      return await importContacts(normalizedRows);
    });

    return { results };
  }
);
```

### Initial execution

1. When the function is first called, the *function handler* is called with only the `event` payload data sent.
2. When the first step is discovered, the `"parse-csv"` step is run. As the step has not been executed before, the step's code (the callback function) is run and the result is captured.
3. The function does not continue executing beyond this step. Each SDK uses a different method to interrupt the function execution before running any more code in your function handler.
4. Internally, the step's ID (`"parse-csv"`) is hashed as the state identifier to be used in future executions. Additionally, the steps' index (`0` in this case) is also included in the result.
5. The result is sent back to Inngest and persisted in the function state store.

### Secondary executions - Memoization of steps

Each of the subsequent steps leverages the state of previous executions and memoization. Here's how it works:

6. The function is re-executed, this time with the `event` payload data and the state of the previous execution in JSON.
7. The next step is discovered (`"parse-csv"`).
8. The previous result is found in the state of previous executions. Internally, the SDK uses the hash of the step name to look up the result in the state data.
9. The step's code is not executed, instead the SDK injects the result into the return value of `step.run`, (in this example, the data will be returned as `rows`).
10. The function continues execution until the next step is discovered (`"normalize-raw-csv"`).
11. The step's code is executed and the result is returned to Inngest (in the same approach as steps 2-5 above).

### Error handling

Some steps may throw errors or exceptions during execution. Here's how error handling works within function execution:

12. If an error occurs during the execution of a step (for example, `"input-contacts"`), the function is interrupted and the error is caught by the SDK.
13. The error is serialized and returned to Inngest. The number of attempts are logged and the error is persisted in the function state store.
14. Depending on the number of attempts configured for the function, the function may be retried (see: [Error handling](/docs-markdown/guides/error-handling)):
    - If the the function *has not* exhausted the number of attempts, the function is re-executed from the point of failure with the state of all previous step executions. The step is re-executed and follows the same process as above (see: steps 6-11).
    - If the function *has* exhausted the number of attempts, the function is re-executed with the error thrown. The function can then catch and handle the error as desired (see: [Handling a failing step](/docs-markdown/guides/error-handling#handling-a-failing-step)).

To learn about how determinism is handled and how you can version functions, read the [Versioning long running functions](/docs-markdown/learn/versioning) guide.

## Conclusion

Inngest functions use steps and memoization to execute functions incrementally and durably. This approach ensures that functions are fault-tolerant and resilient to failures. By breaking down functions into steps, Inngest functions can be retried and resumed from the point of failure. This approach ensures that your code is more reliable and can handle transient errors gracefully.

## Further reading

More information on Durable Execution in Inngest:

- Blog post: ["How we built a fair multi-tenant queuing system"](/blog/building-the-inngest-queue-pt-i-fairness-multi-tenancy)
- Blog post: ["Debouncing in Queueing Systems: Optimizing Efficiency in Asynchronous Workflows"](/blog/debouncing-in-queuing-systems-optimizing-efficiency-in-async-workflows)
- Blog post: ["Accidentally Quadratic: Evaluating trillions of event matches in real-time"](/blog/accidentally-quadratic-evaluating-trillions-of-event-matches-in-real-time)
- Blog post: ["Queues aren't the right abstraction"](/blog/queues-are-no-longer-the-right-abstraction)


--------------------------------------------------------------------------------
title: "Inngest Functions"
source: "https://www.inngest.com/docs/learn/inngest-functions"
--------------------------------------------------------------------------------

# Inngest Functions

Inngest functions enable developers to run reliable background logic, from background jobs to complex workflows.
An Inngest Function is composed of 3 main parts that provide robust tools for retrying, scheduling, and coordinating complex sequences of operations:

**Triggers**: [A list of Events, Cron schedules or webhook events that trigger Function runs.]('/docs-markdown/features/events-triggers')

**Flow Control**: [Control how Function runs get distributed in time with Concurrency, Throttling and more.]('/docs/guides/flow-control')

**Steps**: [Transform your Inngest Function into a workflow with retriable checkpoints.]('/docs/features/inngest-functions/steps-workflows')

#### TypeScript

```ts
inngest.createFunction({
    id: "sync-systems",
    // Easily add Throttling with Flow Control
    throttle: { limit: 3, period: "1min"},
  },
  // A Function is triggered by events
  { event: "auto/sync.request" },
  async ({ step }) => {
    // step is retried if it throws an error
    const data = await step.run("get-data", async () => {
      return getDataFromExternalSource();
    });

    // Steps can reuse data from previous ones
    await step.run("save-data", async () => {
      return db.syncs.insertOne(data);
    });
  }
);
```

#### Python

```python
@inngest_client.create_function(
    id="sync-systems",
    # trigger (event or cron)
    trigger=inngest.TriggerEvent(event="auto/sync.request"),
)
def sync_systems(ctx: inngest.ContextSync) -> None:
    # step is retried if it throws an error
    data = ctx.step.run("Get data", get_data_from_external_source)

    # Steps can reuse data from previous ones
    ctx.step.run("Save data", db.syncs.insert_one, data)
```

#### Go

```go
import (
	"context"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func loadSyncDataInngestFn(client inngestgo.Client) (inngestgo.ServableFunction, error) {
	return inngestgo.CreateFunction(client,
		inngestgo.FunctionOpts{ID: "sync-systems"},
		// Functions are triggered by events
		inngestgo.EventTrigger("auto/sync.request", nil),
		func(ctx context.Context, input inngestgo.Input[SyncRequestEvent]) (any, error) {
			// By wrapping code in step.run, the code will be retried if it throws an error and when successfuly.
			// It's result is saved to prevent unnecessary re-execution
			data, err := step.Run(ctx, "get-data", func(ctx context.Context) (any, error) {
				return getDataFromExternalSource()
			})
			if err != nil {
				return nil, err
			}

			// steps can reuse data from previous ones
			// can also be retried up to 4 times
			_, err = step.Run(ctx, "save-data", func(ctx context.Context) (any, error) {
				return InsertIntoDB(data.(DataType))
			})
			if err != nil {
				return nil, err
			}

			return nil, nil
		},
	)
}
```

## Using Inngest Functions

Start using Inngest Functions by using the pattern that fits your use case:

**Background jobs**: [Run long-running tasks out of the critical path of a request.]('/docs-markdown/guides/background-jobs')

**Delayed Functions**: [Schedule Functions that run in the future.]('/docs/guides/delayed-functions')

**Cron Functions**: [Build Inngest Functions as CRONs.]('/docs/guides/scheduled-functions')

**Workflows**: [Start creating workflows by leveraging Inngest Function Steps.]('/docs/guides/multi-step-functions')

## Learn more about Functions and Steps

Functions and Steps are powered by Inngest's Durable Execution Engine. Learn about its inner working by reading the following guides:

**How Functions are executed**: [A deep dive into Inngest's Durable Execution Engine with a step-by-step workflow run example.]('/docs/learn/how-functions-are-executed')

**Thinking in Steps**: [Discover by example how steps enable more reliable and flexible functions with step-level error handling, conditional steps and waits.]('/docs/guides/multi-step-functions')

## SDK References

**"TypeScript SDK"**: [API reference]("/docs/reference/typescript")

**"Python SDK"**: [API reference]("/docs/reference/python")

**"Go SDK"**: [Go API reference]("https://pkg.go.dev/github.com/inngest/inngestgo@v0.9.0/step")


--------------------------------------------------------------------------------
title: "Inngest Steps"
source: "https://www.inngest.com/docs/learn/inngest-steps"
--------------------------------------------------------------------------------

# Inngest Steps

Steps are fundamental building blocks in Inngest functions. Each step represents an individual task (or other unit of work) within a function that can be executed independently.

Steps are crucial because they allow functions to run specific tasks in a controlled and sequential (or parallel) manner. You can build complex workflows by chaining together simple, discrete operations.

On this page, you will learn about the benefits of using steps, and get an overview of the available step methods.

## Benefits of Using Steps

- **Improved reliability**: structured steps enable precise control and handling of each task within a function.
- **Error handling**: capturing and managing errors at the step level means better error recovery.
- **Retry mechanism**: failing steps can be retried and recovered independently, without re-executing other successful steps.
- **Independent testing**: each step can be tested and debugged independently from others.
- **Improved code readability**: modular approach makes code easier to navigate and refactor.

If you'd like to learn more about how Inngest steps are executed, check the ["How Inngest functions are executed"](/docs-markdown/learn/how-functions-are-executed) page.

## Anatomy of an Inngest Step

The first argument of every Inngest step method is an `id`. Each step is treated as a discrete task which can be individually retried, debugged, or recovered. Inngest uses the ID to memoize step state across function versions.

#### TypeScript

```typescript
export default inngest.createFunction(
  { id: "import-product-images" },
  { event: "shop/product.imported" },
  async ({ event, step }) => {
    const uploadedImageURLs = await step.run(
      // step ID
      "copy-images-to-s3",
      // other arguments, in this case: a handler
      async () => {
        return copyAllImagesToS3(event.data.imageURLs);
    });
  }
);
```

#### Go

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	// config
	inngestgo.FunctionOpts{
		ID: "import-product-images",
	},
	// trigger (event or cron)
	inngestgo.EventTrigger("shop/product.imported", nil),
	// handler function
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Here goes the business logic
		// By wrapping code in steps, it will be retried automatically on failure
		s3Urls, err := step.Run("copy-images-to-s3", func() ([]string, error) {
			return copyAllImagesToS3(input.Event.Data["imageURLs"].([]string))
		})
		if err != nil {
			return nil, err
		}

		return nil, nil
	},
)
```

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="import-product-images",
    event="shop/product.imported"
)
async def import_product_images(ctx: inngest.Context):
    uploaded_image_urls = await ctx.step.run(
        # step ID
        "copy-images-to-s3",
        # other arguments, in this case: a handler
        lambda: copy_all_images_to_s3(ctx.event.data["image_urls"])
    )
```

The ID is also used to identify the function in the Inngest system.

Inngest's SDK also records a counter for each unique step ID. The counter increases every time the same step is called. This allows you to run the same step in a loop, without changing the ID.

> **Callout:** Please note that each step is executed as a separate HTTP request. To ensure efficient and correct execution, place any non-deterministic logic (such as DB calls or API calls) within a step.run() call.

## Available Step Methods

### step.run()

This method executes a defined piece of code. Code within `step.run()` is automatically retried if it throws an error. When `step.run()` finishes successfully, the response is saved in the function run state and the step will not re-run.

Use it to run synchronous or asynchronous code as a retriable step in your function.

#### TypeScript

```typescript
export default inngest.createFunction(
  { id: "import-product-images" },
  { event: "shop/product.imported" },
  async ({ event, step }) => {
    // Here goes the business logic
    // By wrapping code in steps, it will be retried automatically on failure
    const uploadedImageURLs = await step.run("copy-images-to-s3", async () => {
      return copyAllImagesToS3(event.data.imageURLs);
    });
  }
);
```

#### Go

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "import-product-images",
	},
	inngestgo.EventTrigger("shop/product.imported", nil),
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Here goes the business logic
		// By wrapping code in steps, it will be retried automatically on failure
		s3Urls, err := step.Run("copy-images-to-s3", func() ([]string, error) {
			return copyAllImagesToS3(input.Event.Data["imageURLs"].([]string))
		})
		if err != nil {
			return nil, err
		}

		return nil, nil
	},
)
```

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="import-product-images",
    event="shop/product.imported"
)
async def import_product_images(ctx: inngest.Context):
    # Here goes the business logic
    # By wrapping code in steps, it will be retried automatically on failure
    uploaded_image_urls = await ctx.step.run(
        # step ID
        "copy-images-to-s3",
        # other arguments, in this case: a handler
        lambda: copy_all_images_to_s3(ctx.event.data["image_urls"])
    )
```

> **Callout:** step.run() acts as a code-level transaction. The entire step must succeed to complete.

### step.sleep()

This method pauses execution for a specified duration. Even though it seems like a `setInterval`, your function does not run for that time (you don't use any compute). Inngest handles the scheduling for you. Use it to add delays or to wait for a specific amount of time before proceeding. At maximum, functions can sleep for a year (seven days for the [free tier plans](/pricing)).

#### TypeScript

```typescript
export default inngest.createFunction(
  { id: "send-delayed-email" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    await step.sleep("wait-a-couple-of-days", "2d");
    // Do something else
  }
);
```

#### Go

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "send-delayed-email",
	},
	inngestgo.EventTrigger("app/user.signup", nil),
	// handler function
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		step.Sleep("wait-a-couple-of-days", 2*time.Day)
		return nil, nil
	},
)
```

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="send-delayed-email",
    trigger=inngest.TriggerEvent(event="app/user.signup")
)
async def send_delayed_email(ctx: inngest.Context):
    await ctx.step.sleep("wait-a-couple-of-days", datetime.timedelta(days=2))
    # Do something else
```

### step.sleepUntil() / step.sleep\_until()

This method pauses execution until a specific date time. Any date time string in the format accepted by the Date object, for example `YYYY-MM-DD` or `YYYY-MM-DDHH:mm:ss`. At maximum, functions can sleep for a year (seven days for the [free tier plans](/pricing)).

#### TypeScript

```typescript
export default inngest.createFunction(
  { id: "send-scheduled-reminder" },
  { event: "app/reminder.scheduled" },
  async ({ event, step }) => {
    const date = new Date(event.data.remind_at);
    await step.sleepUntil("wait-for-the-date", date);
    // Do something else
  }
);
```

#### Go

Go SDK does not have a `sleepUntil` method. Use `step.Sleep()` with a calculated duration instead.

#### Python

```python
import inngest
from src.inngest.client import inngest_client
from datetime import datetime

@inngest_client.create_function(
    fn_id="send-scheduled-reminder",
    trigger=inngest.TriggerEvent(event="app/reminder.scheduled")
)
async def send_scheduled_reminder(ctx: inngest.Context):
    date = datetime.fromisoformat(ctx.event.data["remind_at"])
    await ctx.step.sleep_until("wait-for-the-date", date)
    # Do something else
```

### step.waitForEvent() / step.wait\_for\_event()

This method pauses the execution until a specific event is received.

#### TypeScript

```typescript
export default inngest.createFunction(
  { id: "send-onboarding-nudge-email" },
  { event: "app/account.created" },
  async ({ event, step }) => {
    const onboardingCompleted = await step.waitForEvent(
      "wait-for-onboarding-completion",
      { event: "app/onboarding.completed", timeout: "3d", if: "event.data.userId == async.data.userId" }
    );
    // Do something else
  }
);
```

#### Go

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/errors"
  "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "send-delayed-email",
	},
	inngestgo.EventTrigger("app/user.signup", nil),
	// handler function
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Sample from the event stream for new events.  The function will stop
		// running and automatically resume when a matching event is found, or if
		// the timeout is reached.
		fn, err := step.WaitForEvent[FunctionCreatedEvent](
			ctx,
			"wait-for-activity",
			step.WaitForEventOpts{
				Name:    "Wait for a function to be created",
				Event:   "api/function.created",
				Timeout: time.Hour * 72,
				// Match events where the user_id is the same in the async sampled event.
				If: inngestgo.StrPtr("event.data.user_id == async.data.user_id"),
			},
		)
		if err == step.ErrEventNotReceived {
			// A function wasn't created within 3 days.  Send a follow-up email.
			_, _ = step.Run(ctx, "follow-up-email", func(ctx context.Context) (any, error) {
				// ...
				return true, nil
			})
			return nil, nil
		}
		return nil, nil
	},
)
```

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="send-onboarding-nudge-email",
    trigger=inngest.TriggerEvent(event="app/account.created")
)
async def send_onboarding_nudge_email(ctx: inngest.Context):
    onboarding_completed = await ctx.step.wait_for_event(
      "wait-for-onboarding-completion",
      event="app/wait_for_event.fulfill",
      if_exp="event.data.user_id == async.data.user_id",
      timeout=datetime.timedelta(days=1),
    );
    # Do something else
```

### step.invoke()

This method is used to asynchronously call another Inngest function ([written in any language SDK](/blog/cross-language-support-with-new-sdks)) and handle the result. Invoking other functions allows you to easily re-use functionality and compose them to create more complex workflows or map-reduce type jobs.

This method comes with its own configuration, which enables defining specific settings like concurrency limits.

#### TypeScript

```typescript
// A function we will call in another place in our app
const computeSquare = inngest.createFunction(
  { id: "compute-square" },
  { event: "calculate/square" },
  async ({ event }) => {
    return { result: event.data.number * event.data.number }; // Result typed as { result: number }
  }
);

// In this function, we'll call `computeSquare`
const mainFunction = inngest.createFunction(
  { id: "main-function" },
  { event: "main/event" },
  async ({ step }) => {
    const square = await step.invoke("compute-square-value", {
      function: computeSquare,
      data: { number: 4 }, // input data is typed, requiring input if it's needed
    });

    return `Square of 4 is ${square.result}.`; // square.result is typed as number
  }
);
```

#### Go

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/errors"
  "github.com/inngest/inngestgo/step"
)

inngestgo.CreateFunction(
	client,
	inngestgo.FunctionOpts{
		ID: "send-delayed-email",
	},
	inngestgo.EventTrigger("app/user.signup", nil),
	// handler function
	func(ctx context.Context, input inngestgo.Input[map[string]any]) (any, error) {
		// Invoke another function and wait for its result
		result, err := step.Invoke[any](
			ctx,
			"invoke-email-function",
			step.InvokeOpts{
				FunctionID: "send-welcome-email",
				// Pass data to the invoked function
				Data: map[string]any{
					"user_id": input.Event.Data["user_id"],
					"email":   input.Event.Data["email"],
				},
				// Optional: Set a concurrency limit
				Concurrency: step.ConcurrencyOpts{
					Limit: 5,
					Key:   "user-{{event.data.user_id}}",
				},
			},
		)
		if err != nil {
			return nil, err
		}
		return result, nil
	},
)
```

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="fn-1",
    trigger=inngest.TriggerEvent(event="app/fn-1"),
)
async def fn_1(ctx: inngest.Context) -> None:
    return "Hello!"

@inngest_client.create_function(
    fn_id="fn-2",
    trigger=inngest.TriggerEvent(event="app/fn-2"),
)
async def fn_2(ctx: inngest.Context) -> None:
    output = await ctx.step.invoke(
        "invoke",
        function=fn_1,
    )

    # Prints "Hello!"
    print(output)
```

### step.sendEvent() / step.send\_event()

This method sends events to Inngest to invoke functions with a matching event. Use `sendEvent()` when you want to trigger other functions, but you do not need to return the result. It is useful for example in [fan-out functions](/docs-markdown/guides/fan-out-jobs).

#### TypeScript

```typescript
export default inngest.createFunction(
  { id: "user-onboarding" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    // Do something
    await step.sendEvent("send-activation-event", {
      name: "app/user.activated",
      data: { userId: event.data.userId },
    });
    // Do something else
  }
);
```

#### Go

Go SDK does not have a dedicated `step.sendEvent()` method. Use the Inngest client's `Send()` method within a `step.Run()` instead.

#### Python

```python
import inngest
from src.inngest.client import inngest_client

@inngest_client.create_function(
    fn_id="my_function",
    trigger=inngest.TriggerEvent(event="app/my_function"),
)
async def fn(ctx: inngest.Context) -> list[str]:
    return await ctx.step.send_event("send", inngest.Event(name="foo"))
```

## Further reading

- [Quick Start](/docs-markdown/getting-started/nextjs-quick-start?ref=docs-inngest-steps): learn how to build complex workflows.
- ["How Inngest functions are executed"](/docs-markdown/learn/how-functions-are-executed): Learn more about Inngest's execution model, including how steps are handled.
- Docs guide: ["Multi-step functions"](/docs-markdown/guides/multi-step-functions).


--------------------------------------------------------------------------------
title: "Security"
source: "https://www.inngest.com/docs/learn/security"
--------------------------------------------------------------------------------

# Security

Security is a primary consideration when moving systems into production.  In this section we'll dive into how Inngest handles security, including endpoint security, encryption, standard practices, and how to add SAML authentication to your account.

## Compliance, audits, and reports

Inngest is [SOC 2 Type II compliant](/blog/soc2-compliant?ref=docs-security). Our company and platform is regularly audited to adhere to the standards of SOC 2. This ensures that we have the necessary controls in place to protect our customers' data and ensure the security and privacy of their information. Our platform and SDKs undergo periodic independent security assessments including penetration testing and red-team simulated attacks.

For more information on our security practices, or to request a copy of our SOC 2 report, please [contact our team](/contact?ref=docs-security).

## Signing keys and SDK security

Firstly, it's important to understand that in production all communication between Inngest and your servers is encrypted via TLS. The SDK also actively mitigates attacks by use of the [signing key](/docs-markdown/platform/signing-keys), a secret pre-shared key unique to each environment. By default, the signing key adds the following:

- **Authentication**: requests to your endpoint are authenticated, ensuring that they originate from Inngest. Inngest SDKs reject all requests that are not authenticated with the signing key.
- **Replay attack prevention:** requests are signed with a timestamp embedded, and old requests are rejected, even if the requests are authenticated correctly.

**It's important that the signing key is kept secret.** If your signing key is exposed, it puts the security of your endpoints at risk. Note that it's possible to [rotate signing keys](/docs-markdown/platform/signing-keys#rotation) with zero downtime.

### Function registration + handshake

Functions are defined and served on your own infrastructure using one of our SDKs. In order to run your functions, they must be [synced](/docs-markdown/apps/cloud), or registered, with your Inngest account. This is required for Inngest to know which functions your application is serving and the configuration of each function. Syncing functions is done via a secure handshake. Here's how the handshake works:

1. After your SDK's endpoint is live, a PUT request to the endpoint initiates a secure handshake with the Inngest servers.
2. The SDK sends function configuration to Inngest's API, with the signing key as a bearer token.
3. The SDK idempotently updates your apps and functions. If there are no changes, nothing happens.

This process is necessary for several reasons, largely as serverless environments are the lowest common denominator. Serverless environments have no default bootup/init process, which means serverless environments can't self-initiate the sync. Secondly, serverless platforms such as AWS Lambda and Vercel create unique URLs for each function deployed, which can't be known ahead of time. The incoming PUT request allows the SDK to introspect the request's URL, which is then used for all function calls.

Note that because the SDK only sends HTTP requests to `api.inngest.com` to complete the sync, it never leaks the signing key to clients attempting registration, keeping your key secure.

## End to end encryption

Inngest runs functions automatically, based off of event data that you send to Inngest. Additionally, Inngest runs steps transactionally, and stores the output of each `step.run` within function state. This may contain regulated, sensitive data.

**If you process sensitive data, we** **strongly recommend, and sometimes require, end-to-end encryption enabled in our SDKs**. [End-to-end encryption is a middleware](/docs-markdown/features/middleware/encryption-middleware) which intercepts requests, responses, and SDK logic on your own servers. With end to end encryption, data is encrypted on your servers with a key that only you have access to. The following applies:

- All data in `event.data.encrypted` is encrypted *before* it leaves your servers. Inngest can never read data in this object.
- All step output and function output is encrypted *before* it leaves your servers. Inngest only receives the encrypted values, and can never read this data. Function state is sent fully encrypted to the SDKs. The SDKs decrypt data on your servers and then resume as usual.

With this enabled, even in the case of unexpected issues your data is encrypted and secure. This greatly improves the security posture for sensitive data.

## SAML

Enterprise users can enable SAML authentication to access their account. In order to enable SAML, you must:

1. Reach out to your account manager and request a SAML integration.
2. From there, we'll request configuration related to your SAML provider. This differs depending on your provider, and may include:
   1. A metadata URL; an SSO URL; An IdP entity ID; an IdP x.509 certificate, and so on.
3. Your account manager will then send you the ACS and Metadata URL used to configure your account.
4. Your account manager will work with you to correctly map attributes to ensure fully functioning sign in.

It's important to note that once SAML is enabled, users **must** sign in via SAML. If you're not on an enterprise plan, [contact us here](/contact?ref=docs-security), and we'll get you set up. There is no additional charge for SAML authentication below 200 users.

## IP Addresses

For security and networking purposes, you may need to know the IP addresses that Inngest uses for outbound requests to your functions and webhooks. These IP addresses are used by Inngest's infrastructure to make authenticated requests to your endpoints.

You can find the current list of IP addresses at:

- [IPv4 addresses](https://www.inngest.com/ips-v4)
- [IPv6 addresses](https://www.inngest.com/ips-v6)

These IP ranges are used for all Inngest function invocations and webhook deliveries. If you need to whitelist these IPs in your firewall or security groups, please use the complete ranges listed on these pages.


--------------------------------------------------------------------------------
title: "Setting up your Inngest app"
source: "https://www.inngest.com/docs/learn/serving-inngest-functions"
--------------------------------------------------------------------------------

# Setting up your Inngest app

With Inngest, you define functions or workflows using the SDK and deploy them to whatever platform or cloud provider you want including including serverless and container runtimes.

For Inngest to remotely execute your functions, you will need to set up a connection between your app and Inngest. This can be done in one of two ways:

**serve()**: [Serve your Inngest functions by creating an HTTP endpoint in your application.Ideal for:Serverless platforms like Vercel, Lambda, etc.
Adding Inngest to an existing API.
Zero changes to your CI/CD pipeline](#serving-inngest-functions)

**connect()**: [Connect to Inngest's servers using out-bound WebSocket connection.Ideal for:Container runtimes (Kubernetes, Docker, etc.)
Latency sensitive applications
Horizontal scaling with workers](/docs-markdown/setup/connect)

Inngest functions are portable, so you can migrate between `serve()` and `connect()` as well as cloud providers.

## Serving Inngest functions

#### TypeScript

Inngest provides a `serve()` handler which adds an API endpoint to your router. You expose your functions to Inngest through this HTTP endpoint. To make automated deploys much easier, **the endpoint needs to be defined at `/api/inngest`** (though you can [change the API path](/docs-markdown/reference/serve#serve-client-functions-options)).

```ts {{ title: "./api/inngest.ts" }}
// All serve handlers have the same arguments:
serve({
  client: inngest, // a client created with new Inngest()
  functions: [fnA, fnB], // an array of Inngest functions to serve, created with inngest.createFunction()
  /* Optional extra configuration */
});
```

## Supported frameworks and platforms

- [Astro](#framework-astro)
- [AWS Lambda](#framework-aws-lambda)
- [Bun](#bun-serve)
- [Cloudflare Pages](#framework-cloudflare-pages-functions)
- [Cloudflare Workers](#framework-cloudflare-workers)
- [DigitalOcean Functions](#framework-digital-ocean-functions)
- [ElysiaJS](#framework-elysia-js)
- [Express](#framework-express)

* [Fastify](#framework-fastify)
* [Fresh (Deno)](#framework-fresh-deno)
* [Google Cloud Run Functions](#framework-google-cloud-run-functions)
* [Firebase Cloud functions](#framework-firebase-cloud-functions)
* [H3](#framework-h3)
* [Hono](#framework-hono)
* [Koa](#framework-koa)
* [NestJS](#framework-nest-js)

- [Next.js](#framework-next-js)
- [Nitro](#framework-nitro)
- [Nuxt](#framework-nuxt)
- [Redwood](#framework-redwood)
- [Remix](#framework-remix)
- [Supabase Edge Functions](#framework-supabase-edge-functions)
- [SvelteKit](#framework-svelte-kit)
- [Tanstack Start](#framework-tanstack-start)

You can also create a custom serve handler for any framework or platform not listed here - [read more here](#custom-frameworks).

> **Callout:** Want us to add support for another framework? Open an issue on GitHub or tell us about it on our Discord.

### Framework: Astro&#x20;

Add the following to `./src/pages/api/inngest.ts`:

```ts {{ title: "v3" }}
import { serve } from "inngest/astro";
import { functions, inngest } from "../../inngest";

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions,
});
```

See the [Astro example](https://github.com/inngest/inngest-js/tree/main/examples/framework-astro) for more information.

### Framework: AWS Lambda&#x20;

We recommend using [Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/lambda-urls.html) to trigger your functions, as these require no other configuration or cost.

Alternatively, you can use an API Gateway to route requests to your Lambda. The handler supports [API Gateway V1](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html) and [API Gateway V2](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html). If you are running API Gateway behind a proxy or have some other configuration, you may have to specify the `serveHost` and `servePath` options when calling `serve()` to ensure Inngest knows the URL where you are serving your functions. See [Configuring the API path](/docs-markdown/reference/serve#serve-client-functions-options) for more details.

```ts {{ title: "v3" }}
import { serve } from "inngest/lambda";
import { inngest } from "./client";
import fnA from "./fnA"; // Your own function

export const handler = serve({
  client: inngest,
  functions: [fnA],
});
```

```ts {{ title: "v2" }}
import { serve } from "inngest/lambda";
import { inngest } from "./client";
import fnA from "./fnA"; // Your own function

export const handler = serve(inngest, [fnA]);
```

### Bun.serve()

You can use the `inngest/bun` handler with `Bun.serve()` for a lightweight
Inngest server:

```ts {{ title: "index.ts" }}
import { serve } from "inngest/bun";
import { functions, inngest } from "./inngest";

Bun.serve({
  port: 3000,
  routes: {
    // ...other routes...
    "/api/inngest": serve({ client: inngest, functions }),
  },
});
```

See the [Bun example](https://github.com/inngest/inngest-js/tree/main/examples/bun) for more information.

### Framework: Cloudflare Pages Functions

You can import the Inngest API server when using Cloudflare pages functions  within `/functions/api/inngest.js`:

```ts {{ title: "v3" }}
import { serve } from "inngest/cloudflare";
import { inngest } from "../../inngest/client";
import fnA from "../../inngest/fnA"; // Your own function

export const onRequest = serve({
  client: inngest,
  functions: [fnA],
});
```

```ts {{ title: "v2" }}
import { serve } from "inngest/cloudflare";
import { inngest } from "../../inngest/client";
import fnA from "../../inngest/fnA"; // Your own function

export const onRequest = serve({
  client: inngest,
  functions: [fnA],
});
```

### Framework: Cloudflare Workers&#x20;

You can export `"inngest/cloudflare"`'s `serve()` as your Cloudflare Worker:

```ts
import { serve } from "inngest/cloudflare";
import { inngest } from "./client";
import fnA from "./fnA";

export default {
  fetch: serve({
    client: inngest,
    functions: [fnA],
    // We suggest explicitly defining the path to serve Inngest functions
    servePath: "/api/inngest",
  }),
};
```

> **Tip:** To automatically pass environment variables defined with Wrangler to Inngest function handlers, use the Cloudflare Workers bindings middleware.

#### Local development with Wrangler

When developing locally with Wrangler and the `--remote` flag, your code is
deployed and run remotely. To use this with a local Inngest Dev Server, you must
use a tool such as [ngrok](https://ngrok.com/) or
[localtunnel](https://theboroer.github.io/localtunnel-www/) to allow access to
the Dev Server from the internet.

```sh
ngrok http 8288
```

```toml {{ title: "wrangler.toml" }}
[vars]
# The URL of your tunnel. This enables the "cloud" worker to access the local Dev Server
INNGEST_DEV = "https://YOUR_TUNNEL_URL.ngrok.app"
# This may be needed:
# The URL of your local server. This enables the Dev Server to access the app at this local URL
# You may have to change this URL to match your local server if running on a different port.
# Without this, the "cloud" worker may attempt to redirect Inngest to the wrong URL.
INNGEST_SERVE_HOST = "http://localhost:8787"
```

See an example of this in the [Hono framework example on GitHub](https://github.com/inngest/inngest-js/tree/main/examples/framework-hono).

### Framework: DigitalOcean Functions

The DigitalOcean serve function allows you to deploy Inngest to DigitalOcean serverless functions.
Because DigitalOcean does not provide the request URL in its function arguments, you **must** include
the function URL and path when configuring your handler:

```ts {{ title: "v3" }}
import { serve } from "inngest/digitalocean";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

const main = serve({
  client: inngest,
  functions: [fnA],
  // Your digitalocean hostname.  This is required otherwise your functions won't work.
  serveHost: "https://faas-sfo3-your-url.doserverless.co",
  // And your DO path, also required.
  servePath: "/api/v1/web/fn-your-uuid/inngest",
});

// IMPORTANT: Makes the function available as a module in the project.
// This is required for any functions that require external dependencies.
module.exports.main = main;
```

```ts {{ title: "v2" }}
import { serve } from "inngest/digitalocean";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

const main = serve(inngest, [fnA], {
  // Your digitalocean hostname.  This is required otherwise your functions won't work.
  serveHost: "https://faas-sfo3-your-url.doserverless.co",
  // And your DO path, also required.
  servePath: "/api/v1/web/fn-your-uuid/inngest",
});

// IMPORTANT: Makes the function available as a module in the project.
// This is required for any functions that require external dependencies.
module.exports.main = main;
```

Inngest functions can also be deployed to [DigitalOcean's App Platform or Droplets](/docs-markdown/deploy/digital-ocean).

### Framework: ElysiaJS

For [deployment options](https://elysiajs.com/patterns/deploy.html), Elysia can compile to a binary or to JavaScript, or you can deploy with Docker or Railway.

```ts {{ title: "src/index.ts" }}
import { Elysia } from "elysia";
import { serve } from "inngest/bun";
import { functions, inngest } from "./inngest";

const handler = serve({
  client: inngest,
  functions,
});

const inngestHandler = new Elysia().all("/api/inngest", ({ request }) =>
  handler(request)
);

// register the handler with Elysia
const app = new Elysia()
.use(inngestHandler)

```

Elysia's `use` function expects a single argument. We make use of the `all` method for the inngest api route to handle the expected
methods and then get the request off of the context object passed to elysia handlers.

See the [ElysiaJS
example](https://github.com/inngest/inngest-js/tree/main/examples/framework-elysiajs)
for more information.

### Framework: Express

You can serve Inngest functions within your existing Express app, deployed to any hosting provider
like Render, Fly, AWS, K8S, and others:

```ts {{ title: "v3" }}
import { serve } from "inngest/express";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

// Important:  ensure you add JSON middleware to process incoming JSON POST payloads.
app.use(express.json());
app.use(
  // Expose the middleware on our recommended path at `/api/inngest`.
  "/api/inngest",
  serve({ client: inngest, functions: [fnA] })
);
```

```ts {{ title: "v2" }}
import { serve } from "inngest/express";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

// Important:  ensure you add JSON middleware to process incoming JSON POST payloads.
app.use(express.json());
app.use(
  // Expose the middleware on our recommended path at `/api/inngest`.
  "/api/inngest",
  serve(inngest, [fnA])
);
```

You must ensure you're using the `express.json()` middleware otherwise your functions won't be
executed. **Note** - You may need to set [`express.json()`'s `limit` option](https://expressjs.com/en/5x/api.html#express.json) to something higher than the default `100kb` to support larger event payloads and function state.

See the [Express
example](https://github.com/inngest/inngest-js/tree/main/examples/framework-express)
for more information.

#### Streaming&#x20;

Express can also stream responses back to Inngest, potentially allowing much
longer timeouts.

To enable this, set add the `streaming: "force"` option to your serve handler:

```ts {{ title: "v3" }}
const handler = serve({
  client: inngest,
  functions: [...fns],
  streaming: "force",
});
```

For more information, check out the [Streaming](/docs-markdown/streaming) page.

### Framework: Fastify&#x20;

You can serve Inngest functions within your existing Fastify app.

We recommend using the exported `inngestFastify` plugin, though we also expose a generic `serve()` function if you'd like to manually create a route.

```ts {{ title: "Plugin" }}
import Fastify from "fastify";
import { fastifyPlugin } from "inngest/fastify";
import { inngest, fnA } from "./inngest";

const fastify = Fastify();

fastify.register(fastifyPlugin, {
  client: inngest,
  functions: [fnA],
  options: {},
});

fastify.listen({ port: 3000 }, function (err, address) {
  if (err) {
    fastify.log.error(err);
    process.exit(1);
  }
});
```

```ts {{ title: "Custom route (v3)" }}
import Fastify from "fastify";
import { serve } from "inngest/fastify";
import { fnA, inngest } from "./inngest";

const fastify = Fastify();

fastify.route({
  method: ["GET", "POST", "PUT"],
  handler: serve({ client: inngest, functions: [fnA] }),
  url: "/api/inngest",
});

fastify.listen({ port: 3000 }, function (err, address) {
  if (err) {
    fastify.log.error(err);
    process.exit(1);
  }
});
```

```ts {{ title: "Custom route (v2)" }}
import Fastify from "fastify";
import { serve } from "inngest/fastify";
import { inngest, fnA } from "./inngest";

const fastify = Fastify();

fastify.route({
  method: ["GET", "POST", "PUT"],
  handler: serve(inngest, [fnA]),
  url: "/api/inngest",
});

fastify.listen({ port: 3000 }, function (err, address) {
  if (err) {
    fastify.log.error(err);
    process.exit(1);
  }
});
```

See the [Fastify example](https://github.com/inngest/inngest-js/tree/main/examples/framework-fastify) for more information.

### Framework: Fresh (Deno)

Inngest works with Deno's Fresh
framework via the `esm.sh` CDN.  Add the serve handler to `./api/inngest.ts` as follows:

```ts {{ title: "v3" }}
import { serve } from "https://esm.sh/inngest/deno/fresh";
import { inngest } from "./src/inngest/client.ts";
import fnA from "./src/inngest/fnA"; // Your own function

export const handler = serve({
  client: inngest,
  functions: [fnA],
});
```

```ts {{ title: "v2" }}
import { serve } from "https://esm.sh/inngest/deno/fresh";
import { inngest } from "./src/inngest/client.ts";
import fnA from "./src/inngest/fnA"; // Your own function

export const handler = serve(inngest, [fnA]);
```

### Framework: Google Cloud Run Functions

Google's [Functions Framework](https://github.com/GoogleCloudPlatform/functions-framework-nodejs) has an Express-compatible API which enables you to use the Express serve handler to deploy your Inngest functions to Google Cloud Run. This is an example of a function:

```ts {{ title: "v3" }}
import * as ff from "@google-cloud/functions-framework";
import { serve } from "inngest/express";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

ff.http(
  "inngest",
  serve({
    client: inngest,
    functions: [fnA],
    servePath: "/",
  })
);
```

```ts {{ title: "v2" }}
import * as ff from "@google-cloud/functions-framework";
import { serve } from "inngest/express";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

ff.http(
  'inngest',
  serve(
    inngest,
    [fnA],
    { servePath: "/" },
  )
);
```

You can run this locally with `npx @google-cloud/functions-framework --target=inngest` which will serve your Inngest functions on port `8080`.

See the [Google Cloud Functions example](https://github.com/inngest/inngest-js/tree/main/examples/framework-google-functions-framework) for more information.

> **Callout:** 1st generation Cloud Run Functions are not officially supported. Using one may result in a signature verification error.

### Framework: Firebase Cloud Functions

Based on the Google Cloud Function architecture, the Firebase Cloud Functions provide a different API to serve functions using `onRequest`:

```typescript
import { onRequest } from "firebase-functions/v2/https";

import { serve } from "inngest/express";
import { inngest as inngestClient } from "./inngest/client";

export const inngest = onRequest(
  serve({
    client: inngestClient,
    functions: [/* ...functions... */],
  })
);
```

> **Callout:** Firebase Cloud Functions require configuring INNGEST\_SERVE\_PATH with the custom function path.For example, for a project named inngest-firebase-functions deployed on the us-central1 region, the INNGEST\_SERVE\_PATH value will be as follows\:/inngest-firebase-functions/us-central1/inngest/

To serve your Firebase Cloud Function locally, use the following command:

```bash
firebase emulators:start
```

Please note that you'll need to start your Inngest Local Dev Server with the `-u` flag to match our Firebase Cloud Function's custom path  as follows:

```bash
npx --ignore-scripts=false inngest-cli@latest dev -u http://127.0.0.1:5001/inngest-firebase-functions/us-central1/inngest
```

*The above command example features a project named `inngest-firebase-functions` deployed on the `us-central1` region*.

### Framework: H3&#x20;

Inngest supports [H3](https://github.com/unjs/h3) and frameworks built upon it. Here's a simple H3 server that hosts serves an Inngest function.

```ts {{ title: "v3" }}
import { createApp, eventHandler, toNodeListener } from "h3";
import { serve } from "inngest/h3";
import { createServer } from "node:http";
import { inngest } from "./inngest/client";
import fnA from "./inngest/fnA";

const app = createApp();
app.use(
  "/api/inngest",
  eventHandler(
    serve({
      client: inngest,
      functions: [fnA],
    })
  )
);

createServer(toNodeListener(app)).listen(process.env.PORT || 3000);
```

```ts {{ title: "v2" }}
import { createApp, eventHandler, toNodeListener } from "h3";
import { serve } from "inngest/h3";
import { createServer } from "node:http";
import { inngest } from "./inngest/client";
import fnA from "./inngest/fnA";

const app = createApp();
app.use("/api/inngest", eventHandler(serve(inngest, [fnA])));

createServer(toNodeListener(app)).listen(process.env.PORT || 3000);
```

See the [github.com/unjs/h3](https://github.com/unjs/h3) repository for more information about how to host an H3 endpoint.

### Framework: Hono

Inngest supports the [Hono](https://hono.dev/) framework which is popularly deployed to Cloudflare Workers. Add the following to `./src/index.ts`:

```ts
import { Hono } from "hono";
import { serve } from "inngest/hono";
import { functions, inngest } from "./inngest";

const app = new Hono();

app.on(
  ["GET", "PUT", "POST"],
  "/api/inngest",
  serve({
    client: inngest,
    functions,
  })
);

export default app;
```

> **Tip:** To automatically pass environment variables defined with Wrangler to Inngest function handlers, use the Hono bindings middleware.

> **Info:** If you're using Hono with Cloudflare's Wrangler CLI in "cloud" mode, follow the documentation above for Cloudflare Workers.

See the [Hono example](https://github.com/inngest/inngest-js/blob/main/examples/framework-hono) for more information.

### Framework: Koa&#x20;

Add the following to your routing file:

```ts {{ title: "v3" }}
import { serve } from "inngest/koa";
import Koa from "koa";
import bodyParser from "koa-bodyparser";
import { functions, inngest } from "./inngest";

const app = new Koa();
app.use(bodyParser()); // make sure we're parsing incoming JSON

const handler = serve({
  client: inngest,
  functions,
});

app.use((ctx) => {
  if (ctx.request.path === "/api/inngest") {
    return handler(ctx);
  }
});
```

See the [Koa example](https://github.com/inngest/inngest-js/tree/main/examples/framework-koa) for more information.

### Framework: NestJS

Add the following to `./src/main.ts`:

```ts
import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { serve } from 'inngest/express';

import { inngest } from '@modules/common/inngest/client';
import { getInngestFunctions } from '@modules/common/inngest/functions';

import { AppModule } from './app.module';
import { AppService } from './app.service';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule, {
    bodyParser: true,
  });

  // Setup inngest
  app.useBodyParser('json', { limit: '10mb' });

  // Inject Dependencies into inngest functions

  const logger = app.get(Logger);
  const appService = app.get(AppService);

  // Pass dependencies into this function
  const inngestFunctions = getInngestFunctions({
    appService,
    logger,
  });

  // Register inngest endpoint
  app.use(
    '/api/inngest',
    serve({
      client: inngest,
      functions: inngestFunctions,
    }),
  );

  // Start listening for http requests
  await app.listen(3000);
}

bootstrap();
```

See the [NestJS example](https://github.com/inngest/inngest-js/tree/main/examples/framework-nestjs) for more information.

### Framework: Next.js

Inngest has first class support for Next.js API routes, allowing you to easily create the Inngest API. Both the App Router and the Pages Router are supported. For the App Router, Inngest requires `GET`, `POST`, and `PUT` methods.

```typescript {{ title: "App Router" }}
// src/app/api/inngest/route.ts
import { serve } from "inngest/next";
import { inngest } from "../../../inngest/client";
import fnA from "../../../inngest/fnA"; // Your own functions

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [fnA],
});
```

```typescript {{ title: "Pages Router" }}
// pages/api/inngest.ts
import { serve } from "inngest/next";
import { inngest } from "../../inngest/client";
import fnA from "../../inngest/fnA"; // Your own function

export default serve({
  client: inngest,
  functions: [fnA],
});
```

#### Streaming&#x20;

Next.js Functions hosted on [Vercel](/docs-markdown/deploy/vercel) with Fluid compute can stream responses back to Inngest which can help you reach the maximum duration of 800s (13m20s) provided you are on a paid Vercel plan.

To enable this, add the `streaming: "force"` option to your serve handler:

**Next.js 13+ on Fluid compute**

```ts
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [...fns],
  streaming: "force",
});
```

**Edge runtime**

If you are not using Vercel Fluid compute, you can also stream responses to Inngest by running on their [edge runtime](https://vercel.com/docs-markdown/functions/runtimes/edge).

To enable this, set your runtime to `"edge"` and add the `streaming: "allow"` option to your serve handler:

**Next.js 13+**

```ts
export const runtime = "edge";

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [...fns],
  streaming: "allow",
});
```

**Older versions (Next.js 12)**

```ts {{ title: "v3" }}
export const config = {
  runtime: "edge",
};

const handler = serve({
  client: inngest,
  functions: [...fns],
  streaming: "allow",
});
```

```ts {{ title: "v2" }}
export const config = {
  runtime: "edge",
};

const handler = serve(inngest, [...fns], {
  streaming: "allow",
});
```

For more information, check out the [Streaming](/docs-markdown/streaming) page.

### Framework: Nitro&#x20;

Add the following to `./server/routes/api/inngest.ts`:

```ts
import { serve } from "inngest/nitro";
import { inngest } from "~~/inngest/client";
import fnA from "~~/inngest/fnA"; // Your own function

export default eventHandler(
  serve({
    client: inngest,
    functions: [fnA],
  })
);
```

See the [Nitro example](https://github.com/inngest/inngest-js/tree/main/examples/framework-nitro) for more information.

### Framework: Nuxt&#x20;

Inngest has first class support for [Nuxt server routes](https://nuxt.com/docs-markdown/guide/directory-structure/server#server-routes), allowing you to easily create the Inngest API.

Add the following within `./server/api/inngest.ts`:

```ts {{ title: "v3" }}
import { serve } from "inngest/nuxt";
import { inngest } from "~~/inngest/client";
import fnA from "~~/inngest/fnA"; // Your own function

export default defineEventHandler(
  serve({
    client: inngest,
    functions: [fnA],
  })
);
```

```ts {{ title: "v2" }}
import { serve } from "inngest/nuxt";
import { inngest } from "~~/inngest/client";
import fnA from "~~/inngest/fnA"; // Your own function

export default defineEventHandler(
  serve(inngest, [fnA])
);
```

See the [Nuxt example](https://github.com/inngest/inngest-js/tree/main/examples/framework-nuxt) for more information.

### Framework: Redwood

Add the following to `api/src/functions/inngest.ts`:

```ts {{ title: "v3" }}
import { serve } from "inngest/redwood";
import { inngest } from "src/inngest/client";
import fnA from "src/inngest/fnA"; // Your own function

export const handler = serve({
  client: inngest,
  functions: [fnA],
  servePath: "/api/inngest",
});
```

```ts {{ title: "v2" }}
import { serve } from "inngest/redwood";
import { inngest } from "src/inngest/client";
import fnA from "src/inngest/fnA"; // Your own function

export const handler = serve(
  inngest,
  [fnA],
  { servePath: "/api/inngest" }
);
```

You should also update your `redwood.toml` to add `apiUrl = "/api"`, ensuring your API is served
at the `/api` root.

### Framework: Remix

Add the following to `./app/routes/api.inngest.ts`:

```ts {{ title: "v3" }}
// app/routes/api.inngest.ts
import { serve } from "inngest/remix";
import { inngest } from "~/inngest/client";
import fnA from "~/inngest/fnA";

const handler = serve({
  client: inngest,
  functions: [fnA],
});

export { handler as action, handler as loader };
```

```ts {{ title: "v2" }}
// app/routes/api.inngest.ts
import { serve } from "inngest/remix";
import { inngest } from "~/inngest/client";
import fnA from "~/inngest/fnA";

const handler = serve(inngest, [fnA]);

export { handler as loader, handler as action };
```

See the [Remix example](https://github.com/inngest/inngest-js/tree/main/examples/framework-remix) for more information.

#### Streaming&#x20;

Remix Edge Functions hosted on [Vercel](/docs-markdown/deploy/vercel) can also stream responses back to Inngest, giving you a much higher request timeout of 15 minutes (up from 10 seconds on the Vercel Hobby plan!).

To enable this, set your runtime to `"edge"` (see [Quickstart for Using Edge Functions | Vercel Docs](https://vercel.com/docs-markdown/concepts/functions/edge-functions/quickstart)) and add the `streaming: "allow"` option to your serve handler:

```ts {{ title: "v3" }}
export const config = {
  runtime: "edge",
};

const handler = serve({
  client: inngest,
  functions: [...fns],
  streaming: "allow",
});
```

```ts {{ title: "v2" }}
export const config = {
  runtime: "edge",
};

const handler = serve(inngest, [...fns], {
  streaming: "allow",
});
```

For more information, check out the [Streaming](/docs-markdown/streaming) page.

### Framework: Supabase Edge Functions

Supabase Edge Functions can use our `inngest/edge` package.

```ts
import { serve } from "https://esm.sh/inngest/edge";
import { inngest } from "./src/inngest/client";
import fnA from "./src/inngest/fnA"; // Your own function

Deno.serve(serve({
  client: inngest,
  functions: [fnA],
  servePath: "/functions/v1/your-function-name",
}));
```

Ensure that `servePath` matches your Supabase Edge Function name. Alternatively, you can set this with the `INNGEST_SERVE_PATH` environment variable. This is necessary because Supabase Edge Functions rewrite the request path.

### Framework: Firebase Cloud Functions

Based on the Google Cloud Function architecture, the Firebase Cloud Functions provide a different API to serve functions using `onRequest`:

```typescript
import { onRequest } from "firebase-functions/v2/https";

import { serve } from "inngest/express";
import { inngest as inngestClient } from "./inngest/client";

export const inngest = onRequest(
  serve({
    client: inngestClient,
    functions: [/* ...functions... */],
  })
);
```

### Framework: SvelteKit&#x20;

Add the following to `./src/routes/api/inngest/+server.ts`:

```ts {{ title: "v3" }}
import { functions, inngest } from '$lib/inngest';
import { serve } from 'inngest/sveltekit';

const inngestServe = serve({ client: inngest, functions });
export const GET = inngestServe.GET;
export const POST = inngestServe.POST;
export const PUT = inngestServe.PUT;
```

See the [SvelteKit example](https://github.com/inngest/inngest-js/tree/main/examples/framework-sveltekit) for more information.

### Framework: Tanstack Start

Add the following to `./src/routes/api/inngest.ts`:

```ts
import { createFileRoute } from "@tanstack/react-router";
import { serve } from "inngest/edge";
import { inngest, functions } from "../../inngest";

const handler = serve({ client: inngest, functions });

export const Route = createFileRoute("/api/inngest")({
  server: {
    handlers: {
      GET: async ({ request }) => handler(request),
      POST: async ({ request }) => handler(request),
      PUT: async ({ request }) => handler(request),
    },
  },
});

```

See the [Tanstack Start example](https://github.com/inngest/inngest-js/tree/main/examples/framework-tanstack-start) for more information.

### Custom frameworks

If the framework that your application uses is not included in the above list of first-party supported frameworks, you can create a custom `serve` handler.

To create your own handler, check out the [example handler](https://github.com/inngest/inngest-js/blob/main/packages/inngest/src/test/functions/handler.ts) in our SDK's open source repository to understand how it works. Here's an example of a custom handler being created and used:

```ts
import { Inngest, InngestCommHandler, type ServeHandlerOptions } from "inngest";

const serve = (options: ServeHandlerOptions) => {
  const handler = new InngestCommHandler({
    frameworkName: "edge",
    fetch: fetch.bind(globalThis),
    ...options,
    handler: (req: Request) => {
      return {
        body: () => req.json(),
        headers: (key) => req.headers.get(key),
        method: () => req.method,
        url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
        transformResponse: ({ body, status, headers }) => {
          return new Response(body, { status, headers });
        },
      };
    },
  });

  return handler.createHandler();
};

const inngest = new Inngest({ id: "example-edge-app" });

const fn = inngest.createFunction(
  { id: "hello-world" },
  { event: "test/hello.world" },
  () => "Hello, World!"
);

export default serve({ client: inngest, functions: [fn] });
```

#### Go

Inngest enables you to create a HTTP handler for your functions. This handler will be used to serve your functions over HTTP (compatible with `net/http`).

```go {{ title: "Go (HTTP)" }}
package main

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/inngest/inngestgo"
	"github.com/inngest/inngestgo/step"
)

func main() {
	client, err := inngestgo.NewClient(inngestgo.ClientOpts{
		AppID: "core",
	})
	if err != nil {
		panic(err)
	}
	_, err = inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{
			ID:   "account-created",
			Name: "Account creation flow",
		},
		// Run on every api/account.created event.
		inngestgo.EventTrigger("api/account.created", nil),
		AccountCreated,
	)
	if err != nil {
		panic(err)
	}
	http.ListenAndServe(":8080", client.Serve())
}
```

#### Python

You expose your functions to Inngest through this HTTP endpoint.
Inngest provides integrations with Flask and FastAPI.

```python {{ title: "Python (Flask)" }}
import logging
import inngest
from src.flask import app
import inngest.flask

logger = logging.getLogger(f"{app.logger.name}.inngest")
logger.setLevel(logging.DEBUG)

inngest_client = inngest.Inngest(app_id="flask_example", logger=logger)

@inngest_client.create_function(
    fn_id="hello-world",
    trigger=inngest.TriggerEvent(event="say-hello"),
)
def hello(ctx: inngest.ContextSync) -> str:

inngest.flask.serve(
    app,
    inngest_client,
    [hello],
)

app.run(port=8000)
```

```python {{ title: "Python (FastAPI)" }}
import logging
import inngest
import fastapi
import inngest.fast_api

logger = logging.getLogger("uvicorn.inngest")
logger.setLevel(logging.DEBUG)

inngest_client = inngest.Inngest(app_id="fast_api_example", logger=logger)

@inngest_client.create_function(
    fn_id="hello-world",
    trigger=inngest.TriggerEvent(event="say-hello"),
)
async def hello(ctx: inngest.Context) -> str:
    return "Hello world!"

app = fastapi.FastAPI()

inngest.fast_api.serve(
    app,
    inngest_client,
    [hello],
)
```

### Signing key

You'll need to assign your [signing key](/docs-markdown/platform/signing-keys) to an [`INNGEST_SIGNING_KEY`](/docs-markdown/sdk/environment-variables#inngest-signing-key) environment variable in your hosting
provider or `.env` file locally, which lets the SDK securely communicate with Inngest. If you can't
provide this as a signing key, you can pass it in to `serve` when setting up your framework. [Read
the reference for more information](/docs-markdown/sdk/reference/serve#reference).

### Other configuration

When using `serve`, allow requests up to 4 MB in size. This is the maximum request size that Inngest will send to your app. Configurating maximum request size is framework-specific, so check the documentation for your framework for more information.

## Reference

For more information about the `serve` handler, read the [the reference guide](/docs-markdown/reference/serve), which includes:

- [`serve()` configuration options](/docs-markdown/reference/serve#serve-client-functions-options)
- [How the serve handler works](/docs-markdown/reference/serve#how-the-serve-api-handler-works)


--------------------------------------------------------------------------------
title: "Versioning"
source: "https://www.inngest.com/docs/learn/versioning"
--------------------------------------------------------------------------------

# Versioning

Long-running functions inevitably change over time. Inngest enables developers to implement multiple strategies for changing long-running code over time. To manage these changes effectively, it's crucial to understand how the SDK implements determinism and [executes steps](/docs-markdown/learn/how-functions-are-executed).

## Determinism in functions

Determinism is consistent in *every* Inngest language SDK. Except for language-specific idioms, all SDKs implement the same logic. In every SDK, functions in Inngest are a series of steps. Each step runs reliably, will retry on failure, and is as close to exactly-once execution as possible (excluding outbound network failures when reporting completed steps).

### How the SDK works with steps

As covered in [*How Inngest functions are executed*](/docs-markdown/learn/how-functions-are-executed), each step in a function has a unique identifier, represented as a string. Each time a step is found, the SDK checks whether the step has been executed. It does this by:

1. Hashing the step's unique identifier along with a counter of the number of times the step has been called. This enables steps to be used in a loop.
2. Looking up the resulting hash in function run state.
   1. If the hash is present, the step has been executed. The SDK returns the memoized state and skips execution.
   2. If the hash isn't found, the SDK executes the step and returns the output to Inngest to be stored in the function run state.

After a step completes, the function execution immediately ends. The function is re-executed from the top with the updated memoized state until the function completes.

### Handling determinism

The SDK handles determinism *gracefully* by default. The SDK keeps track of the order in which every step is executed. If new steps are added, they're executed when they're first discovered. This means that:

- The SDK always knows if functions are deterministic, even over months or years.
- **New steps, or steps with changed IDs, are executed when they're discovered.** If the order of step executions change, a warning is logged by default. Logging a warning allows you to comfortably extend and improve functions over time, without worrying about in-progress functions failing completely or panicking.

## Change management across versions

Given the above, there are a few strategies for change management:

- **Adding new steps to a function is generally safe.** New steps will be executed when the functions re-run (after a step completes). Imagine a function has steps `[A, B, C]`. When you add a new step `Z` in-between the first steps, the executor will run steps `[A, Z, B, C]` and log a warning. The caveat here is that you must take care to ensure that the new step can run out-of-order and doesn't reference undefined variables. Note that step `B` and `C` will *not* automatically re-run. Instead, a warning will be logged by default. You can change logging a warning and instead permanently fail by enabling strict mode. Failing runs permanently is acceptable, and you can use [Replay](/docs-markdown/platform/replay) to bulk-replay permanent failures.
- **Forcing steps to re-run by changing step IDs.** This changes the hash, which forces re-evaluation as the step's state is not found. Note that the SDK will log a warning by default as the order of step execution changes. If you change step `C`'s ID to `E`, your run's state will expect steps `[A, B, C]` to run and instead will see `[A, B, E]`.
- **For complete changes in logic, create a new function which subscribes to the same triggering event**. Update the existing function's trigger to include an [`if` expression](/docs-markdown/reference/functions/create#trigger) to only handle events before a certain [timestamp](/docs-markdown/events#event-payload-format) (for example: `event.ts < ${EPOCH_MS}`). Then create a new function with the updated logic, the same original event trigger, and a new `id` (for example: `process-upload-v2`). This allows you to safely transition to the new function without losing any data. A caveat is that this creates a new function in your app and therefore the Inngest dashboard.

## Conclusion

Understanding how determinism works should allow you to gracefully evolve functions over time. Consider these strategies when making changes to long-running functions to ensure that they can run successfully to completion over time.


--------------------------------------------------------------------------------
title: "Local development"
source: "https://www.inngest.com/docs/local-development"
--------------------------------------------------------------------------------

# Local development

Inngest's tooling makes it easy to develop your functions locally with any framework using the Inngest Dev Server.

The Inngest Dev Server is a fully-featured and [open-source](https://github.com/inngest/inngest) local version of the [Inngest Platform](/docs-markdown/platform/deployment) enabling a seamless transition from your local development to feature, staging and production environments.

![Dev Server Demo](/assets/docs-markdown/local-development/dev-server-demo-2025-01-15.gif)

## Getting started

You can start the dev server with a single command. The dev server will attempt to find an Inngest `serve` API endpoint by scanning ports and endpoints that are commonly used for this purpose (See "[Auto-discovery](#auto-discovery)"). Alternatively, you can specify the URL of the `serve` endpoint:

```shell {{ title: "npx (npm)" }}
npx --ignore-scripts=false inngest-cli@latest dev
# You can specify the URL of your development `serve` API endpoint
npx --ignore-scripts=false inngest-cli@latest dev -u http://localhost:3000/api/inngest
```

```shell {{ title: "Docker" }}
docker run -p 8288:8288 inngest/inngest \
  inngest dev -u http://host.docker.internal:3000/api/inngest
```

You can now open the dev server's browser interface on [`http://localhost:8288`](http://localhost:8288).

## Connecting apps to the Dev Server

There are two ways to connect apps to the Dev Server:

1. **Automatically**: The Dev Server will attempt to "auto-discover" apps running on common ports and endpoints (See "[Auto-discovery](#auto-discovery)").
2. **Manually**: You scan explicitly add the URL of the app to the Dev Server using one of the following options:
   - Using the CLI `-u` param (ex. `npx --ignore-scripts=false inngest-cli@latest dev -u http://localhost:3000/api/inngest`)
   - Adding the URL in the Dev Server Apps page. You can edit the URL or delete a manually added app at any point in time
   - Using the `inngest.json` (or similar) configuration file (See "[Configuration file](#configuration-file)")

![Dev Server demo manually syncing an app](/assets/docs-markdown/local-development/dev-server-apps-demo-2025-01-15.gif)

> **Tip:** The dev server does "auto-discovery" which scans popular ports and endpoints like /api/inngest and /.netlify/functions/inngest. If you would like to disable auto-discovery, pass the --no-discovery flag to the dev command. Learn more about this below

### How functions are loaded by the Dev Server

The dev server polls your app locally for any new or changed functions. Then as events are sent, the dev server calls your functions directly, just as Inngest would do in production over the public internet.

## Testing functions

### Invoke via UI

From the Functions tab, you can quickly test any function by click the "Invoke" button and providing the data for your payload in the modal that pops up there. This is the easiest way to directly call a specific function:

### Sending events to the Dev Server

There are different ways that you can send events to the dev server when testing locally:

1. Using the Inngest SDK
2. Using the "Test Event" button in the Dev Server's interface
3. Via HTTP request (e.g. curl)

#### Using the Inngest SDK

When using the Inngest SDK locally, it tries to detect if the dev server is running on your machine. If it's running, the event will be sent there.

```ts {{ title: "Node.js" }}
import { Inngest } from "inngest";

const inngest = new Inngest({ id: "my_app" });
await inngest.send({
  name: "user.avatar.uploaded",
  data: { url: "https://a-bucket.s3.us-west-2.amazonaws.com/..." },
});
```

```python {{ title: "Python" }}
from inngest import Inngest

inngest_client = inngest.Inngest(app_id="my_app")
await inngest_client.send(
  name="user.avatar.uploaded",
  data={"url": "https://a-bucket.s3.us-west-2.amazonaws.com/..."},
)
```

```go {{ title: "Go" }}
import (
	"context"

	"github.com/inngest/inngestgo"
)

func main() {
	client, _ := inngestgo.NewClient(inngestgo.ClientOpts{
		AppID: "my_app",
	})

	client.Send(context.Background(), inngestgo.Event{
		Name: "user.avatar.uploaded",
		Data: map[string]any{"url": "https://a-bucket.s3.us-west-2.amazonaws.com/..."},
	})
}
```

**Note** - During local development, you can use a dummy value for your [`INNGEST_EVENT_KEY`](/docs-markdown/sdk/environment-variables#inngest-event-key?ref=local-development) environment variable. The dev server does not validate keys locally.

#### Using the "Test Event" button

The dev server's interface also has a "Test Event" button on the top right that enables you to enter any JSON event payload and send it manually. This is useful for testing out different variants of event payloads with your functions.

#### Via HTTP request

All events are sent to Inngest using a simple HTTP API with a JSON body. Here is an example of a curl request to the local dev server's `/e/<EVENT_KEY>` endpoint running on the default port of `8228` using a dummy event key of `123`:

```shell
curl -X POST -v "http://localhost:8288/e/123" \
  -d '{
    "name": "user.avatar.uploaded",
    "data": { "url": "https://a-bucket.s3.us-west-2.amazonaws.com/..." }
  }'
```

> **Callout:** üí° Since you can send events via HTTP, this means you can send events with any programming language or from your favorite testing tools like Postman.

## Configuration file

When using lots of configuration options or specifying multiple `-u` flags for a project, you can choose to configure the CLI via `inngest.json` configuration file. The `dev` command will start in your current directory and walk up directories until it finds a file. `yaml`, `yml`, `toml`, or `properties` file formats and extensions are also supported. You can list all options with `dev --help`. Here is an example file specifying two app urls and the `no-discovery` option:

```json {{ title: "inngest.json" }}
{
  "sdk-url": [
    "http://localhost:3000/api/inngest",
    "http://localhost:3030/api/inngest"
  ],
  "no-discovery": true
}
```

```yaml {{ title: "inngest.yaml" }}
sdk-url:
  - "http://localhost:3000/api/inngest"
  - "http://localhost:3030/api/inngest"
no-discovery: true
```

## Inngest SDK debug endpoint

The [SDK's `serve` API endpoint](/docs/learn/serving-inngest-functions) will return some diagnostic information for your server configuration when sending a `GET` request. You can do this via `curl` command or by opening the URL in the browser.

Here is an example of a curl request to an Inngest app running at `http://localhost:3000/api/inngest`:

```sh
$ curl -s http://localhost:3000/api/inngest | jq
{
  "message": "Inngest endpoint configured correctly.",
  "hasEventKey": false,
  "hasSigningKey": false,
  "functionsFound": 1
}
```

## Auto-discovery

The dev server will automatically detect and connect to apps running on common ports and endpoints. You can disable auto-discovery by passing the `--no-discovery` flag to the `dev` command:

```sh
npx --ignore-scripts=false inngest-cli@latest dev --no-discovery -u http://localhost:3000/api/inngest
```

```plaintext {{ title: "Common endpoints" }}
/api/inngest
/x/inngest
/.netlify/functions/inngest
/.redwood/functions/inngest
```

```plaintext {{ title: "Common ports" }}
80, 443,
// Rails, Express & Next/Nuxt/Nest routes
3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010,
// Django
5000,
// Vite/SvelteKit
5173,
// Other common ports
8000, 8080, 8081, 8888,
// Redwood
8910, 8911, 8912, 8913, 8914, 8915,
// Cloudflare Workers
8787,
```

## CLI flags

`inngest-cli dev` command supports the following flags:

|  **Long form** | **Short form** | **Type** |                            **Default value**                           |            **Description**            |
| :------------: | :------------: | :------: | :--------------------------------------------------------------------: | :-----------------------------------: |
|    --config    |        -       |  string  |                                    -                                   | Path to an Inngest configuration file |
|     --help     |       -h       |     -    |                                    -                                   |      Output the help information      |
|     --host     |        -       |  string  |                  [http://localhost](http://localhost)                  |          Inngest server host          |
| --no-discovery |        -       |  boolean |                                  false                                 |       Disable app auto-discovery      |
|    --no-poll   |        -       |  boolean |                                  false                                 |  Disable polling of apps for updates  |
|     --port     |       -p       |    int   |                                  8288                                  |          Inngest server port          |
|    --sdk-url   |       -u       |  strings | [http://localhost:3000/api/inngest](http://localhost:3000/api/inngest) |         App serve URLs to sync        |

## Development with Docker

Inngest provides a Docker image that you can use to run the Inngest Dev Server within a container. This is useful when running Inngest locally or in a CI/CD environment.

### Docker image

The [`inngest/inngest`](https://hub.docker.com/r/inngest/inngest) image is available on Docker Hub. Regular updates are made to this image, so we recommend pulling the latest version. You can find the latest version release on [our Github repo](https://github.com/inngest/inngest/releases).

```bash
docker pull inngest/inngest
```

### Standalone Docker container

Docker can be useful for running the Inngest Dev Server in a standalone container. This is useful if you do not want to use the `npx --ignore-scripts=false inngest-cli@latest` method to run the Dev Server.

To run the Inngest container, you'll need to:

1. Expose the Dev Server port (default is `8288`).
2. Use the `inngest dev` command with the `-u` flag to specify the URL where Inngest can find your app.

In this example command, our app is running on the host machine on port `3000`. We use the `host.docker.internal` hostname to connect to the host machine from within the Docker container. For ease of reading, the command is broken up into multiple lines.

```bash
docker run -p 8288:8288 \
  inngest/inngest \
  inngest dev -u http://host.docker.internal:3000/api/inngest
```

You will then be able to access the Inngest Dev Server on your host machine at `http://localhost:8288` or whatever hostname you have configured. You may need to adjust the hostname for your app if you are using a different Docker network setup.

> **Callout:** If you decide to run the Dev Server on another port, you will need to set the INNGEST\_BASE\_URL environment variable in your app to point to the correct port. This value defaults to http\://localhost:8288.

### Docker Compose

If you're using [Docker Compose](https://docs.docker.com/compose/) to run your services locally, you can easily add Inngest to your local environment. Here's an example `docker-compose.yml` file that includes Inngest:

```yaml {{ filename: "docker-compose.yaml" }}
services:
  app:
    build: ./app
    environment:
      - INNGEST_DEV=1
      - INNGEST_BASE_URL=http://inngest:8288
    ports:
      - '3000:3000'
  inngest:
    image: inngest/inngest:v0.27.0
    command: 'inngest dev -u http://app:3000/api/inngest'
    ports:
      - '8288:8288'
```

In this example, we have two services: `app` and `inngest`. The `app` service is your application, and the `inngest` service is the Inngest Dev Server. There are a few key configurations to note:

- The `INNGEST_DEV=1` environment variable tells the Inngest SDK it should connect to the Dev Server\*.
- The `INNGEST_BASE_URL=http://inngest:8288` environment variable tells the Inngest SDK where the Dev Server is running. In our example, the `inngest` service is running on port `8288` (the default Dev Server port).
- The `command: 'inngest dev -u http://app:3000/api/inngest'` command tells the Dev Server where to find your app within the Docker network. In this example, the `app` service is running on port `3000`.
- The `ports` configuration exposes the Dev Server on port `8288` so you can view this on your host machine in the browser.

\* - The `INNGEST_DEV` environment variable was added to the TypeScript SDK in version 3.14. Prior to this version, you can set `NODE_ENV=development` to force the SDK to connect to the Dev Server.

## Development flow

Developing with Inngest looks as it follows:

1. Configure the Inngest SDK in your application
2. [Connecting the Inngest Dev Server to your local application](#connecting-apps-to-the-dev-server)
3. Develop your Inngest Functions with [Steps](/docs-markdown/learn/inngest-steps), [Flow Control](/docs-markdown/guides/flow-control) and [more](/docs-markdown/learn/inngest-functions)
4. *(Optional) - Configure Preview environments with [our Vercel Integration](/docs-markdown/deploy/vercel)*

**Moving to production environments (preview envs, staging or production)**

Deploying your application to preview, staging and production environments does not require any code change:

6. [Create an Inngest App](/docs-markdown/apps) on the Inngest Platform and [configure its Event and Signing Keys on your Cloud](/docs-markdown/platform/deployment).
7. Leverage the Inngest Platform to manage and monitor Events and Function Runs

## SDKs

**TypeScript SDK**: [Setup the Inngest SDK in your TypeScript application.]('/docs/reference/typescript')

**Python SDK**: [Setup the Inngest SDK in your Python application.]('/docs/reference/python')

**Go SDK**: [Setup the Inngest SDK in your Go application.]('https://pkg.go.dev/github.com/inngest/inngestgo')

## FAQs

**Can I run the Inngest Dev Server in production?**: The Inngest Dev Server is not designed to be run in production, but you can run it anywhere that you want including testing environments or CI/CD pipelines.

**How do I test webhooks locally?**: Webhooks configured on the Platform can be sent to the Dev Server.

**How do I work with Stripe or Clerk webhooks locally?**: External webhooks from Stripe and Clerk must go through a tunnel solution (such as ngrok or localtunnel) to reach the Dev Server.

**Are Crons supported locally?**: Yes. You can also trigger a function at any time by using the "Invoke" button from the Dev Server Functions list view.

Find more answers in our [Discord community](/discord).

## Further reference

- [Dev Server source code on GitHub](https://github.com/inngest/inngest)
- [`inngest/inngest` Docker image on Docker Hub](https://hub.docker.com/r/inngest/inngest)
- [TypeScript SDK Environment variable reference](/docs-markdown/sdk/environment-variables)
- [Python SDK Environment variable reference](/docs-markdown/reference/python/overview/env-vars)


--------------------------------------------------------------------------------
title: "Platform Guides"
source: "https://www.inngest.com/docs/platform"
--------------------------------------------------------------------------------

# Platform Guides

Learn how to use the Inngest platform


--------------------------------------------------------------------------------
title: "Deployment"
source: "https://www.inngest.com/docs/platform/deployment"
--------------------------------------------------------------------------------

# Deployment

Moving to production requires deploying your Inngest Functions on your favorite Cloud Provider and configuring it to allow the Inngest Platform to orchestrate runs:

**Deploy on any platform or runtime**: [Inngest Functions can be deployed to any serverless cloud or container running on any server.]('/docs-markdown/apps/cloud#sync-a-new-app-in-inngest-cloud')

**Deploy with Vercel**: [Use our Vercel Integration to deploy your Inngest Functions.]('/docs/deploy/vercel')

**Deploy with DigitalOcean**: [Deploy your Inngest Functions on DigitalOcean.]('/docs/deploy/digital-ocean')

**Deploy with Cloudflare Pages**: [Deploy your Inngest Functions on Cloudflare Pages.]('/docs/deploy/cloudflare')

**Deploy with Render**: [Deploy your Inngest Functions on Render.]('/docs/deploy/render')

**Self-host Inngest**: [Self-host Inngest on your own infrastructure.]('/docs/self-hosting')

## How Inngest handles Function Runs

The Inngest Platform hosts the Inngest Durable Execution Engine, responsible for triggering and maintaining the state of **Function runs happening on your Cloud Provider**:

The Inngest Platform relies on [Event](/docs/events/creating-an-event-key) and [Signing Keys](/docs-markdown/platform/signing-keys), as well as [other security mechanisms](/docs-markdown/learn/security), to communicate securely and reliably with the Inngest SDK.

Learn more on Inngest's Durable Execution Engine in our ["How Inngest Functions are executed" guide](/docs-markdown/learn/how-functions-are-executed).


--------------------------------------------------------------------------------
title: "Environments"
source: "https://www.inngest.com/docs/platform/environments"
--------------------------------------------------------------------------------

# Environments

Inngest accounts all have multiple environments that help support your entire software development lifecycle. Inngest has different types of environments:

- **Production Environment** for all of your production applications, functions and event data.
- [**Branch Environments**](#branch-environments) are sandbox environments that enables developers on your team to test your changes specific to current Git feature branch. These are designed to work with platforms that support branch-based deployment previews like Vercel or Netlify.
- [**Custom Environments**](#custom-environments) are used to create shared, non-production environments like staging, QA, or canary.
- [**Local Environment**](/docs-markdown/local-development) leverages the Inngest Dev Server (`npx --ignore-scripts=false inngest-cli@latest dev`) to test and debug functions on your own machine.

The key things that you need to know about environments:

- Data is isolated within each environment. Event types or functions may share the same name, but their data and logs are fully separated.
- Each environment uses [Event Keys](/docs-markdown/events/creating-an-event-key) and [Signing Keys](/docs-markdown/platform/signing-keys) to securely send data or sync apps within a given environment.
- You can sync multiple applications with each environment.&#x20;
- You are billed for your usage across all environments, *except of course your local environment*.

## Branch Environments

Most developer workflows are centered around branching, whether feature branches or a variant of GitFlow. Inngest's Branch Environments are designed to give you and your team an isolated sandbox for every non-production branch that you deploy. For example,

![Branch Environments mapping to your hosting platform's deployment previews](/assets/docs-markdown/environments/branch-environments-with-your-platform.svg)

Branch deployments:

- Are created on-demand when you send events or register your functions for a given environment
- Share Event Keys and Signing Keys to streamline your developer workflow (see: [Configuring Branch Environments](#configuring-branch-environments))

It can be helpful to visualize the typical Inngest developer workflow using Branch environments and your platform's deploy previews:

![The software development lifecycle from local development to Branch Environments to Production](/assets/docs-markdown/environments/branch-environments-sdlc.svg)

## Configuring Branch Environments

As Branch Environments are created on-demand, all of your Branch Environments share the same Event Keys and Signing Key. This enables you to use the same environment variables in each of your application's deployment preview environments and set the environment dynamically using the `env` option with the `Inngest` client:

```ts {{ title: "TypeScript" }}
const inngest = new Inngest({
  id: "my-app",
  env: process.env.BRANCH,
});
// Alternatively, you can set the INNGEST_ENV environment variable in your app

// Pass the client to the serve handler to complete the setup
serve({ client: inngest, functions: [myFirstFunction, mySecondFunction] });
```

```python {{ title: "Python" }}
import inngest

inngest_client = inngest.Inngest(
    app_id="flask_example",
  env=os.getenv("BRANCH"),
)
```

### Automatically Supported Platforms

The Inngest SDK tries to automatically detect your application's branch and use it to set the `env` option when deploying to certain supported platforms. Here are the platforms that are automatically supported and what environment variable is *automatically* used:

- **Vercel** - `VERCEL_GIT_COMMIT_REF` - This works perfectly with our Vercel integration.

You can always override this using [`INNGEST_ENV`](/docs-markdown/sdk/environment-variables#inngest-env) or by manually passing `env` to the `Inngest` client.

### Other Platforms

Some platforms only pass an environment variable at build time. This means you'll have to explicitly set `env` to the platform's specific environment variable. For example, here's how you would set it on Netlify:

```ts {{ title: "TypeScript" }}
const inngest = new Inngest({
  id: "my-app",
  env: process.env.BRANCH,
});
```

```python {{ title: "Python" }}
import inngest

inngest_client = inngest.Inngest(
    app_id="flask_example",
  env=os.getenv("BRANCH"),
)
```

- **Netlify** - `BRANCH` ([docs](https://docs.netlify.com/configure-builds/environment-variables/#git-metadata))
- **Cloudflare Pages** - `CF_PAGES_BRANCH` ([docs](https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables))
- **Railway** - `RAILWAY_GIT_BRANCH` ([docs](https://docs.railway.app/develop/variables#railway-provided-variables))
- **Render** - `RENDER_GIT_BRANCH` ([docs](https://render.com/docs-markdown/environment-variables#all-services))

### Sending Events to Branch Environments

As all branch environments share Event Keys, all you need to do to send events to your branch environment is set the `env` option with the SDK. This will configure the SDK's `send()` method to automatically route events to the correct environment.

If you are sending events without an Inngest SDK, you'll need to pass the `x-inngest-env` header along with your request. For more information about this and sending events from any environment with **the Event API**, [read the `send()` reference](/docs-markdown/reference/events/send#send-events-via-http-event-api).

### Archiving Branch Environments

By default, branch environments are archived 3 days after their latest deploy. Each time you deploy, the auto archive date is extended by 3 days. Archiving a branch environment doesn't delete anything; it only prevents the environment's functions from triggering.

If you'd like to disable auto archive on a branch environment, click the toggle in the [environments page](https://app.inngest.com/env). There's also a button that lets you manually archive/unarchive branch environments at any time.

### Disabling Branch Environments in Vercel

The recommended way to disable branch environments is through the Vercel UI. Delete the "Preview" Inngest environment variables:
![Vercel environment keys](/assets/docs-markdown/environments/environment-keys.jpg)

## Custom Environments

Many teams have shared environments that are used for non-production purposes like staging, QA, or canary. Inngest's Custom Environments are designed to give you and your team an isolated sandbox for every non-production environment that you deploy.

You can create an environment from the [environments page](https://app.inngest.com/env) in the Inngest dashboard.

Some key things to know about custom environments:

- Each environment has its own keys, event history, and functions. All data is isolated within each environment.
- You can deploy multiple apps to the same environment to fully simulate your production environment.
- You can create as many environments as you need.
- Custom environments execute at a lower priority than production environments, so you may see higher latency.

[Create an environment in the dashboard](https://app.inngest.com/create-environment)

## Viewing and Switching Environments

In the Inngest dashboard you can quickly switch between environments in the environment switcher dropdown in the top navigation. You can click ‚Äú[View All Environments](https://app.inngest.com/env)‚Äù for a high level view of all of your environments.

![The environment switcher dropdown menu in the Inngest dashboard](/assets/docs-markdown/environments/branch-dropdown.png)


--------------------------------------------------------------------------------
title: "Apps"
source: "https://www.inngest.com/docs/platform/manage/apps"
--------------------------------------------------------------------------------

# Apps

Inngest enables you to manage your Inngest Functions deployments via [Inngest Environments and Apps](/docs-markdown/apps). Inngest Environments (ex, production, testing) can contain multiple Apps that can be managed using:

- [The Apps Overview](#apps-overview) - A quick access to all apps, including the unattached syncs
- [Syncs management](#syncs) - Run App diagnostics and access all syncs history
- [Archiving](#archive-an-app) - Archive inactive Apps

## Apps Overview

The Apps Overview is the main entry page of the Inngest Platform, listing the Apps of the active Environment, visible in the top left Environment selector:

![The home page of the Inngest Platform is an Apps listing. Each App item display the App status along with some essential information such as active Functions count and the SDK version used.](/assets/docs-markdown/platform/manage/environments-apps/apps-overview.png)

The Apps Overview provides all the essential information to assess the healthy sync status of your active Apps: Functions identified, Inngest SDK version. You can switch to ‚ÄúArchived Apps‚Äù using the top left selector.

### Unattached Syncs

Automatic syncs or an App misconfiguration can result in syncs failing to attach to an existing app.

These unsuccessful syncs are listed in the ‚ÄúUnattached Syncs‚Äù section where detailed information are available, helping in resolving the issue:

![The Unattached Syncs list provides detailed information regarding failed syncs.](/assets/docs-markdown/platform/manage/environments-apps/unattached-syncs.png)

> **Callout:** Please read our Syncs Troubleshooting section for more information on how to deal with failed sync.

## App management

### Overview

Navigating to an App provides more detailed information (SDK version and language, deployment URL) that can be helpful when interacting with our Support.

You will also find quick access to all active functions and their associated triggers:

![Clicking on an App from the home page will give you more detailed information about the current App deployment such as: the Functions list, the target URL. Those information can be useful when exchanging with Support.](/assets/docs-markdown/platform/manage/environments-apps/app-overview.png)

### Syncs

Triggering a Manual Sync from the Inngest Platform sends requests to your app to fetch the up-to-date configuration of your applications's functions. At any time, access the history of all syncs from the App page:

![The list of an App Syncs provide helpful information to navigate through recent deployments and their associated Functions changes.](/assets/docs-markdown/platform/manage/environments-apps/app-syncs.png)

If a sync fails, try running an App Diagnostic before reaching out to Support:

![A App Diagnostic tool is available to help mitigating any sync issues. You can access it by opening the top left menu from the App Syncs listing page.](/assets/docs-markdown/platform/manage/environments-apps/check-app-health.png)

### Archive an app

Apps can be archived and unarchived at any time. Once an app is archived, all of its functions are archived.

When the app is archived:

- New function runs will not be triggered.
- Existing function runs will continue until completion.
- Functions will be marked as archived, but will still be visible, including their run history.

If you need to cancel all runs prior to completion, read our [cancellation guide](/docs-markdown/guides/cancel-running-functions).

**How to archive an app**

1. Navigate to the app you want to archive. You will find an ‚ÄúArchive‚Äù button at the top-right corner of the page.

![Archiving an app is accessible from an App page by using the top left menu.](/assets/docs-markdown/platform/manage/environments-apps/archive-app.png)

2. Confirm that you want to archive the app by clicking "Yes".

![A confirmation modal will open to confirm the action. Please note that archiving is not an irreversible action.](/assets/docs-markdown/platform/manage/environments-apps/archiving-app.png)

3. Your app is now archived. üéâ

![An archived App features a top informative banner.](/assets/docs-markdown/platform/manage/environments-apps/archived-app.png)

In the image below, you can see how archived apps look like in Inngest Cloud:

![An archived App is still accessible from the Home page, by switching the top left filter to "Archived Apps".](/assets/docs-markdown/platform/manage/environments-apps/archived-apps.png)


--------------------------------------------------------------------------------
title: "Function runs Bulk Cancellation"
source: "https://www.inngest.com/docs/platform/manage/bulk-cancellation"
--------------------------------------------------------------------------------

# Function runs Bulk Cancellation

In addition to providing [SDK Cancellation features](/docs-markdown/features/inngest-functions/cancellation/cancel-on-events) and a [dedicated REST API endpoint](/docs-markdown/guides/cancel-running-functions), the Inngest Platform also features a Bulk Cancellation UI.

This feature comes in handy to quickly stop unwanted runs directly from your browser.

## Cancelling Function runs

To cancel multiple Function runs, navigate to the Function's page on the Inngest Platform and open the ‚ÄúAll actions‚Äù top right menu:

![The bulk cancellation button can be found from a Function page, in the top right menu.](/assets/docs-markdown/platform/function-dashboard-actions-2025-05-05.png)

Clicking the ‚ÄúBulk cancel‚Äù menu will open the following modal, asking you to select the date range that will be used to select and cancel Function runs:

![The Bulk cancel modal is composed, from top to bottom, of an input to name the cancellation process and a date range selector. Once those information filled, a estimation of the impacted Function Runs. The cancellation cannot be started if no Function runs match the criteria.](/assets/docs-markdown/platform/manage/bulk-cancellation/bulk-cancel-modal.png)

The Bulk Cancellation will start cancelling the matching Function runs immediately; the Function runs list will update progressively, showing runs as cancelled:

![Once the Bulk Cancellation completed, the impacted Function Runs will appear as "cancelled" in the Function Runs list.](/assets/docs-markdown/platform/manage/bulk-cancellation/function-runs-cancelled.png)

You can access the history of running or completed Bulk Cancellation processes via the "Cancellation history" tab:

![The "Cancellation history" tab lists all the Bulk Cancellations.](/assets/docs-markdown/platform/manage/bulk-cancellation/bulk-cancel-history.png)

> **Callout:** ConsiderationsCancellation is useful to stop running Functions or cancel scheduled ones; however, keep in mind that:Steps currently running on your Cloud Provider won't be forced to stop; the Function will cancel upon the current step's completion.Cancelling a Function run does not prevent new runs from being enqueued. If you are looking to mitigate an unwanted loop or to cope with an abnormal number of executions, consider using Function Pausing.


--------------------------------------------------------------------------------
title: "Datadog integration"
source: "https://www.inngest.com/docs/platform/monitor/datadog-integration"
--------------------------------------------------------------------------------

# Datadog integration

Inngest has a native Datadog integration which publishes metrics from your Inngest environment to your Datadog account. This enables you to monitor your Inngest functions and configure alerts based on your Inngest metrics. No Datadog agent configuration is required.

![The Inngest Datadog integration](/assets/docs-markdown/platform/monitor/datadog-integration/example-dashboard-2025-05-23.png "The default dashboard for the Inngest Datadog integration")

The Datadog integration comes with a default dashboard that you can use to monitor your Inngest functions.

## Setup

Navigate to the Inngest integration's page in the Datadog dashboard:

[Open Datadog integration](https://app.datadoghq.com/integrations/inngest)

> **Info:** If you have multiple Inngest organizations, please use the "Switch organization" button located in the user menu in the Inngest dashboard to ensure that you have the correct organization selected.

Click the "**Install integration**" button at the top right.

![The Datadog integration's install page](/assets/docs-markdown/platform/monitor/datadog-integration/datadog-install-integration.png "The Datadog integration's install page")

Now click "**Connect Accounts**" to connect your Inngest account to Datadog. This will open an authentication flow. You will be asked to authorize Inngest to access your Datadog account.

![The Datadog integration's connect accounts page](/assets/docs-markdown/platform/monitor/datadog-integration/datadog-connect-accounts.png "The Datadog integration's connect accounts page")

Once you have connected your Inngest account to Datadog, you will be redirected to [the Datadog integration page in the Inngest dashboard](https://app.inngest.com/settings/integrations/datadog). The connected Inngest environment will begin setup which may take up to 60 seconds to complete.

Here you can connect additional Inngest environments to connect to Datadog as well as add add additional Datadog accounts to send metrics to.

You will see the granularity and delay of the metrics that will be sent to Datadog based on your Inngest [billing plan](/pricing).

![The Datadog integration page](/assets/docs-markdown/platform/monitor/datadog-integration/inngest-dashboard-post-setup.png)

> **Info:** The setup process may take up to 60 seconds to complete. You can refresh the page to see the status of the setup.

Once the setup is complete, you can navigate to [the Dashboards tab in the Datadog dashboard](https://app.datadoghq.com/dashboard/lists?q=Inngest) and located the newly installed "Inngest" dashboard.

This dashboard (pictured at the top of this page), gives some default visualizations to help you get started. You can also create your own custom dashboards to monitor your Inngest functions using the `inngest.*` metrics.

## Metrics

The integration publishes several metrics including the metrics below. You can also view a full list of metrics available from the integration's "Data Collected" tab:

| **Metric Name**                                         | **Description**                                                                              |                               |
| ------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------- |
| **inngest.function\_run.scheduled.total**(count)        | Function runs scheduled during the time interval *Unit: run*                                 | environment, function         |
| **inngest.function\_run.started.total**(count)          | Function runs that started during the time interval *Unit: run*                              | environment, function         |
| **inngest.function\_run.ended.total**(count)            | Function runs that ended during the time interval *Unit: run*                                | status, environment, function |
| **inngest.function\_run.rate\_limited.total**(count)    | Function runs that did not execute due to rate limiting during the time interval *Unit: run* | environment, function         |
| **inngest.step.output\_bytes.total**(count)             | Bytes used by step outputs during the time interval *Unit: byte*                             | environment, function         |
| **inngest.sdk.req\_scheduled.total**(count)             | Step executions scheduled during the time interval *Unit: step*                              | environment, function         |
| **inngest.sdk.req\_started.total**(count)               | Step executions started during the time interval *Unit: step*                                | environment, function         |
| **inngest.sdk.req\_ended.total**(count)                 | Step executions that ended during the time interval *Unit: step*                             | environment, function, status |
| **inngest.steps.scheduled**(gauge)                      | Steps currently scheduled *Unit: step*                                                       | environment, function         |
| **inngest.steps.running**(gauge)                        | Steps currently running *Unit: step*                                                         | environment, function         |
| **inngest.steps.sleeping**(gauge)                       | Steps currently sleeping *Unit: step*                                                        | environment, function         |
| **inngest.metric\_export\_integration\_healthy**(gauge) | Indicates the Inngest integration successfully sent metrics to Datadog *Unit: success*       |                               |

## Granularity and delay

The Datadog integration is available to all paid plans and is subject to the following limits.

| Plan       | Granularity | Delay      |
| ---------- | ----------- | ---------- |
| Basic      | 15 minutes  | 15 minutes |
| Pro        | 5 minutes   | 5 minutes  |
| Enterprise | 1 minute    | Immediate  |


--------------------------------------------------------------------------------
title: "Insights"
source: "https://www.inngest.com/docs/platform/monitor/insights"
--------------------------------------------------------------------------------

# Insights

Inngest Insights allows you to query and analyze your event data using SQL directly within the Inngest platform. Every event sent to Inngest contains valuable information, and Insights gives you the power to extract meaningful patterns and analytics from that data.

> **Info:** Insights support is currently in Public Beta. Some details including SQL syntax and feature availability are still subject to change during this period. Read more about the Public Beta release phase here and the roadmap here.

## Overview

Insights provides an in-app SQL editor and query interface where you can:

- **Use AI to generate queries** - Describe what you want in plain English and let the Insights AI write the SQL for you
- Query event data using familiar SQL syntax
- Save and reuse common queries
- Share them with your team
- Browse your event schemas directly in the editor
- Analyze patterns in your event triggers
- Extract business intelligence from your workflows

Currently, you can **only query events**. Support for querying function runs will be added in future releases.

## Getting Started

Access Insights through the Inngest dashboard by clicking on the "Insights" tab in the left navigation.

![Getting Started Dashboard View](/assets/docs-markdown/platform/monitor/insights/insights_dashboard_view.png)

We have several pre-built query templates to help you get started exploring your data.

![Getting Started Templates View](/assets/docs-markdown/platform/monitor/insights/insights_template_view.png)

## Insights AI

Insights AI helps you generate SQL queries using natural language. Instead of writing SQL manually, you can describe what you want to analyze and the assistant will create the query for you.

### How it works

Simply describe what you want to query in plain English, and Insights AI will:

1. **Match events** - Analyze your prompt and identify the most relevant events from your account to use in the query
2. **Write the query** - Generate a properly formatted SQL query based on your event schemas
3. **Summarize results** - Provide a natural language summary of your query results

### Example prompts

- "Show me all failed functions in the last 24 hours"
- "Count orders by user for the past week"
- "What are the most common event types?"
- "Find all events where the amount is greater than 100"

The generated query is automatically inserted into the SQL editor and executed, so you can see results immediately and further refine the query if needed.

> **Info:** Insights AI is built using Inngest's own Realtime API, AgentKit, and durable execution with checkpointing.

## SQL Editor

The Insights interface includes a full-featured SQL editor where you can:

- Write and execute SQL queries against your event data
- Save frequently used queries for later access
- View query results in an organized table format
- Access query history and templates from the sidebar
- Autocomplete for writing sql and choosing events

![Sql Editor View](/assets/docs-markdown/platform/monitor/insights/insights_sql_editor.png)

### Available Columns

When querying events, you have access to the following columns:

| Column     | Type                | Description                                                                                          |
| ---------- | ------------------- | ---------------------------------------------------------------------------------------------------- |
| `id`       | String              | Unique identifier for the event                                                                      |
| `name`     | String              | The name/type of the event                                                                           |
| **`data`** | **JSON**            | **The event payload data - users can send any JSON structure here**                                  |
| `ts`       | Unix timestamp (ms) | Unix timestamp in milliseconds when the event occurred - [reference](https://www.unixtimestamp.com/) |
| `v`        | String              | Event format version                                                                                 |

For more details on the event format, see the [Inngest Event Format documentation](/docs-markdown/features/events-triggers/event-format).

### Data Retention

Refer to [pricing plans](/pricing) for data retention limits.

### Result Limits

- Current page limit: **1000 rows**
- Future updates will support larger result sets through async data exports

## Schema Explorer

The Schema Explorer, located on the right side, enables you to explore the fields available to write your Insight query. Browse and search your event schemas without leaving the editor.

The two types of schemas you will notice are:

- Common Schemas - Standard fields across all events (`id`, `name`, `ts`, etc.)
- Event-specific schemas - The structure of each event type's `data` payload

Search is also available for more efficient filtering of fields. After you have located the field you want, you can click to copy and paste it into your SQL editor.

![Schema Explorer](/assets/docs-markdown/platform/monitor/insights/insights_schema_explorer.png)

## SQL Support

Insights is built on ClickHouse, which provides powerful SQL capabilities with some differences from traditional SQL databases.

![Sql Editor View](/assets/docs-markdown/platform/monitor/insights/insights_query_results.png)

### Supported Functions

#### Arithmetic Functions

Basic mathematical operations and calculations.
[View ClickHouse arithmetic functions documentation](https://clickhouse.com/docs-markdown/sql-reference/functions/arithmetic-functions)

#### String Functions

String manipulation and search capabilities.

- [String search functions](https://clickhouse.com/docs-markdown/sql-reference/functions/string-search-functions)
- [String manipulation functions](https://clickhouse.com/docs-markdown/sql-reference/functions/string-functions)

#### JSON Functions

Essential for working with `events.data` payloads.
[View ClickHouse JSON functions documentation](https://clickhouse.com/docs-markdown/sql-reference/functions/json-functions)

#### Date/Time Functions

For analyzing event timing and patterns.
[View ClickHouse date/time functions documentation](https://clickhouse.com/docs-markdown/sql-reference/functions/date-time-functions)

#### Other Supported Function Categories

- [Logical functions](https://clickhouse.com/docs-markdown/sql-reference/functions/logical-functions)
- [Rounding functions](https://clickhouse.com/docs-markdown/sql-reference/functions/rounding-functions)
- [Type conversion functions](https://clickhouse.com/docs-markdown/sql-reference/functions/type-conversion-functions)
- [Functions for nulls](https://clickhouse.com/docs-markdown/sql-reference/functions/functions-for-nulls)
- [ULID functions](https://clickhouse.com/docs-markdown/sql-reference/functions/ulid-functions)

### Aggregate Functions

The following aggregate functions are supported:

| Function        | Description                                                                                                                        |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| `ARRAY_AGG()`   | [Aggregates values into an array](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/grouparray)  \* |
| `AVG()`         | [Calculates average](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/avg)                         |
| `COUNT()`       | [Counts rows](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/count)                              |
| `MAX()`         | [Finds maximum value](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/max)                        |
| `MIN()`         | [Finds minimum value](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/min)                        |
| `STDDEV_POP()`  | [Population standard deviation](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/stddevpop)        |
| `STDDEV_SAMP()` | [Sample standard deviation](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/stddevsamp)           |
| `SUM()`         | [Calculates sum](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/sum)                             |
| `VAR_POP()`     | [Population variance](https://clickhouse.com/docs-markdown/en/sql-reference/aggregate-functions/reference/varPop)                  |
| `VAR_SAMP()`    | [Sample variance](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/varSamp)                        |
| `median()`      | [Finds median value](https://clickhouse.com/docs-markdown/sql-reference/aggregate-functions/reference/median)                      |

### SQL Syntax Limitations

Some SQL features are not yet supported but are planned for future releases:

- **CTEs (Common Table Expressions)** using `WITH`
- **`IS` operator**
- **`NOT` operator**

## Working with Event Data

### Event-Specific Schema

Within **`events.data`**, users can send any JSON they want, so the structure and available fields will be specific to their payloads. You can use ClickHouse's JSON functions to extract and query specific fields within your event data.

### Example Queries

#### Basic Event Filtering

```sql
SELECT count(*)
FROM events
WHERE name = 'inngest/function.failed'
AND simpleJSONExtractString(data, 'function_id') = 'generate-report'
AND ts > toUnixTimestamp(addHours(now(), -1)) * 1000;
```

#### Extracting JSON Data and Aggregating

```sql
SELECT simpleJSONExtractString(data, 'user_id') as user_id, count(*) 
FROM events
WHERE name = 'order.created'
GROUP BY user_id
ORDER BY count(*) DESC
LIMIT 10;
```

## Saved Queries

You can save frequently used queries for quick access. Saved queries are private to you by default.

### Shared Queries

Some queries are valuable to the whole organization, and now you can more easily share those across your organization. Once you save a query, you can select the actions dropdown and share it with your organization.

Shared queries will be added to a `Shared queries` navigation dropdown within the Insights Sidebar.

![Share With Org](/assets/docs-markdown/platform/monitor/insights/insights_share_with_org.png)
![Shared Queries Navigation](/assets/docs-markdown/platform/monitor/insights/insights_shared_queries.png)

## Roadmap

### Coming Soon

- Query support for function runs
- `received_at` column for tracking event receipt time
- Pagination for large result sets
- Async data exports for results larger than 1000 rows

### Future Enhancements

- Support for CTEs (Common Table Expressions)
- `IS` and `NOT` operators
- Advanced visualization capabilities

## Need Help?

If you encounter issues or have questions about Insights:

1. Check this documentation for common solutions
2. Review the [ClickHouse SQL reference](https://clickhouse.com/docs-markdown/sql-reference/) for advanced function usage
3. Contact support through the Inngest platform

***

*Insights is actively under development. Features and column names may change as we continue to improve the product.*


--------------------------------------------------------------------------------
title: "Inspecting an Event"
source: "https://www.inngest.com/docs/platform/monitor/inspecting-events"
--------------------------------------------------------------------------------

# Inspecting an Event

The Event details will provide all the information to understand how this event was received, which data it contained and the tools to reproduce it locally.

## Accessing Events

Events across all application of the currently [selected environment](/docs-markdown/platform/environments) are accessible via the "Events" page in the left side navigation.

![The Events list features the last events received.](/assets/docs-markdown/platform/monitor/inspecting-events/events.png)

*Events can be filtered using a time filter.*

Accessing the events of a specific Event Type is achieved via the "Event Types" menu.

## Searching Events

Advanced filters are available using a [CEL expression](/docs-markdown/guides/writing-expressions). The search feature is available by clicking on the "Show search" button.

![The events list features an advance search feature that filters results using a CEL query.](/assets/docs-markdown/platform/monitor/inspecting-events/events-search.png)

### Searchable properties

Only basic search operators and the `event` variable are available for now:

| Field name | Type             | Operators                        |
| ---------- | ---------------- | -------------------------------- |
| event.id   | `string`         | `==`, `!=`                       |
| event.name | `string`         | `==`, `!=`                       |
| event.ts   | `int64`          | `==`, `!=`, `>`, `>=`, `<`, `<=` |
| event.v    | `string`         | `==`, `!=`                       |
| event.data | `map[string]any` | `==`, `!=`, `>`, `>=`, `<`, `<=` |

A few examples of valid search queries are `event.data.hello == "world"` and `event.name != "billing"`. [Learn more about how expressions are used in Inngest.](/docs-markdown/guides/writing-expressions)

> **Tip:** You can combine multiple search queries using the && operator or || operator. Adding a new line is the equivalent of using the && operator.


--------------------------------------------------------------------------------
title: "Inspecting a Function run"
source: "https://www.inngest.com/docs/platform/monitor/inspecting-function-runs"
--------------------------------------------------------------------------------

# Inspecting a Function run

You identified a failed Function run and want to identify the root cause? Or simply want to dig into a run's timings?
The Function run details will provide all the information to understand how this run ran and the tools to reproduce it locally.

## Accessing Function runs

Functions runs across all application of the currently [selected environment](/docs-markdown/platform/environments) are accessible via the "Runs" page in the left side navigation.

![The "Handle failed payments" Function runs list features a run in a failing state.](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-runs.png)

*Runs can be filtered using a Status, Queued or Started at and Application filters.*

Accessing the runs of a specific Function is achieved via the "Functions" menu, as described in [the function run details section](/docs-markdown/platform/monitor/inspecting-function-runs#the-function-run-details).

## Searching Function runs

Advanced filters are available using a [CEL expression](/docs-markdown/guides/writing-expressions). The search feature is available by clicking on the "Show search" button next to the other run filters.

![The runs list features an advance search feature that filters results using a CEL query.](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-runs-search.png)

### Searchable properties

Only basic search operators and `event` and `output` variables are available for now:

| Field name | Type             | Operators                        |
| ---------- | ---------------- | -------------------------------- |
| event.id   | `string`         | `==`, `!=`                       |
| event.name | `string`         | `==`, `!=`                       |
| event.ts   | `int64`          | `==`, `!=`, `>`, `>=`, `<`, `<=` |
| event.v    | `string`         | `==`, `!=`                       |
| event.data | `map[string]any` | `==`, `!=`, `>`, `>=`, `<`, `<=` |
| output     | `any`            | `==`, `!=`, `>`, `>=`, `<`, `<=` |

A few examples of valid search queries are `event.data.hello == "world"` and `output.success != true`. [Learn more about how expressions are used in Inngest.](/docs-markdown/guides/writing-expressions)

> **Tip:** You can combine multiple search queries using the && operator or || operator. Adding a new line is the equivalent of using the && operator.

### Searching for errors

Errors are serialized as JSON on the `output` object. When supported by the language SDK, errors are deserialized into a structured object. Here is an example of a error in TypeScript:

```typescript {{ title: "Example TypeScript code" }}
throw new NonRetriableError("Failed to import data");
```

```json {{ title: "Example TypeScript error" }}
{
  "name": "NonRetriableError",
  "message": "Failed to import data",
  "stack": "NonRetriableError: Failed to import data\n    at V1InngestExecution.userFnToRun (/opt/render/project/src/build/inngest/ai.js:143:15) ..."
}
```

This error can be searched using the following CEL expression:

```
output.name == "NonRetriableError" && output.message == "Failed to import data"
```

> **Tip:** Using custom error types in TypeScript can make it easier to search by the type of error:Example TypeScript codeimport \{ NonRetriableError } from "inngest";
>
> class UserNotFoundError extends NonRetriableError \{
> &#x20; constructor(message: string) \{
> &#x20;   super(message);
> &#x20;   this.name = "UserNotFoundError";
> &#x20; }
> }
> inngest.createFunction(
> &#x20; \{ id: "my-fn" },
> &#x20; \{ event: "user" },
> &#x20; async (\{ step, event }) => \{
> &#x20;   await step.run("get-user", async () => \{
> &#x20;     const user = await getUser(event.data.userId);
> &#x20;     if (!user) \{
> &#x20;       throw new UserNotFoundError(\`User not found ($\{event.data.userId})\`);
> &#x20;     }
> &#x20;     // ...
> &#x20;   });
> &#x20; }
> );event.data.userId == "12345" && output.name == "UserNotFoundError"

## The Function run details

A *Handle failed payments* function failed after retrying 5 times:

![The "Handle failed payments" Function runs list features a run in a failing state.](/assets/docs-markdown/platform/monitor/inspecting-function-runs/handle-failed-payments-function-run-failed.png)

Clicking on the failed Function Runs expands the run detail view:

![The Function run details view displays the event payload on the left, some technical attributes (function version, timings) on the right and a timeline of steps on the bottom left.](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-run-logs.png)

The Function run details panel is divided in 3 parts:

- On the top right: the **Trigger details** helpful when exchanging with Support
- On the right: the **Event payload** that triggered the Function run
- On the bottom right: the **Run details** with its timeline, a clear with of the Function's steps execution

The Function run details informs us that our Function run failed because of an `Error: Failed to downgrade user` error.

This is a first clue, let's have a closer look at the Timeline to identify the root cause:

We can now spot that the `downgrade-account-billing-plan` failed.

Let's expand this step to look at the retries and errors.

![The Timelime of steps features two steps: a first one to fetch the subscription from Stripe and second one to update it. The second is marked as failed.](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-run-logs-timeline-1.png)

![Expanding the second step lists all the attempted retries along with their respective error.](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-run-logs-timeline-2.png)

Expanding a step provides the same level of details (the error message and timings) along with retries information.

It seems that our `downgrade-account-billing-plan` step raised the same error during the following 5 retries, we might have to perform a fix in the database.

> **Callout:** üí° TipsClicking on the icon next to "Run details" open it in a new tab with a full-page layout.Clicking on the icon next to "Run details" open it in a new tab with a full-page layoutIt is useful for Function having a lot of steps or retries!

## Performing actions from the Function run details

The Function run details provides two main actions: replay the Function Run or sending the trigger event to your local Inngest Dev Server.

Sending the trigger Event to your local Inngest Dev Server provides a quick way to reproduce issues that are not linked to external factors (ex: new function version recently deployed, data issues).

After looking at the Function run details, the failure is judged temporary or fixed by a recent deployment, you can replay the Function run by using the "Rerun" button at the top right of the screen.

![The rerun button is accessible in the header of the "run details" section of the Function run detail](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-runs-details-open-new-tab.png)


--------------------------------------------------------------------------------
title: "Observability & Metrics"
source: "https://www.inngest.com/docs/platform/monitor/observability-metrics"
--------------------------------------------------------------------------------

# Observability & Metrics

With hundreds to thousands of events going through your Inngest Apps, triggering multiple Function runs, getting a clear view of what is happening at any time is crucial.

The Inngest Platform provides observability features for both Events and Function runs, coupled with Event logs and [a detailed Function Run details to inspect arguments and steps timings](/docs-markdown/platform/monitor/inspecting-function-runs).

## Function runs observability

The Functions list page provides the first round of essential information in one place with:

- **Triggers**: Events or Cron schedule
- **Failure rate**: enabling you to quickly identify a surge of errors
- **Volume**: helping in identifying possible drops in processing

![The Functions list page lists all available Functions with essential information such as associated Events, Failure rate and Volume.](/assets/docs-markdown/platform/monitor/observability-metrics/functions-list.png)

## Function metrics

Navigating to a Function displays the Function metrics page, composed of 7 charts:

![Clicking on a Function leads us to the Function view, composed of 7 charts.](/assets/docs-markdown/platform/monitor/observability-metrics/function-view.png)

All the above charts can be filtered based on a time range (ex: last 24 hours), a specific Function or [App](/docs-markdown/platform/manage/apps).

Let's go over each chart in detail:

### Function Status

![The Function Status chart is a pie chart where each part represents a function status (failed, succeed or cancelled).](/assets/docs-markdown/platform/monitor/observability-metrics/function-metrics-runs.png)

The Function Status chart provides a snapshot of the number of Function runs grouped by status.

> **Callout:** How to use this chart?This chart is the quickest way to identify an unwanted rate of failures at a given moment.

### Failed Functions

The *Failed Functions* chart displays the top 6 failing functions with the frequency of failures.

> **Callout:** How to use this chart?You can leverage this chart to identify a possible elevated rate of failures and quickly access the Function runs details from the "View all" button.

![](/assets/docs-markdown/platform/monitor/observability-metrics/failed-functions-chart.png)

### Total runs throughput

![The Total runs throughput is a line chart featuring the total number of Function runs per application.](/assets/docs-markdown/platform/monitor/observability-metrics/function-metrics-throughput.png)

The *Total runs throughput* is a line chart featuring the **rate of Function runs started per app**. This shows the performance of the system of how fast new runs are created and are being handled.

> **Callout:** How to use this chart?Flow control might intentionally limit throughput, this chart is a great way to visualize it.

### Total steps throughput

![The Total steps throughput is a line chart featuring the total number of Function steps running at a given time, per application.](/assets/docs-markdown/platform/monitor/observability-metrics/total-steps-throughput.png)

The *Total steps throughput* chart represents **the rate of which steps are executed, grouped by the selected Apps**.

> **Callout:** How to use these charts?The Total steps throughput chart is helpful to assess the configuration of your Inngest Functions.For example, a low Total steps throughput might be linked to a high number of concurrent steps combined with a restrictive concurrency configuration.

### Backlog

![The\_Backlog highlights the number of Function runs waiting to processed at a given time bucket.](/assets/docs-markdown/platform/monitor/observability-metrics/backlog.png)

The *Backlog* highlights the number of **Function runs waiting to processed at a given time bucket, grouped by the selected Apps**.

> **Callout:** How to use this chart?This chart is useful to assess the Account Concurrency capacity of your account and to identify potential spikes of activity.

## Events observability

Events volume and which functions they trigger can become hard to visualize.

Thankfully, the Events page gives you a quick overview of the volume of Events being sent to your Inngest account:

![The Events page lists the available Event type. Each list item features the event name along with its associated Functions and a events volume indicator.](/assets/docs-markdown/platform/monitor/observability-metrics/events-list.png)

Get more detailed metrics for a dedicated event by navigating to it from the list:

## Events metrics and logs

The Event page helps quickly visualize the throughput (the rate of event over time) and functions associated with this event.

The event occurrences feature a ‚ÄúSource‚Äù column, which is helpful when an event is triggered from multiple Apps (ex, using different languages):

![Clicking on an Events leads us to the Event page that displays, at the top, a chart of events occurrences over the last 24 hours and at the list of associated events.](/assets/docs-markdown/platform/monitor/observability-metrics/event-view.png)

Clicking on a specific event will redirect you to its Logs.

The Event Logs view provides the most precise information, with the linked Function run and raw event data.

Such information, combined with the ability to forward the event to your Local Dev Server instance, makes debugging events much quicker:

![Clicking on an event of the below list open the Event Logs view, providing much detailed information such as the Event Payload and triggered Functions.](/assets/docs-markdown/platform/monitor/observability-metrics/event-logs-view.png)

## Global Search

The global search feature helps you quickly find apps, functions, and events in your account using their names or **IDs**. It‚Äôs more than a search tool ‚Äî you can also use it to navigate around the environment and take quick actions or access helpful resources.

To open global search, press **Command (‚åò) / Ctrl + K** on your keyboard, or click the search icon in the top-left corner.

![Global search snippet](/assets/docs-markdown/platform/monitor/observability-metrics/cmd+k-observability.png)


--------------------------------------------------------------------------------
title: "Prometheus metrics export integration"
source: "https://www.inngest.com/docs/platform/monitor/prometheus-metrics-export-integration"
--------------------------------------------------------------------------------

# Prometheus metrics export integration

Inngest supports exporting [Prometheus](https://prometheus.io/) metrics via scrape endpoints. This enables you to monitor your Inngest functions from your existing Prometheus or Prometheus-compatible monitoring tools like [Grafana](https://prometheus.io/docs-markdown/visualization/grafana/), [New Relic](https://docs.newrelic.com/docs-markdown/infrastructure/prometheus-integrations/get-started/send-prometheus-metric-data-new-relic/), or similar.

## Setup

To get started, navigate to the Prometheus integration page in the Inngest dashboard's "Integrations" section.

Select the Inngest environment you want to export metrics from. The scrape config will be automatically generated including your Inngest API key required to authenticate with the scrape endpoint. You can use this configuration in your Prometheus instance or similar tool that supports scraping from a URL.

![Prometheus integration page](/assets/docs-markdown/platform/monitor/prometheus-exports/prometheus-integration-page.png)

## Metrics

The following metrics are exported:

| Metric                                 | Type    | Tags                   |
| -------------------------------------- | ------- | ---------------------- |
| `inngest_function_run_scheduled_total` | counter | `fn`, `date`           |
| `inngest_function_run_started_total`   | counter | `fn`, `date`           |
| `inngest_function_run_ended_total`     | counter | `fn`, `date`, `status` |
| `inngest_sdk_req_scheduled_total`      | counter | `fn`, `date`           |
| `inngest_sdk_req_started_total`        | counter | `fn`, `date`           |
| `inngest_sdk_req_ended_total`          | counter | `fn`, `date`, `status` |
| `inngest_step_output_bytes_total`      | counter | `fn`, `date`           |
| `inngest_steps_scheduled`              | gauge   | `fn`                   |
| `inngest_steps_running`                | gauge   | `fn`                   |

Example output:

```yaml
# HELP inngest_function_run_ended_total The total number of function runs ended
# TYPE inngest_function_run_ended_total counter
inngest_function_run_ended_total{date="2025-02-12",fn="my-app-my-function",status="Completed"} 480
inngest_function_run_ended_total{date="2025-02-12",fn="my-app-my-function",status="Failed"} 20
# HELP inngest_function_run_scheduled_total The total number of function runs scheduled
# TYPE inngest_function_run_scheduled_total counter
inngest_function_run_scheduled_total{date="2025-02-12",fn="my-app-my-function"} 500
# HELP inngest_function_run_started_total The total number of function runs started
# TYPE inngest_function_run_started_total counter
inngest_function_run_started_total{date="2025-02-12",fn="my-app-my-function"} 500
# HELP inngest_sdk_req_ended_total The total number of SDK invocation/step execution ended
# TYPE inngest_sdk_req_ended_total counter
inngest_sdk_req_ended_total{date="2025-02-12",fn="my-app-my-function",status="errored"} 17
inngest_sdk_req_ended_total{date="2025-02-12",fn="my-app-my-function",status="failed"} 15
inngest_sdk_req_ended_total{date="2025-02-12",fn="my-app-my-function",status="success"} 740
# HELP inngest_sdk_req_scheduled_total The total number of SDK invocation/step execution scheduled
# TYPE inngest_sdk_req_scheduled_total counter
inngest_sdk_req_scheduled_total{date="2025-02-12",fn="my-app-my-function"} 772
# HELP inngest_sdk_req_started_total The total number of SDK invocation/step execution started
# TYPE inngest_sdk_req_started_total counter
inngest_sdk_req_started_total{date="2025-02-12",fn="my-app-my-function"} 772
# HELP inngest_step_output_bytes_total The total number of bytes used by step outputs
# TYPE inngest_step_output_bytes_total counter
inngest_step_output_bytes_total{date="2025-02-12",fn="my-app-my-function"} 2804
# HELP inngest_steps_running The number of steps currently running
# TYPE inngest_steps_running gauge
inngest_steps_running{fn="my-app-my-function"} 7
# HELP inngest_steps_scheduled The number of steps scheduled
# TYPE inngest_steps_scheduled gauge
inngest_steps_scheduled{fn="my-app-my-function"} 30
```

## Limits

The Prometheus integration is available to all paid plans and is subject to the following limits.

| Plan       | Granularity | Delay      |
| ---------- | ----------- | ---------- |
| Basic      | 15 minutes  | 15 minutes |
| Pro        | 5 minutes   | 5 minutes  |
| Enterprise | 1 minute    | Immediate  |

All plans are subject to a rate limit of 30 requests per minute.


--------------------------------------------------------------------------------
title: "Traces"
source: "https://www.inngest.com/docs/platform/monitor/traces"
--------------------------------------------------------------------------------

# Traces

The Inngest DevServer and Cloud offer three levels of tracing to give you visibility into your function executions, each designed for different observability needs:

1. **Built-in Traces** - A quick access to your function and steps timing, retries and logs
2. **AI Traces** - Metadata for [AI Inference steps](/docs-markdown/features/inngest-functions/steps-workflows/step-ai-orchestration), including: tokens count, model input and output
3. **Extended Traces** - OpenTelemetry tracing capturing HTTP requests and third party library traces

## Built-in Traces  &#x20;

Every Inngest function automatically includes built-in tracing without any configuration. These traces track the core execution of your functions:

- **Function execution timeline** - Start and end times for your function runs
- **Step execution** - Individual step timing and status
- **Event data** - The event that triggered the function
- **Logs** - Logger output and errors
- **Retry attempts** - Failed runs and retry history

### Viewing Built-in Traces

Built-in traces are available in the Inngest dashboard and [DevServer](/docs-markdown/dev-server) for every function run:

![Function runs list showing recent executions in the Inngest Dashboard](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-runs.png)

*Traces in the Inngest Dashboard*

Click on any function run to see detailed execution information:

![Function run details showing traces and logs](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-run-logs-timeline-1.png)

The timeline view shows your function's execution path with steps and logs:

![Function run timeline with integrated trace and log information](/assets/docs-markdown/platform/monitor/inspecting-function-runs/function-run-logs-timeline-2.png)

Built-in traces are perfect for:

- **Day-to-day monitoring** - Tracking function executions and debugging basic issues
- **Step-level visibility** - Understanding which steps succeed or fail
- **Quick debugging** - Viewing logs and execution order

## AI Traces &#x20;

[AI Inference steps](/docs-markdown/features/inngest-functions/steps-workflows/step-ai-orchestration) (*`step.ai.*` methods*) enables you to offload LLM requests to the Inngest Platform and capture AI metadata including prompts, responses, token usage, and model parameters.

### What's Included

Each AI Trace display detailed metadata, including:

- Model name and version
- Tokens used (input, output)
- A side-by-side view of the input prompt and output response

### What You'll See

### Get started

AI Traces are automatically enabled when using `step.ai.infer()` from the TypeScript or Python SDK.

[Get started with AI Inference steps]("/docs-markdown/features/inngest-functions/steps-workflows/step-ai-orchestration")

## Extended Traces&#x20;

Extended Traces bring OpenTelemetry-powered distributed tracing to your Inngest functions, providing the most comprehensive visibility into every aspect of your function execution‚Äîfrom individual steps and external API calls to database queries and third-party services.

### What's Included

When you enable Extended Traces, Inngest automatically instruments your functions to capture detailed trace data about:

- **External service calls** - Track API requests, database queries, and third-party integrations
- **Performance bottlenecks** - Identify slow operations and optimize your functions
- **Distributed context** - Full distributed tracing across your entire stack

Extended Traces integrate seamlessly with your existing observability stack through [OpenTelemetry](https://opentelemetry.io/), the industry standard for distributed tracing.

### What You'll See

Every function run includes comprehensive trace spans showing the complete execution timeline.
Each span includes specific metadata from the operation (*`method`, `url` for HTTP requests, `driver`, `query` for SQL requests*):

> **Note:** Extended Traces automatically capture spans from popular libraries including HTTP clients, database drivers, and more. See the full list of automatic instrumentation.

### Get started

Extended Traces are currently available in the TypeScript as an opt-in beta.
Get started in just a few minutes by configuring the Extended Traces middleware.

[Get started with Extended Traces]("/docs-markdown/reference/typescript/extended-traces")


--------------------------------------------------------------------------------
title: "Function Replay"
source: "https://www.inngest.com/docs/platform/replay"
--------------------------------------------------------------------------------

# Function Replay

Functions will fail. It's unavoidable. When they do, you need to recover from the failure quickly.

When a large number of functions fail, you can easily *replay* them in bulk from the Inngest dashboard.

![Relay graphic](/assets/docs-markdown/platform/replay/featured-image-v2.png)

The recovery flow in other systems may require dead-letter queues or some other form of manual intervention.
With Replay, you can replay functions in bulk from the Inngest dashboard:

1. You detect an issue with your functions (e.g. a failure due to a bug or external system)
2. You fix the issue and push to production
3. You use Replay to replay the functions from the time range when the issues occurred

Let's learn how you can use Replay to recover from function failures:

## How to create a new Replay

To replay a function, select the "Replay" option in the "All actions" menu from a function's dashboard. This will open a modal where you can select the runs you want to replay.

![Replay button in function runs page](/assets/docs-markdown/platform/function-dashboard-actions-2025-05-05.png)

Each replay requires a name, a time range and status(es) to filter the runs to be replayed.
We recommend using a name that describes the incident that you're resolving so your team can
understand this later, or maybe just mention the bug tracker issue:  e.g. "Bug fix from PR #958",
"API-395: Networking blip."

![Replay modal form](/assets/docs-markdown/platform/replay/replay-function-modal-empty-2025-05-05.png)

Here's an example of a Replay that fixed a bug triggered by daylight savings time between the given timestamp.
For this issue, we only want to target the "Failed" function runs statuses. You can select multiple run
statuses in case your function might have had a bug that failed silently, so you want to replay anything
previously marked as "Succeeded" as well.

![Replay modal form filled](/assets/docs-markdown/platform/replay/replay-function-modal-filled-2025-05-05.png)

Once you have selected the runs you want to replay, click the replay button to start the replay. You
will be redirected to the replay page where you can see the progress of the replay.

![List of all Replays](/assets/docs-markdown/platform/replay/replay-function-replays-2025-05-05.png)

The replay will spread out the runs over time as to not overwhelm your application with requests.
Depending on the number of runs to be replayed, this could take seconds or minutes to complete.

When all the runs have been replayed, the replay will be marked as "Completed."


--------------------------------------------------------------------------------
title: "Signing keys"
source: "https://www.inngest.com/docs/platform/signing-keys"
--------------------------------------------------------------------------------

# Signing keys

Inngest uses signing keys to secure communication between Inngest and your servers. The signing key is a *secret* pre-shared key unique to each [environment](/docs-markdown/platform/environments). The signing key adds the following security features:

- **Serve endpoint authentication** - All requests sent to your server are signed with the signing key, ensuring that they originate from Inngest. Inngest SDKs reject all requests that are not authenticated with the signing key.
- **API authentication** - Requests sent to the Inngest API are signed with the signing key, ensuring that they originate from your server. The Inngest API rejects all requests that are not authenticated with the signing key. For example, when syncing functions with Inngest, the SDK sends function configuration to Inngest's API with the signing key as a bearer token.
- **Replay attack prevention** - Requests are signed with a timestamp embedded, and old requests are rejected, even if the requests are authenticated correctly.

> **Callout:** üîê Signing keys are secrets and you should take precautions to ensure that they are kept secure. Avoid storing them in source control.

You can find your signing key within each environment's [Signing Key tab](https://app.inngest.com/env/production/manage/signing-key).

## Configuring the signing key

You can set the signing key in your SDK by setting the `INNGEST_SIGNING_KEY` environment variable. Alternatively, you can pass the signing key as an argument when creating the SDK client, but we recommend never hardcoding the signing key in your code.

Additionally, you'll set the `INNGEST_SIGNING_KEY_FALLBACK` environment variable to ensure zero downtime when rotating your signing key. Read more about that [below](#rotation).

## Local development

Signing keys should be omitted when using the Inngest [Dev Server](/docs-markdown/local-development). To simplify local development and testing, the Dev Server doesn't require a signing key.

Each language SDK attempts to detect if your application is running in production or development mode. If you're running in development mode, the SDK will automatically disable signature verification. To force development mode, set `INNGEST_DEV=1` in your environment. This is useful when running in an automated testing environment.

## Rotation

Signing keys can be rotated to mitigate the risk of a compromised key. We recommend rotating your signing keys periodically or whenever you believe they may have been exposed.

Inngest supports zero downtime signing key rotation if your SDK version meets the minimum version:

| Language   | Minimum Version |
| ---------- | --------------- |
| Go         | `0.7.2`         |
| Python     | `0.3.9`         |
| TypeScript | `3.18.0`        |

You can still rotate your signing key if you use an older SDK version, but you will experience downtime.

To begin the rotation process, navigate to the [Signing Key tab](https://app.inngest.com/env/production/manage/signing-key) in the Inngest dashboard. Click the "Create new signing key" button and then follow the instructions in the **Rotate key** section.

> **Callout:** ü§î Why do I need a "fallback" signing key?As requests are signed with the current signing key, your code must have both the current and the new signing key available to verify requests during the rotation. To ensure there is zero downtime, the SDKs will retry authentication failures with the fallback key.

### Vercel integration

To rotate signing keys for Vercel projects, you must manually update the `INNGEST_SIGNING_KEY` environment variable in your Vercel project.

During initial setup, the Vercel integration automatically sets this key, but the integration ***will not*** automatically rotate the key for you. You must follow the manual process as guided within the Inngest dashboard.

## Signing keys and branch environments

All [branch environments](/docs-markdown/platform/environments#configuring-branch-environments) within your account share a signing key. This enables you to set a single environment variable for preview environments in platforms like [Vercel](/docs-markdown/deploy/vercel) or [Netlify](/docs-markdown/deploy/netlify) and each platform can dynamically specify the correct branch environment through secondary environment variables.

## Further reading

- [TypeScript SDK serve reference](/docs-markdown/reference/serve#signingKey)
- [Python SDK client reference](/docs-markdown/reference/python/client/overview#signing_key)


--------------------------------------------------------------------------------
title: "Consuming webhook events"
source: "https://www.inngest.com/docs/platform/webhooks"
--------------------------------------------------------------------------------

# Consuming webhook events

At its core, Inngest is centered around functions that are triggered by events. Webhooks are one of the most ubiquitous sources for events for developers. Inngest was designed to support webhook events.

This guide will show you how to use Inngest to consume your webhook events and trigger functions.

When talking about webhooks, it's useful to define some terminology:

- **Provider** - The service sending the webhook events as HTTP post requests.
- **Consumer** - The URL endpoint which receives the HTTP post requests.

Inngest enables you to create any number of unique URLs which act as webhook consumers. You can create a webhook for each third party service that you use (e.g. Stripe, Github, Clerk) along with custom rules on how to handle that webhook.

## Creating a webhook

First, you'll need to head to the **Manage** tab in the Inngest dashboard and then click **Webhooks**. From there, click **Create Webhook**.

Now you'll have a uniquely generated URL that you can provide to any provider service to start sending events. These URLs are configured in different ways for different provider services. For example, with Stripe, you need to enter "developer mode" and configure your webhook URLs.

Give your webhook a name and save it. Next we'll explore how to turn the request payload into Inngest events.

![Inngest dashboard showing a newly created webhook](/assets/docs-markdown/platform/dashboard-webhook-screenshot.png)

## Defining a transform function

Most webhooks send event data as JSON within the POST request body. These raw events must be transformed slightly to be compatible with [the Inngest event payload format](/docs-markdown/features/events-triggers/event-format). Mainly, we must have `name` and `data` set in the Inngest event.

Fortunately, Inngest includes ***transform*** functions for every webhook. You can define a short JavaScript function used to transform the shape of the payload. This transform runs on Inngest's servers so there is no added load or cost to your infra.

Here is [an example of a raw webhook payload from Clerk](https://clerk.com/docs-markdown/integrations/webhooks/overview#payload-structure) on the left and our transformed event:

```json {{ title: "Example Clerk webhook payload"}}
{
  "type": "user.created",
  "object": "event",
  "data": {
    "created_at": 1654012591514,
    "external_id": "567772",
    "first_name": "Example",
    "id": "user_29w83sxmDNGwOuEthce5gg56FcC",
    "last_name": "Example",
    "last_sign_in_at": 1654012591514,
    "object": "user",
    "primary_email_address_id": "idn_29w83yL7CwVlJXylYLxcslromF1",
    // ... simplified for example
  },
}
```

```json {{ title: "Example Inngest event format"}}
{
  "name": "clerk/user.created",
  "data": {
    "created_at": 1654012591514,
    "external_id": "567772",
    "first_name": "Example",
    "id": "user_29w83sxmDNGwOuEthce5gg56FcC",
    "last_name": "Example",
    "last_sign_in_at": 1654012591514,
    "object": "user",
    "primary_email_address_id": "idn_29w83yL7CwVlJXylYLxcslromF1",
    // ... simplified for example
  }
}
```

Transforms are defined as simple JavaScript functions that accept three arguments and expect the Inngest event payload object in the returned value. The arguments are:

- `evt` (object): The raw JSON payload from the POST request body

* `headers` (object): A map of HTTP headers sent along with the request as key-value pairs. Header names are case-insensitive and are canonicalized by making the first character and any characters following a hyphen uppercase and the rest lowercase. For more details, check out the underlying implementation reference.

- `queryParams` (object): A map of parsed query string parameters sent to the webhook URL. Values are all arrays to support multiple params for a single key.

Here's a simple transform function for the Clerk example shown above:

```ts
function transform(evt, headers = {}, queryParams = {}) {
  return {
    name: `clerk/${evt.type}`,
    data: evt.data,
    // You can optionally set ts using data from the raw json payload
    // to explicitly set the timestamp of the incoming event.
    // If ts is not set, it will be automatically set to the time the request is received.
  }
}
```

> **Callout:** üëâ We also recommend prefixing each event name with the name of the provider service, e.g. clerk/user.created, stripe/charge.failed.

### Example transforms

> **Callout:** üí° Header names are case-insensitive and are canonicalized by making the first character and any characters following a hyphen uppercase and the rest lowercase.Remember to check your transforms for header usage and make sure to use the correct case.

**Github** - Using headers

Github uses a `X-Github-Event` header to specify the event type:

```js
function transform(evt, headers = {}, queryParams = {}) {
  const name = headers["X-Github-Event"];
  return {
    // Use the event as the data without modification
    data: evt,
    // Add an event name, prefixed with "github." based off of the X-Github-Event data
    name: "github." + name.trim().replace("Event", "").toLowerCase(),
  };
}
```

**Stripe** - Using an `id` for deduplication

Stripe sends an `id` with every event to deduplicate events. We can use this as the `id` for the Inngest event for the same reason:

```js
function transform(evt, headers = {}, queryParams = {}) {
  return {
    id: evt.id,
    name: `stripe/${evt.type}`,
    data: evt,
  };
}
```

**Linear** - Creating useful event names

```js
function transform(evt, headers = {}, queryParams = {}) {
  return {
    // type (e.g. Issue) + action (e.g. create)
    name: `linear/${evt.type.toLowerCase()}.${evt.action}`,
    data: evt,
  };
}
```

**Intercom** - Setting the `ts` field

```js
function transform(evt, headers = {}, queryParams = {}) {
  return {
    name: `intercom/${evt.topic}`,
    // the top level obj only contains webhook data, so we omit that
    data: evt.data,
    ts: evt.created_at * 1000,
   };
};
```

**Resend**

```js
function transform(evt, headers = {}, queryParams = {}) {
  return {
    name: `resend/${evt.type}`,
    data: evt.data,
   };
};
```

### Testing transforms

The Inngest dashboard includes a tool to quickly test your transform function. You can paste the incoming payload from the webhook provider in the "Incoming Event JSON" editor and immediately preview what the transformed event will look like.

![Inngest dashboard transform testing](/assets/docs-markdown/platform/dashboard-webhook-transform-testing.png)

Some webhook providers do not provide example payloads in their documentation. If that's the case, you can use a tool that we built, [TypedWebhooks.tools](https://typedwebhook.tools/?ref=) to test webhooks and browse payloads.

## Advanced configuration

Additionally, you can configure allow/deny lists for event names and IP addresses. This can be useful if you want a bit more control over what events are ingested.

## Managing webhooks via REST API

Webhooks can be created, updated and deleted all via the Inngest REST API. This is very useful if you want to manage all transforms within your codebase and sync them to the Inngest platform. Check out the documentation below to learn more:

**API: Webhooks**: [Read the documentation about managing Webhooks via the Inngest REST API]('https://api-docs.inngest.com/docs-markdown/inngest-api/b539bae406d1f-get-all-webhook-endpoints-in-given-environment')

**Demo: Webhook transform sync**: [View an end-to-end example of how to test and sync Webhooks in your codebase.]('https://github.com/inngest/webhook-transform-sync')

## Local development

To test your webhook locally, you can forward events to the [Dev Server](/docs/local-development) from the Inngest dashboard using the "Send to Dev Server" button. This button is found anywhere that an event payload is visible on the Inngest dashboard. This will send a copy of the event to your local machine where you can test your functions.

## Writing functions

Now that you have events flowing into Inngest, you can write functions that that handle the events that you care about. You can also explore the list of events that have been received at any time by heading to the *Events* tab of the Inngest dashboard.

```ts {{ title: "Example: Send a welcome email when the clerk/user.created event is received"}}
inngest.createFunction(
  { name: "Send welcome email", id: "send-welcome-email" },
  { event: "clerk/user.created" },
  async ({ event, step }) => {
    const emailAddress = event.data.email_addresses[0].email_address;
    await step.run('send-email', async () => {
      return await resend.emails.send({
        to: emailAddress,
        from: "noreply@inngest.com",
        subject: "Welcome to Inngest!",
        react: WelcomeEmail(),
      })
    });
  }
)
```

> **Callout:** üí° Tip: To test functions locally, copy an event from a webhook from the Inngest dashboard and use it with the Inngest dev server's Send test button.

## Verifying request signatures

Many webhook providers sign their requests with a secret key to ensure that the request is coming from them. This establishes trust with the webhook provider and ensures that the event data has not been tampered with.

To verify a webhook signature, you'll need to return the signature and raw request body string in your transform. For example, the following transform function could be used for Stripe webhooks:

```ts
function transform(evt, headers, queryParams, raw) {
  return {
    name: `stripe/${evt.type}`,
    data: {
      raw,
      sig: headers["Stripe-Signature"],
    }
  };
};
```

Then you can use that data to verify the signature in your Inngest functions:

```ts
inngest.createFunction(
  { id: "stripe/charge.updated" },
  { event: "stripe/charge.updated" },
  async ({ attempt, event, step }) => {
    if (!verifySig(event.data.raw, event.data.sig, stripeSecret)) {
      throw new NonRetriableError("failed signature verification");
    }

    // Now it's safe to use the event data.
    const data = JSON.parse(event.data.raw);
  }
);
```

## Branch environments

All branch environments share the same webhooks. They are centrally-managed in a [single page](https://app.inngest.com/env/branch/manage/webhooks).

Additionally, the target branch environment must be specified using either an `x-inngest-env` query param or header. For example, the following command will send an webhook to the `branch-1` branch environment:

```sh
curl 'https://inn.gs/e/REDACTED?x-inngest-env=branch-1' -d '{"msg": "hi"}'
```

If the branch environment is not specified with the header or query param, the webhook will be sent to [this page](https://app.inngest.com/env/branch/events) and will not trigger any functions. Events will also go here if the branch environment does not exist.

> **Callout:** The value for x-inngest-env is the name of the branch environment, not the ID in the URL.

## Supported content types

Webhooks currently support the following content types:

- `application/json`
- `application/x-www-form-urlencoded`
- `multipart/form-data`

> **Callout:** The application/x-www-form-urlencoded and multipart/form-data content types are currently in beta.

### Processing webhooks with URL params or Form Data content

Given the following `application/x-www-form-urlencoded` webhook:

```sh
curl https://inn.gs/e/REDACTED \
  -H "content-type: application/x-www-form-urlencoded" \
  -d "name=Alice&messages=hello&messages=world"
```

And your webhook transform looks like this:

```js
function transform(json, headers, queryParams, raw) {
  return {
    name: "hi",
    data: { json, raw },
  };
};
```

Then the resulting event data will be:

```json
{
  "json": {
    "messages": ["hello", "world"],
    "name": ["Alice"]
  },
  "raw": "name=Alice&messages=hello&messages=world"
}
```

> **Callout:** ‚ö†Ô∏è Note that the JSON object's values are always arrays of strings.

## Building webhook integrations

Inngest has a feature called **webhook intents** that allows you to build webhook integrations with any application. [Read more about building webhook integrations here](/docs-markdown/platform/webhooks/build-an-integration).


--------------------------------------------------------------------------------
title: "Webhook intents: Building a webhook integration"
source: "https://www.inngest.com/docs/platform/webhooks/build-an-integration"
--------------------------------------------------------------------------------

# Webhook intents: Building a webhook integration

**Webhook intents** is a feature that enables any webhook provider to build an integration with Inngest.

## What is a webhook intent?

A webhook intent is a simple URL that providers can redirect their users to for Inngest users to approve and create a new webhook URL. The intent redirects the user back to the provided redirect URL with the new webhook URL as a query parameter.

## Creating a webhook intent

The base webhook intent URL is:

```
https://app.inngest.com/intent/create-webhook
```

To customize the intent, use the following query params:

- `name` (string): The name of the webhook intent. This will be used to identify the webhook in the user's Inngest environment and create a slug prefix for all events received from this webhook.

* `redirect_uri` (string): The URL to redirect the user back to after they approve the webhook intent.This URL will receive a url query param with the full URL of the webhook intent which can be stored on your end as the webhook target URL.

A full example URL would look like this:

```
https://app.inngest.com/intent/create-webhook?name=AcmeApp&redirect_uri=https%3A%2F%2Fapi.example.com%2Fwebhook%2Fcallback
```

## How it works

In your application, create a button that opens the webhook intent URL either in the same tab or in a pop up window (ex. via `window.open`).

Example: Open in pop up window

```javascript
window.open("https://app.inngest.com/intent/create-webhook?name=AcmeApp&redirect_uri=https%3A%2F%2Fapi.example.com%2Fwebhook%2Fcallback","_blank", "popup=true,height=640,width=680")
```

The user will be sent to the intent page where they can approve the webhook intent. If they are not logged in, they will be prompted to login.

![Webhook intent page](/assets/docs-markdown/platform/webhooks/intent-popup.png)

When approved, Inngest will create a new webhook URL with the slugified name as an event prefix and the [default transform function](#default-webhook-transform) will be used to transform incoming webhook payloads into [the Inngest event format](/docs-markdown/features/events-triggers/event-format).

The user will be redirected back to the original application's `redirect_uri` with the new webhook URL as a query parameter (`url`). You can save this URL to your database and use it as the webhook target URL for your application. The user will begin seeing events from your application in Inngest immediately.

```
https://api.example.com/webhook/callback?url=https%3A%2F%2Finn.gs%2Fe%2F9VFPYIh8dKJmt7ERkNytXlQEvc_WtX0YgZCErRB5qPd4OUx7t7lUyl333ynly8Mo5-OjRKZ1oWPDhWZq24Y6Qw
```

## Default webhook transform

Inngest webhooks support [transform functions](/docs-markdown/platform/webhooks#defining-a-transform-function) which are used to transform incoming webhook payload JSON body into [the Inngest event format](/docs-markdown/features/events-triggers/event-format). The webhook intent creates a default transform automatically that supports the most common webhook payloads.

```javascript
function transform(evt, headers = {}, queryParams = {}, raw = "") {
  return {
    // This was created by the <Provider name> integration.
    // Edit this to customize the event name and payload.
    name: `<provider-name-slug>/${evt.type || evt.name || evt.event_type || "webhook.received"}`,
    data: evt.data || evt,
  };
};
```

If you're a developer and you'd like to request new functionality please [contact us](mailto:hello@inngest.com?subject=Webhook%20intent%20feature%20request).


--------------------------------------------------------------------------------
title: "Reference"
source: "https://www.inngest.com/docs/reference"
--------------------------------------------------------------------------------

# Reference

Learn about our SDKs:


--------------------------------------------------------------------------------
title: "Create the Inngest Client"
source: "https://www.inngest.com/docs/reference/client/create"
--------------------------------------------------------------------------------

# Create the Inngest Client

The `Inngest` client object is used to configure your application, enabling you to create functions and send events.

```ts {{ title: "v3" }}
import { Inngest } from "inngest";

const inngest = new Inngest({
  id: "my-application",
});
```

```ts {{ title: "v2" }}
import { Inngest } from "inngest";

const inngest = new Inngest({
  name: "My application",
});
```

***

## Configuration

- `id` (string): A unique identifier for your application. We recommend a hyphenated slug.

* `baseUrl` (string): Override the default (https\://inn.gs/) base URL for sending events. See also the INNGEST\_BASE\_URL environment variable.

- `env` (string): The environment name. Required only when using Branch Environments.

* `eventKey` (string): An Inngest Event Key. Alternatively, set the INNGEST\_EVENT\_KEY environment variable.

- `fetch` (Fetch API compatible interface): Override the default
  fetch
  implementation. Defaults to the runtime's native Fetch API.If you need to specify this, make sure that you preserve the function's binding, either by using .bind or by wrapping it in an anonymous function.

* `isDev` (boolean): Set to true to force Dev mode, setting default local URLs and turning off
  signature verification, or force Cloud mode with false. Alternatively, set INNGEST\_DEV.

- `logger` (Logger): A logger object that provides the following interfaces (.info(), .warn(), .error(), .debug()). Defaults to using console if not provided. Overwrites INNGEST\_LOG\_LEVEL if set. See logging guide for more details.

* `middleware` (array): A stack of middleware to add to the client.

- `schemas` (EventSchemas): Event payload types. See Defining Event Payload Types.

> **Callout:** We recommend setting the INNGEST\_EVENT\_KEY as an environment variable over using the eventKey option. As with any secret, it's not a good practice to hard-code the event key in your codebase.

## Defining Event Payload Types

You can leverage TypeScript, Zod, Valibot, or any schema library that
implements the [Standard Schema interface](https://standardschema.dev/) to define
your event payload types.

When you pass types to the Inngest client,
events are fully typed when using them with `inngest.send()` and
`inngest.createFunction()`. This can more easily alert you to issues with your
code during compile time.

> **Callout:** Click the toggles on the top left of the code block to see the different methods available!

```ts {{ title: "Standard Schema" }}
import { EventSchemas, Inngest } from "inngest";
import { z } from "zod";

export const inngest = new Inngest({
  schemas: new EventSchemas().fromSchema({
    "app/account.created": z.object({
      userId: z.string(),
    }),
    "app/subscription.started": z.object({
      userId: z.string(),
      planId: z.string(),
    }),
  }),
});
```

```ts {{ title: "Union" }}
import { EventSchemas, Inngest } from "inngest";

type AppAccountCreated = {
  name: "app/account.created";
  data: {
    userId: string;
  };
};

type AppSubscriptionStarted = {
  name: "app/subscription.started";
  data: {
    userId: string;
    planId: string;
  };
};

type Events = AppAccountCreated | AppSubscriptionStarted;

export const inngest = new Inngest({
  schemas: new EventSchemas().fromUnion<Events>(),
});
```

```ts {{ title: "Record"}}
import { EventSchemas, Inngest } from "inngest";

type Events = {
  "app/account.created": {
    data: {
      userId: string;
    };
  };
  "app/subscription.started": {
    data: {
      userId: string;
      planId: string;
    };
  };
};

export const inngest = new Inngest({
  schemas: new EventSchemas().fromRecord<Events>(),
});
```

```ts {{ title: "Stacking" }}
import { EventSchemas, Inngest } from "inngest";
import { z } from "zod";

type Events = {
  "app/user.created": {
    data: { id: string };
  };
};

const zodEventSchemas = {
  "app/account.created": z.object({
    userId: z.string(),
  }),
};

type AppPostCreated = {
  name: "app/post.created";
  data: { id: string };
};

type AppPostDeleted = {
  name: "app/post.deleted";
  data: { id: string };
};

export const inngest = new Inngest({
  schemas: new EventSchemas()
    .fromRecord<Events>()
    .fromUnion<AppPostCreated | AppPostDeleted>()
    .fromSchema(zodEventSchemas),
});
```

### Reusing event types&#x20;

You can use the `GetEvents<>` generic to access the final event types from an Inngest client.

> **Callout:** It's recommended to use this instead of directly reusing your event types, as Inngest will add extra properties and internal events such as ts and inngest/function.failed.

```ts
import { EventSchemas, Inngest, type GetEvents } from "inngest";

export const inngest = new Inngest({
  schemas: new EventSchemas().fromRecord<{
    "app/user.created": { data: { userId: string } };
  }>(),
});

type Events = GetEvents<typeof inngest>;
type AppUserCreated = Events["app/user.created"];
```

For more information on this and other TypeScript helpers, see [TypeScript -
Helpers](/docs-markdown/typescript#helpers).

## Cloud Mode and Dev Mode

An SDK can run in two separate "modes:" **Cloud** or **Dev**.

- **Cloud Mode**
  - üîí Signature verification **ON**
  - Defaults to communicating with Inngest Cloud (e.g. `https://api.inngest.com`)
- **Dev Mode**
  - ‚ùå Signature verification **OFF**
  - Defaults to communicating with an Inngest Dev Server (e.g. `http://localhost:8288`)

You can force either Dev or Cloud Mode by setting
[`INNGEST_DEV`](/docs-markdown/sdk/environment-variables#inngest-dev) or the
[`isDev`](#configuration) option.

If neither is set, the SDK will attempt to infer which mode it should be in
based on environment variables such as `NODE_ENV`. Most of the time, this inference is all you need and explicitly setting a mode
isn't required.

## Best Practices

### Share your client across your codebase

Instantiating the `Inngest` client in a single file and sharing it across your codebase is ideal as you only need a single place to configure your client and define types which can be leveraged anywhere you send events or create functions.

```ts {{ title: "v3" }}
import { Inngest } from "inngest";

export const inngest = new Inngest({ id: "my-app" });
```

```ts {{ title: "v2" }}
import { Inngest } from "inngest";

export const inngest = new Inngest({ name: "My App" });
```

```ts {{ filename: './inngest/myFunction.ts' }}
import { inngest } from "./client";

export default inngest.createFunction(...);
```

### Handling multiple environments with middleware

If your client uses middleware, that middleware may import dependencies that are not supported across multiple environments such as "Edge" and "Serverless" (commonly with either access to WebAPIs or Node).

In this case, we'd recommend creating a separate client for each environment, ensuring Node-compatible middleware is only used in Node-compatible environments and vice versa.

This need is common in places where function execution should declare more involved middleware, while sending events from the edge often requires much less.

```ts {{ title: "v3" }}
// inngest/client.ts
import { Inngest } from "inngest";
import { nodeMiddleware } from "some-node-middleware";

export const inngest = new Inngest({
  id: "my-app",
  middleware: [nodeMiddleware],
});

// inngest/edgeClient.ts
import { Inngest } from "inngest";

export const inngest = new Inngest({
  id: "my-app-edge",
});
```

```ts {{ title: "v2" }}
// inngest/client.ts
import { Inngest } from "inngest";
import { nodeMiddleware } from "some-node-middleware";

export const inngest = new Inngest({
  name: "My App",
  middleware: [nodeMiddleware],
});

// inngest/edgeClient.ts
import { Inngest } from "inngest";

export const inngest = new Inngest({
  id: "My App (Edge)",
});
```

Also see [Referencing functions](/docs-markdown/functions/references), which can help you invoke functions across these environments without pulling in any dependencies.


--------------------------------------------------------------------------------
title: "Send events"
source: "https://www.inngest.com/docs/reference/events/send"
--------------------------------------------------------------------------------

# Send events

Send events to Inngest. Functions with matching event triggers will be invoked.

```ts
import { inngest } from "./client";

await inngest.send({
  name: "app/account.created",
  data: {
    accountId: "645e9f6794e10937e9bdc201",
    billingPlan: "pro",
  },
  user: {
    external_id: "645ea000129f1c40109ca7ad",
    email: "taylor@example.com",
  }
})
```

To send events from within of the context of a function, use [`step.sendEvent()`](/docs-markdown/reference/functions/step-send-event).

***

## `inngest.send(eventPayload | eventPayload[], options): Promise<{ ids: string[] }>`

- `eventPayload` (object | object\[]): An event payload object or an array of event payload objects.The event name. We recommend using lowercase dot notation for names, prepending prefixes/ with a slash for organization.Any data to associate with the event. Will be serialized as JSON.Any relevant user identifying data or attributes associated with the event. This data is encrypted at rest.An external identifier for the user. Most commonly, their user id in your system.A unique ID used to idempotently trigger function runs.  If duplicate event IDs are seen,
  only the first event will trigger function runs. Read the idempotency guide here.A timestamp integer representing the time (in milliseconds) at which the event occurred. Defaults to the time the Inngest receives the event.If the ts time is in the future, function runs will be scheduled to start at the given time.   This has the same effect as running await step.sleepUntil(event.ts) at
  the start of the function.Note: This does not apply to functions waiting for events. Functions waiting for events will immediately resume, regardless of the timestamp.A version identifier for a particular event payload. e.g. "2023-04-14.1"

* `options` (object): The environment to send the events to.

```ts
// Send a single event
await inngest.send({
  name: "app/post.created",
  data: { postId: "01H08SEAXBJFJNGTTZ5TAWB0BD" }
});

// Send an array of events
await inngest.send([
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e024befa68763f5b500" }
  },
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e08f29fb563c972b1f7" }
  },
]);

// Send user data that will be encrypted at rest
await inngest.send({
  name: "app/account.created",
  data: { billingPlan: "pro" },
  user: {
    external_id: "6463da8211cdbbcb191dd7da",
    email: "test@example.com"
  }
});

// Specify the idempotency id, version, and timestamp
await inngest.send({
  // Use an id specific to the event type & payload
  id: "cart-checkout-completed-ed12c8bde",
  name: "storefront/cart.checkout.completed",
  data: { cartId: "ed12c8bde" },
  user: { external_id: "6463da8211cdbbcb191dd7da" },
  ts: 1684274328198,
  v: "2024-05-15.1"
});
```

### Return values

The function returns a promise that resolves to an object with an array of Event IDs that were sent. These events can be used to look up the event in the Inngest dashboard or via [the REST API](https://api-docs.inngest.com/docs-markdown/inngest-api/pswkqb7u3obet-get-an-event).

```ts
const { ids } = await inngest.send([
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e024befa68763f5b500" }
  },
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e08f29fb563c972b1f7" }
  },
]);
/**
 * ids = [
 *   "01HQ8PTAESBZPBDS8JTRZZYY3S",
 *   "01HQ8PTFYYKDH1CP3C6PSTBZN5"
 * ]
 */
```

## User data encryption üîê

All data sent in the `user` object is fully encrypted at rest.

> **Callout:** ‚ö†Ô∏è When replaying a function, event.user will be empty. This will be fixed in the future, but for now assume that you cannot replay functions that rely on event.user data.

In the future, this object will be used to support programmatic deletion via API endpoint to support certain right-to-be-forgotten flows in your system. This will use the `user.external_id` property for lookup.

## Usage limits

See [usage limits][usage-limits] for more details.

[usage-limits]: /docs-markdown/usage-limits/inngest#events


--------------------------------------------------------------------------------
title: "Create Function"
source: "https://www.inngest.com/docs/reference/functions/create"
--------------------------------------------------------------------------------

# Create Function

Define your functions using the `createFunction` method on the [Inngest client](/docs-markdown/reference/client/create).

```ts
import { inngest } from "./client";

export default inngest.createFunction(
  { id: "import-product-images" },
  { event: "shop/product.imported" },
  async ({ event, step, runId }) => {
    // Your function code
  }
);
```

***

## `inngest.createFunction(configuration, trigger, handler): InngestFunction`

The `createFunction` method accepts a series of arguments to define your function.

### Configuration

- `id` (string): A unique identifier for your function. This should not change between deploys.

* `name` (string): A name for your function. If defined, this will be shown in the UI as a friendly display name instead of the ID.

- `concurrency` (number | object | \[object, object]): Limit the number of concurrently running functions (reference)The maximum number of concurrently running steps.The scope for the concurrency limit, which impacts whether concurrency is managed on an individual function, across an environment, or across your entire account.fn (default):  only the runs of this function affects the concurrency limitenv:  all runs within the same environment that share the same evaluated key value will affect the concurrency limit.  This requires setting a key which evaluates to a virtual queue name.account:  every run that shares the same evaluated key value will affect the concurrency limit, across every environment.  This requires setting a key which evaluates to a virtual queue name.A unique key expression for which to restrict concurrently running steps to. The expression is evaluated for each triggering event and a unique key is generated. Read our guide to writing expressions for more info.

* `throttle` (object): Limits the number of new function runs started over a given period of time (guide).The total number of runs allowed to start within the given period.The period within which the limit will be applied.The number of additional runs allowed to start in the given window in a single burst. This is added on top of the limit, which ensures high throughput within the period.A unique expression for which to apply the throttle limit to. The expression is evaluated for each triggering event and will be applied for each unique value. Read our guide to writing expressions for more info.

- `idempotency` (string): A key expression which is used to prevent duplicate events from triggering a function more than once in 24 hours. This is equivalent to setting rateLimit with a key, a limit of 1  and period of 24hr. Read the idempotency guide here.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Only run once for each customer id: 'event.data.customer\_id'Only run once for each account and email address: 'event.data.account\_id + "-" + event.user.email'

* `rateLimit` (object): Options to configure how to rate limit function execution (reference)The maximum number of functions to run in the given time period.The time period of which to set the limit. The period begins when the first matching event is received.
  Current permitted values are from 1s to 60s.A unique key expression to apply the limit to. The expression is evaluated for each triggering event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Rate limit per customer id: 'event.data.customer\_id'Rate limit per account and email address: 'event.data.account\_id + "-" + event.user.email'

- `debounce` (object): Options to configure function debounce (reference)The time period of which to set the limit. The period begins when the first matching event is received.
  Current permitted values are from 1s to 7d (168h).A unique key expression to apply the debounce to. The expression is evaluated for each triggering event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Debounce per customer id: 'event.data.customer\_id'Debounce per account and email address: 'event.data.account\_id + "-" + event.user.email'

* `priority` (object): Options to configure how to prioritize functionsAn expression which must return an integer between -600 and 600 (by default), with higher return values resulting in a higher priority.Examples:Return the priority within an event directly: event.data.priority (where
  event.data.priority is an int within your account's range)Rate limit by a string field: event.data.plan == 'enterprise' ? 180 : 0See reference for more information.

- `batchEvents` (object): Configure how the function should consume batches of events (reference)The maximum number of events a batch can have. Current limit is 100.How long to wait before invoking the function with the batch even if it's not full.
  Current permitted values are from 1s to 60s.A unique key expression to apply the batching to. The expression is evaluated for each triggering event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Batch events per customer id: 'event.data.customer\_id'Batch events per account and email address: 'event.data.account\_id + "-" + event.user.email'A boolean expression to conditionally batch events that evaluate to true on this expression. The expression is evaluated for each triggering event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Batch events for free account types: 'event.data.account\_type == "free"'

* `retries` (number): Configure the number of times the function will be retried from 0 to 20. Default: 4

- `onFailure` (function): A function that will be called only when this Inngest function fails after all retries have been attempted (reference)

* `cancelOn` (array of objects): Define events that can be used to cancel a running or sleeping function (reference)The event name which will be used to cancelThe property to match the event trigger and the cancelling event, using dot-notation, for example, data.userId. Read our guide to writing expressions for more info.An expression on which to conditionally match the original event trigger (event) and the wait event (async). Cannot be combined with match.Expressions are defined using the Common Expression Language (CEL) with the events accessible using dot-notation. Read our guide to writing expressions for more info. Examples:event.data.userId == async.data.userId && async.data.billing\_plan == 'pro'The amount of time to wait to receive the cancelling event. A time string compatible with the ms package, e.g. "30m", "3 hours", or "2.5d"

- `timeouts` (object): Options to configure timeouts for cancellation (reference)The timeout for starting a function run.  If the time between scheduling and starting a function exceeds this duration, the function will be cancelled.
  Examples are: 10s, 45m, 18h30m.The timeout for executing a run.  If a run takes longer than this duration to execute, the run will be cancelled.  This does not include the
  time waiting for the function to start (see timeouts.start).
  Examples are: 10s, 45m, 18h30m.

### Trigger

One of the following function triggers is **Required**.

You can also specify an array of up to 10 of the following triggers to invoke
your function with multiple events or crons. See the [Multiple Triggers](/docs-markdown/guides/multiple-triggers) guide.

> **Callout:** Cron triggers with overlapping schedules for a single function will be deduplicated.

- `event` (string): The name of the event that will trigger this event to run

* `cron` (string): A unix-cron compatible schedule string. Optional timezone prefix, e.g. TZ=Europe/Paris 0 12 \* \* 5.

When using an `event` trigger, you can optionally combine it with the `if` option to filter events:

- `if` (string): A comparison expression that returns true or false whether the function should handle or ignore a given matching event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:'event.data.action == "published"''event.data.priority >= 4'

### Handler

The handler is your code that runs whenever the trigger occurs. Every function handler receives a single object argument which can be deconstructed. The key arguments are `event` and `step`. Note, that scheduled functions that use a `cron` trigger will not receive an `event` argument.

```ts
function handler({ event, events, step, runId, logger, attempt }) {/* ... */}
```

#### `event`

The event payload `object` that triggered the given function run. The event payload object will match what you send with [`inngest.send()`](/docs-markdown/reference/events/send). Below is an example event payload object:

```ts
{
  name: "app/account.created",
  data: {
    userId: "1234567890"
  },
  v: "2023-05-12.1",
  ts: 1683898268584
}
```

#### `events`&#x20;

`events` is an array of `event` payload objects that's accessible when the `batchEvents` is set on the function configuration.
If batching is not configured, the array contains a single event payload matching the `event` argument.

#### `step`

The `step` object has methods that enable you to define

- [`step.run()`](/docs-markdown/reference/functions/step-run) - Run synchronous or asynchronous code as a retriable step in your function
- [`step.sleep()`](/docs-markdown/reference/functions/step-sleep) - Sleep for a given amount of time
- [`step.sleepUntil()`](/docs-markdown/reference/functions/step-sleep-until) - Sleep until a given time
- [`step.invoke()`](/docs-markdown/reference/functions/step-invoke) - Invoke another Inngest function as a step, receiving the result of the invoked function
- [`step.waitForEvent()`](/docs-markdown/reference/functions/step-wait-for-event) - Pause a function's execution until another event is received
- [`step.sendEvent()`](/docs-markdown/reference/functions/step-send-event) - Send event(s) reliability within your function. Use this instead of `inngest.send()` to ensure reliable event delivery from within functions.

#### `runId`

The unique ID for the given function run. This can be useful for logging and looking up specific function runs in the Inngest dashboard.

#### `logger`&#x20;

The `logger` object exposes the following interfaces.

```ts
export interface Logger {
  info(...args: any[]): void;
  warn(...args: any[]): void;
  error(...args: any[]): void;
  debug(...args: any[]): void;
}
```

It is a proxy object that is either backed by `console` or the logger you provided ([reference](/docs-markdown/guides/logging)).

#### `attempt`&#x20;

The current zero-indexed attempt number for this function execution. The first attempt will be 0, the second 1, and so on. The attempt number is incremented every time the function throws an error and is retried.


--------------------------------------------------------------------------------
title: "Debounce functions&#x20;"
source: "https://www.inngest.com/docs/reference/functions/debounce"
--------------------------------------------------------------------------------

# Debounce functions&#x20;

Debounce delays a function run for the given `period`, and reschedules functions for the given `period` any time new events are received while the debounce is active.  The function run starts after the specified `period` passes and no new events have been received.  Functions use the last event as their input data.

See the [Debounce guide](/docs-markdown/guides/debounce) for more information about how this feature works.

```ts
export default inngest.createFunction(
  {
    id: "handle-webhook",
    debounce: {
      key: "event.data.account_id",
      period: "5m",
    },
  },
  { event: "intercom/company.updated" },
  async ({ event, step }) => {
    // This function will only be scheduled 5m after events have stopped being received with the same
    // `event.data.account_id` field.
    //
    // `event` will be the last event in the series received.
  }
);
```

- `debounce` (object): Options to configure how to debounce function executionThe time delay to delay execution. The period begins when the first matching event is received.Current permitted values are from 1s to 7d (168h).An optional unique key expression to apply the limit to. The expression is evaluated for each triggering event,
  and allows you to debounce against event data.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Rate limit per customer id: 'event.data.customer\_id'Rate limit per account and email address: 'event.data.account\_id + "-" + event.user.email'The maximum time that a debounce can be extended before running.

> **Callout:** Functions will run using the last event received as the input data.

> **Callout:** Debounce cannot be combined with batching.


--------------------------------------------------------------------------------
title: "Handling Failures"
source: "https://www.inngest.com/docs/reference/functions/handling-failures"
--------------------------------------------------------------------------------

# Handling Failures

Define any failure handlers for your function with the [`onFailure`](/docs-markdown/reference/functions/create#configuration) option. This function will be automatically called when your function fails after it's maximum number of retries. Alternatively, you can use the [`"inngest/function.failed"`](#the-inngest-function-failed-event) system event to handle failures across all functions.

```ts
import { inngest } from "./client";

export default inngest.createFunction(
  {
    id: "import-product-images",
    onFailure: async ({ error, event, step }) => {
      // This is the failure handler which can be used to
      // send an alert, notification, or whatever you need to do
    },
  },
  { event: "shop/product.imported" },
  async ({ event, step, runId }) => {
    // This is the main function handler's code
  }
);
```

The failure handler is very useful for:

- Sending alerts to your team
- Sending metrics to a third party monitoring tool (e.g. Datadog)
- Send a notification to your team or user that the job has failed
- Perform a rollback of the transaction (i.e. undo work partially completed by the main handler)

*Failures* should not be confused with *Errors* which will be retried. Read the [error handling & retries documentation](/docs-markdown/functions/retries) for more context.

***

## How `onFailure` works

The `onFailure` handler is a helper that actually creates a separate Inngest function used specifically for handling failures for your main function handler.

The separate Inngest function utilizes an [`"inngest/function.failed"`](#the-inngest-function-failed-event) system event that gets sent to your account any time a function fails. The function created with `onFailure` will appear as a separate function in your dashboard with the name format: `"<Your function name> (failure)"`.

## `onFailure({ error, event, step, runId })`

The `onFailure` handler function has the same arguments as [the main function handler](/docs-markdown/reference/functions/create#handler) when creating a function, but also receives an `error` argument.

### `error`

The JavaScript [`Error`](https://developer.mozilla.org/en-US/docs-markdown/Web/JavaScript/Reference/Global_Objects/Error/Error) object as thrown from the last retry in your main function handler.

> **Callout:** The Inngest SDK attempts to serialize and deserialize the Error object to the best of its ability and any custom error classes (e.g. Prisma.PrismaClientKnownRequestError or MyCustomErrorType) that may be thrown will be deserialized as the default Error object. This means you cannot use instance of within onFailure to infer the type of error.

### `event`

The [`"inngest/function.failed"`](/docs-markdown/reference/system-events/inngest-function-failed) system event payload object. This object is similar to any event payload, but it contains data specific to the failed function's final retry attempt. [See the complete reference for this event payload here](/docs-markdown/reference/system-events/inngest-function-failed).

### `step`

[See the `step` reference in the create function documentation](/docs-markdown/reference/functions/create#step).

### `runId`

This will be the function run ID for the error handling function, *not the function that failed*. To get the failed function's run ID, use `event.data.run_id`. [Learn more about `runId` here](/docs-markdown/reference/functions/create#run-id).

## Examples

### Send a Slack notification when a function fails

In this example, the function attempts to sync all products from a Shopify store, and if it fails, it sends a message to the team's *#eng-alerts* Slack channel using the Slack Web Api's `chat.postMessage` ([docs](https://api.slack.com/methods/chat.postMessage)) API.

```ts
import { client } from "@slack/web-api";
import { inngest } from "./client";

export default inngest.createFunction(
  {
    id: "sync-shopify-products",
    // Your handler should be an async function:
    onFailure: async ({ error, event }) => {
      const originalEvent = event.data.event;

      // Post a message to the Engineering team's alerts channel in Slack:
      const result = await client.chat.postMessage({
        token: process.env.SLACK_TOKEN,
        channel: "C12345",
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: `Sync Shopify function failed for Store ${
                originalEvent.storeId
              }: ${error.toString()}`,
            },
          },
        ],
      });

      return result;
    },
  },
  { event: "shop/product_sync.requested" },
  async ({ event, step, runId }) => {
    // This is the main function handler's code
    const products = await step.run("fetch-products", async () => {
      const storeId = event.data.storeId;
      // The function might fail here or...
    });
    await step.run("save-products", async () => {
      // The function might fail here after the maximum number of retries
    });
  }
);
```

### Capture all failure errors with Sentry

Similar to the above example, you can capture and all failed functions' errors and send them to a singular place. Here's an example using [Sentry's node.js library](https://docs.datadoghq.com/api/latest/events/) to capture and send all failure errors to Sentry.

```ts
import * as Sentry from "@sentry/node";
import { inngest } from "./client";

Sentry.init({
  dsn: "https://examplePublicKey@o0.ingest.sentry.io/0",
});

export default inngest.createFunction(
  {
    name: "Send failures to Sentry",
    id: "send-failed-function-errors-to-sentry"
  },
  { event: "inngest/function.failed" },
  async ({ event, step }) => {

    // The error is serialized as JSON, so we must re-construct it for Sentry's error handling:
    const error = event.data.error;
    const reconstructedEvent = new Error(error.message);
    // Set the name in the newly created event:
    // You can even customize the name here if you'd like,
    // e.g. `Function Failure: ${event.} - ${error.name}`
    reconstructedEvent.name = error.name;

    // Add the stack trace to the error:
    reconstructedEvent.stack = error.stack;

    // Capture the error with Sentry and append any additional tags or metadata:
    Sentry.captureException(reconstructedEvent,{
      extra: {
        function_id,
      },
    });

    // Flush the Sentry queue to ensure the error is sent:
    return await Sentry.flush();
  }
);
```

### Additional examples


--------------------------------------------------------------------------------
title: "Rate limit function execution"
source: "https://www.inngest.com/docs/reference/functions/rate-limit"
--------------------------------------------------------------------------------

# Rate limit function execution

Set a *hard limit* on how many function runs can start within a time period. Events that exceed the rate limit are *skipped* and do not trigger functions to start.

See the [Rate Limiting guide](/docs-markdown/guides/rate-limiting) for more information about how this feature works.

```ts
export default inngest.createFunction(
  {
    id: "synchronize-data",
    rateLimit: {
      key: "event.data.company_id",
      limit: 1,
      period: "4h",
    },
  },
  { event: "intercom/company.updated" },
  async ({ event, step }) => {
    // This function will be rate limited
    // It will only run 1 once per 4 hours for a given event payload with matching company_id
  }
);
```

## Configuration

- `rateLimit` (object): Options to configure how to rate limit function executionThe maximum number of functions to run in the given time period.The time period of which to set the limit. The period begins when the first matching event is received.
  Current permitted values are from 1s to 24h.A unique key expression to apply the limit to. The expression is evaluated for each triggering event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Rate limit per customer id: 'event.data.customer\_id'Rate limit per account and email address: 'event.data.account\_id + "-" + event.user.email'

## Examples

### Limiting synchronization triggered by webhook events

In this example, we use events from the Intercom webhook. The webhook can be overly chatty and send multiple `intercom/company.updated` events in a short time window. We also only really care to sync the user's data from Intercom no more than 4 times per day, so we set our limit to `6h`:

```ts
/** Example event payload:
{
  name: "intercom/company.updated",
  data: {
    company_id: "123456789",
    company_name: "Acme, Inc."
  }
}
*/
export default inngest.createFunction(
  {
    id: "synchronize-data",
    rateLimit: {
      key: "event.data.company_id",
      limit: 1,
      period: "4h",
    },
  },
  { event: "intercom/company.updated" },
  async ({ event, step }) => {
    const company = await step.run(
      "fetch-latest-company-data-from-intercom",
      async () => {
        return await client.companies.find({
          companyId: event.data.company_id,
        });
      }
    );

    await step.run("update-company-data-in-database", async () => {
      return await database.companies.upsert({ id: company.id }, company);
    });
  }
);
```

### Send at most one email for multiple alerts over an hour

When there is an issue in your system, you may want to send your user an email notification, but don't want to spam them. The issue may repeat several times within the span of few minutes, but the user really just needs one email. You can

```ts
/** Example event payload:
{
  name: "service/check.failed",
  data: {
    incident_id: "01HB9PWHZ4CZJYRAGEY60XEHCZ",
    issue: "HTTP uptime check failed at 2023-09-26T21:23:51.515631317Z",
    user_id: "user_aW5uZ2VzdF9pc19mdWNraW5nX2F3ZXNvbWU=",
    service_name: "api",
    service_id: "01HB9Q2EFBYG2B7X8VCD6JVRFH"
  },
  user: {
    external_id: "user_aW5uZ2VzdF9pc19mdWNraW5nX2F3ZXNvbWU=",
    email: "user@example.com"
  }
}
*/
export default inngest.createFunction(
  {
    id: "send-check-failed-notification",
    rateLimit: {
      // Don't send duplicate emails to the same user for the same service over 1 hour
      key: `event.data.user_id + "-" + event.data.service_id`,
      limit: 1,
      period: "1h",
    },
  },
  { event: "service/check.failed" },
  async ({ event, step }) => {
    await step.run("send-alert-email", async () => {
      return await resend.emails.send({
        from: "notifications@myco.com",
        to: event.user.email,
        subject: `ALERT: ${event.data.issue}`,
        text: `Dear user, ...`,
      });
    });
  }
);
```


--------------------------------------------------------------------------------
title: "Function run priority&#x20;"
source: "https://www.inngest.com/docs/reference/functions/run-priority"
--------------------------------------------------------------------------------

# Function run priority&#x20;

You can prioritize specific function runs above other runs **within the same function**.

See the [Priority guide](/docs-markdown/guides/priority) for more information about how this feature works.

```ts
export default inngest.createFunction(
  {
    id: "ai-generate-summary",
    priority: {
      // For enterprise accounts, a given function run will be prioritized
      // ahead of functions that were enqueued up to 120 seconds ago.
      // For all other accounts, the function will run with no priority.
      run: "event.data.account_type == 'enterprise' ? 120 : 0",
    },
  },
  { event: "ai/summary.requested" },
  async ({ event, step }) => {
    // This function will be prioritized based on the account type
  }
);
```

## Configuration

- `priority` (object): Options to configure how to prioritize functionsAn expression which must return an integer between -600 and 600 (by default), with higher return
  values resulting in a higher priority.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Return the priority within an event directly: event.data.priority (where
  event.data.priority is an int within your account's range)Prioritize by a string field: event.data.plan == 'enterprise' ? 180 : 0

> **Callout:** Return values outside of your account's range (by default, -600 to 600) will automatically be clipped
> to your max bounds.An invalid expression will evaluate to 0, as in "no priority".


--------------------------------------------------------------------------------
title: "Ensure exclusive execution of a function"
source: "https://www.inngest.com/docs/reference/functions/singleton"
--------------------------------------------------------------------------------

# Ensure exclusive execution of a function

Ensure that only a single run of a function (*or a set of specific functions, based on specific event properties*) is running at a time.

See the [Singleton Functions guide](/docs-markdown/guides/singleton) for more information about how this feature works.

```ts
export default inngest.createFunction(
  {
    id: "data-sync",
    singleton: {
      key: "event.data.user_id",
      mode: "skip",
    },
  },
  { event: "data-sync.start" },
  async ({ event }) => {
    // This function will be skipped if another run of the same function is already running for the same user
  }
);
```

## Configuration

- `singleton` (object): Options to configure exclusive execution of a function.A unique key expression to which the limit is applied. This expression is evaluated for each triggering event.Expressions are defined using the Common Expression Language (CEL) with the original event accessible using dot-notation. Read our guide to writing expressions for more info. Examples:Ensure exclusive execution of a function per customer ID: 'event.data.customer\_id'Ensure exclusive execution of a function per account and email address: 'event.data.account\_id + "-" + event.user.email'The mode to use for the singleton function:"skip": Skip the new run."cancel": Cancel the existing run and start the new one.


--------------------------------------------------------------------------------
title: "Invoke&#x20;"
source: "https://www.inngest.com/docs/reference/functions/step-invoke"
--------------------------------------------------------------------------------

# Invoke&#x20;

Use `step.invoke()` to asynchronously call another function and handle the result. Invoking other functions allows you to easily re-use functionality and compose them to create more complex workflows or map-reduce type jobs. `step.invoke()` returns a `Promise` that resolves with the return value of the invoked function.

```ts
// Some function we'll call
const computeSquare = inngest.createFunction(
  { id: "compute-square" },
  { event: "calculate/square" },
  async ({ event }) => {
    return { result: event.data.number * event.data.number }; // Result typed as { result: number }
  }
);

// In this function, we'll call `computeSquare`
const mainFunction = inngest.createFunction(
  { id: "main-function" },
  { event: "main/event" },
  async ({ step }) => {
    const square = await step.invoke("compute-square-value", {
      function: computeSquare,
      data: { number: 4 }, // input data is typed, requiring input if it's needed
    });

    return `Square of 4 is ${square.result}.`; // square.result is typed as number
  }
);
```

## `step.invoke(id, options): Promise`

- `id` (string): The ID of the invocation. This is used in logs and to keep track of the invocation's state across different versions.

* `options` (object): Options for the invocation:A local instance of a function or a reference to a function to invoke.Optional data to pass to the invoked function. Will be required and typed if it can be.Optional user context for the invocation./\* Purposefully not mentioning the default timeout of 1 year, as we expect to lower this very soon. \*/The amount of time to wait for the invoked function to complete. The time to wait can be specified using a number of milliseconds, an ms-compatible time string like "1 hour", "30 mins", or "2.5d", or a Date object.If the timeout is reached, the step will throw an error. See Error handling below. Note that the invoked function will continue to run even if this step times out.Throwing errors within the invoked function will be reflected in the invoking function.

```ts
const resultFromDirectCall = await step.invoke("invoke-by-definition", {
  function: anotherFunction,
  data: { ... },
});
```

```ts
const resultFromReference = await step.invoke("invoke-by-reference", {
  function: referenceFunction(...),
  data: { ... },
});
```

```ts
const resultFromDirectCall = await step.invoke("invoke-with-timeout", {
  function: anotherFunction,
  data: { ... },
  timeout: "1h",
});
```

## How to call `step.invoke()`

Handling `step.invoke()` is similar to handling any other Promise in JavaScript:

```ts
// Using the "await" keyword
const result = await step.invoke("invoke-function", {
  function: someInngestFn,
  data: { ... },
});

// Using `then` for chaining
step
  .invoke("invoke-function", { function: someInngestFn, data: { ... } })
  .then((result) => {
    // further processing
  });

// Running multiple invocations in parallel
Promise.all([
  step.invoke("invoke-first-function", {
    function: firstFunctionReference,
    data: { ... },
  }),
  step.invoke("invoke-second-function", {
    function: secondFn,
    data: { ... },
  }),
]);
```

## Using function references

Instead of directly importing a local function to invoke, [`referenceFunction()`](/docs-markdown/functions/references) can be used to call an Inngest function located in another app, or to avoid importing the dependencies of a function within the same app.

```ts
import { referenceFunction } from "inngest";
import { type computePi } from "@/inngest/computePi";

// Create a local reference to a function without importing dependencies
const computePi = referenceFunction<typeof computePi>({
  functionId: "compute-pi",
});

// Create a reference to a function in another application
const computeSquare = referenceFunction({
  appId: "my-python-app",
  functionId: "compute-square",
});

// square.result is typed as a number
const square = await step.invoke("compute-square-value", {
  function: computePi,
  data: { number: 4 }, // input data is typed, requiring input if it's needed
});
```

See [Referencing functions](/docs-markdown/functions/references) for more information.

## When to use `step.invoke()`

Use of `step.invoke()` to call an Inngest function directly is more akin to traditional RPC than Inngest's usual event-driven flow. While this tool still uses events behind the scenes, you can use it to help break up your codebase into reusable workflows that can be called from anywhere.

Use `step.invoke()` in tasks that need specific settings like concurrency limits. Because it runs with its own configuration,
distinct from the invoker's, you can provide a tailored configuration for each function.

If you don't need to define granular configuration or if your function won't be reused across app boundaries, use `step.run()` for simplicity.

## Internal behaviour

When a function object is passed as an argument, internally, the SDK retrieves the function's ID automatically. Alternatively, if a function ID `string` is passed, the Inngest SDK will assert the ID is correct at runtime. See [Error handling](#error-handling) for more information about this point.

When Inngest receives the request to invoke a function, it'll do so and wait for an `inngest/function.finished` event, which it will use to fulfil the data (or error) for the step.

## Return values and serialization

Similar to `step.run()`, all data returned from `step.invoke()` is serialized as JSON. This is done to enable the SDK to return a valid serialized response to the Inngest service.

## Timeout

If not explicity configured, the default timeout for `step.invoke` is 1 year.

## Retries

The invoked function will be executed as a regular Inngest function: it will have its own set of retries and can be seen as a brand new run.

If a `step.invoke()` fails for any of the reasons below, it will throw a `NonRetriableError`. This is to combat compounding retries, such that chains of invoked functions can be executed many more times than expected. For example, if A invokes B which invokes C, which invokes D, on failure D would be run 27 times (`retryCount^n`).

This may change on the future - [let us know](https://roadmap.inngest.com/roadmap?ref=docs) if you'd like to change this.

## Error handling

### Function not found

If Inngest could not find a function to invoke using the given ID (see [Internal behaviour](#internal-behaviour) above), an `inngest/function.finished` event will be sent with an appropriate error and the step will fail with a `NonRetriableError`.

### Invoked function fails

If the function exhausts all retries and fails, an `inngest/function.finished`
event will be sent with an appropriate error and the step will fail with a
`NonRetriableError`.

### Invoked function times out

If the `timeout` has been reached and the invoked function is still running, the
step will fail with a `NonRetriableError`.

### Invoked function is rate limited

If the called function has a rate limit configuration and is skipped, the step will fail with a `NonRetriableError`.
It's recommended to wrap the `step.invoke` with a `try catch` if the invoked function is expected to be executing occasionally.

### Invoked function is debounced

If the called function has a debounce configuration and is skipped, the step will fail with a `NonRetriableError` after the timeout has been reached. It is preferable to always set a meaningful timeout when invoking a function with debounce configuration.

## Usage limits

See [usage limits][usage-limits] for more details.

[usage-limits]: /docs-markdown/usage-limits/inngest#functions


--------------------------------------------------------------------------------
title: "Run"
source: "https://www.inngest.com/docs/reference/functions/step-run"
--------------------------------------------------------------------------------

# Run

Use `step.run()` to run synchronous or asynchronous code as a retriable step in your function. `step.run()` returns a [Promise](https://developer.mozilla.org/en-US/docs-markdown/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with the return value of your handler function.

```ts
export default inngest.createFunction(
  { id: "import-product-images" },
  { event: "shop/product.imported" },
  async ({ event, step }) => {
    const uploadedImageURLs = await step.run("copy-images-to-s3", async () => {
      return copyAllImagesToS3(event.data.imageURLs);
    });
  }
);
```

***

## `step.run(id, handler): Promise`

- `id` (string): The ID of the step. This will be what appears in your function's logs and is used to memoize step state across function versions.

* `handler` (function): The function that code that you want to run and automatically retry for this step. Functions can be:A synchronous functionAn async functionAny function that returns a PromiseThrowing errors within the handler function will trigger the step to be retried (reference).

```ts
// Steps can have async handlers
const result = await step.run("get-api-data", async () => {
  // Steps should return data used in other steps
  return fetch("...").json();
});

// Steps can have synchronous handlers
const data = await step.run("transform", () => {
  return transformData(result);
});

// Returning data is optional
await step.run("insert-data", async () => {
  db.insert(data);
});
```

## How to call `step.run()`

As `step.run()` returns a [Promise](https://developer.mozilla.org/en-US/docs-markdown/Web/JavaScript/Reference/Global_Objects/Promise), you will need to handle it like any other Promise in JavaScript. Here are some ways you can use `step.run()` in your code:

```ts
// Use the "await" keyword to wait for the promise to fulfil
await step.run("create-user", () => {/* ... */});
const user = await step.run("create-user", () => {/* ... */});

// Use `then` (or similar)
step.run("create-user", () => {/* ... */})
  .then((user) => {
    // do something else
  });

// Use with a Promise helper function to run in parallel
Promise.all([
  step.run("create-subscription", () => {/* ... */}),
  step.run("add-to-crm", () => {/* ... */}),
  step.run("send-welcome-email", () => {/* ... */}),
]);
```

## Retries

Each `step.run()` call has its own independent retry counter. When a step throws an error, it will be retried according to your function's retry configuration. The retry configuration applies to each individual step, not as a shared pool across all steps in your function.

For example, if your function is configured with `retries: 4`, each `step.run()` will be retried up to 4 times independently (5 total attempts including the initial attempt). If you have multiple steps in your function, each step gets its own full set of retries.

Learn more about [configuring retries](/docs-markdown/features/inngest-functions/error-retries/retries).

## Return values and serialization

All data returned from `step.run` is serialized as JSON. This is done to enable the SDK to return a valid serialized response to the Inngest service.

```ts
const output = await step.run("create-user", () => {
  return { id: new ObjectId(), createdAt: new Date() };
});
/*
{
  "id": "647731d1759aa55be43b975d",
  "createdAt": "2023-05-31T11:39:18.097Z"
}
*/
```

## Usage limits

See [usage limits][usage-limits] for more details.

[usage-limits]: /docs-markdown/usage-limits/inngest#functions


--------------------------------------------------------------------------------
title: "Send Event"
source: "https://www.inngest.com/docs/reference/functions/step-send-event"
--------------------------------------------------------------------------------

# Send Event

Use to send event(s) reliably within your function. Use this instead of [`inngest.send()`](/docs-markdown/reference/events/send) to ensure reliable event delivery from within functions. This is especially useful when [creating functions that fan-out](/docs-markdown/guides/fan-out-jobs).

```ts {{ title: "v3" }}
export default inngest.createFunction(
  { id: "user-onboarding" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    // Do something
    await step.sendEvent("send-activation-event", {
      name: "app/user.activated",
      data: { userId: event.data.userId },
    });
    // Do something else
  }
);
```

```ts {{ title: "v2" }}
export default inngest.createFunction(
  { name: "User onboarding" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    // Do something
    await step.sendEvent({
      name: "app/user.activated",
      data: { userId: event.data.userId },
    });
    // Do something else
  }
);
```

To send events from outside of the context of a function, use [`inngest.send()`](/docs-markdown/reference/events/send).

***

## `step.sendEvent(id, eventPayload | eventPayload[]): Promise<{ ids: string[] }>`

- `id` (string): The ID of the step. This will be what appears in your function's logs and is used to memoize step state across function versions.

* `eventPayload` (object | object\[]): An event payload object or an array of event payload objects.See the documentation for inngest.send() for the event payload format.

```ts {{ title: "v3" }}
// Send a single event
await step.sendEvent("send-activation-event", {
  name: "app/user.activated",
  data: { userId: "01H08SEAXBJFJNGTTZ5TAWB0BD" },
});

// Send an array of events
await step.sendEvent("send-invoice-events", [
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e024befa68763f5b500" },
  },
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e08f29fb563c972b1f7" },
  },
]);
```

```ts {{ title: "v2" }}
// Send a single event
await step.sendEvent({
  name: "app/user.activated",
  data: { userId: "01H08SEAXBJFJNGTTZ5TAWB0BD" },
});

// Send an array of events
await step.sendEvent([
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e024befa68763f5b500" },
  },
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e08f29fb563c972b1f7" },
  },
]);
```

> **Callout:** step.sendEvent() must be called using await or some other Promise handler to ensure your function sleeps correctly.

### Return values

The function returns a promise that resolves to an object with an array of Event IDs that were sent. These events can be used to look up the event in the Inngest dashboard or via [the REST API](https://api-docs.inngest.com/docs-markdown/inngest-api/pswkqb7u3obet-get-an-event).

```ts
const { ids } = await step.sendEvent([
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e024befa68763f5b500" }
  },
  {
    name: "app/invoice.created",
    data: { invoiceId: "645e9e08f29fb563c972b1f7" }
  },
]);
/**
 * ids = [
 *   "01HQ8PTAESBZPBDS8JTRZZYY3S",
 *   "01HQ8PTFYYKDH1CP3C6PSTBZN5"
 * ]
 */
```


--------------------------------------------------------------------------------
title: "Sleep until `step.sleepUntil()`"
source: "https://www.inngest.com/docs/reference/functions/step-sleep-until"
--------------------------------------------------------------------------------

# Sleep until `step.sleepUntil()`

## `step.sleepUntil(id, datetime): Promise`

- `id` (string): The ID of the step. This will be what appears in your function's logs and is used to memoize step state across function versions.

* `datetime` (Date | string | Temporal.Instant | Temporal.ZonedDateTime): The datetime at which to continue execution of your function. This can be:A Date objectAny date time string in the format accepted by the Date object, i.e. YYYY-MM-DDTHH:mm:ss.sssZ or simplified forms like YYYY-MM-DD or YYYY-MM-DDHH:mm:ss Temporal.Instant Temporal.ZonedDateTime

```ts {{ title: "v3" }}
// Sleep until the new year
await step.sleepUntil("happy-new-year", "2024-01-01");

// Sleep until September ends
await step.sleepUntil("wake-me-up", "2023-09-30T11:59:59");

// Sleep until the end of the this week
const date = dayjs().endOf("week").toDate();
await step.sleepUntil("wait-for-end-of-the-week", date);

// Sleep until tea time in London
const teaTime = Temporal.ZonedDateTime.from("2025-05-01T16:00:00+01:00[Europe/London]");
await step.sleepUntil("british-tea-time", teaTime);

// Sleep until the end of the day
const now = Temporal.Now.instant();
const endOfDay = now.round({ smallestUnit: "day", roundingMode: "ceil" });
await step.sleepUntil("done-for-today", endOfDay);
```

```ts {{ title: "v2" }}
// Sleep until the new year
await step.sleepUntil("2024-01-01");

// Sleep until September ends
await step.sleepUntil("2023-09-30T11:59:59");

// Sleep until the end of the this week
const date = dayjs().endOf('week').toDate();
await step.sleepUntil(date)
```

> **Callout:** step.sleepUntil() must be called using await or some other Promise handler to ensure your function sleeps correctly.


--------------------------------------------------------------------------------
title: "Sleep `step.sleep()`"
source: "https://www.inngest.com/docs/reference/functions/step-sleep"
--------------------------------------------------------------------------------

# Sleep `step.sleep()`

## `step.sleep(id, duration): Promise`

- `id` (string): The ID of the step. This will be what appears in your function's logs and is used to memoize step state across function versions.

* `duration` (number | string | Temporal.Duration): The duration of time to sleep:number of millisecondsstring compatible with the ms package, e.g. "30m", "3 hours", or "2.5d" Temporal.Duration

```ts {{ title: "v3" }}
// Sleep for 30 minutes
const thirtyMins = Temporal.Duration.from({ minutes: 30 });
await step.sleep("wait-with-temporal", thirtyMins);

await step.sleep("wait-with-string", "30m");
await step.sleep("wait-with-string-alt", "30 minutes");
await step.sleep("wait-with-ms", 30 * 60 * 1000);
```

```ts {{ title: "v2" }}
// Sleep for 30 minutes
await step.sleep("30m");
await step.sleep("30 minutes");
await step.sleep(30 * 60 * 1000);
```

> **Callout:** step.sleep() must be called using await or some other Promise handler to ensure your function sleeps correctly.


--------------------------------------------------------------------------------
title: "Wait for event"
source: "https://www.inngest.com/docs/reference/functions/step-wait-for-event"
--------------------------------------------------------------------------------

# Wait for event

## `step.waitForEvent(id, options): Promise<null | EventPayload>`

- `id` (string): The ID of the step. This will be what appears in your function's logs and is used to memoize step state across function versions.

* `options` (object): Options for configuring how to wait for the event.The name of a given event to wait for.The amount of time to wait to receive the event. A time string compatible with the ms package, e.g. "30m", "3 hours", or "2.5d"The property to match the event trigger and the wait event, using dot-notation, e.g. data.userId. Cannot be combined with if.An expression on which to conditionally match the original event trigger (event) and the wait event (async). Cannot be combined with match.\*\*Expressions are defined using the Common Expression Language (CEL) with the events accessible using dot-notation. Read our guide to writing expressions for more info. Examples:event.data.userId == async.data.userId && async.data.billing\_plan == 'pro'

```ts {{ title: "v3" }}
// Wait 7 days for an approval and match invoice IDs
const approval = await step.waitForEvent("wait-for-approval", {
  event: "app/invoice.approved",
  timeout: "7d",
  match: "data.invoiceId",
});

// Wait 30 days for a user to start a subscription
// on the pro plan
const subscription = await step.waitForEvent("wait-for-subscription", {
  event: "app/subscription.created",
  timeout: "30d",
  if: "event.data.userId == async.data.userId && async.data.billing_plan == 'pro'",
});
```

```ts {{ title: "v2" }}
// Wait 7 days for an approval and match invoice IDs
const approval = await step.waitForEvent("app/invoice.approved", {
  timeout: "7d",
  match: "data.invoiceId",
});

// Wait 30 days for a user to start a subscription
// on the pro plan
const subscription = await step.waitForEvent("app/subscription.created", {
  timeout: "30d",
  if: "event.data.userId == async.data.userId && async.data.billing_plan == 'pro'",
});
```

> **Callout:** step.waitForEvent() must be called using await or some other Promise handler to ensure your function sleeps correctly.


--------------------------------------------------------------------------------
title: "Example middleware&#x20;"
source: "https://www.inngest.com/docs/reference/middleware/examples"
--------------------------------------------------------------------------------

# Example middleware&#x20;

The following examples show how you might use middleware in some real-world scenarios.

- [Cloudflare Workers AI](#cloudflare-workers-ai)
- [Common actions for every function](#common-actions-for-every-function)
- [Logging](#logging)
- [Prisma in function context](#prisma-in-function-context)
- [Cloudflare Workers & Hono environment variables](/docs-markdown/examples/middleware/cloudflare-workers-environment-variables)

***

## Cloudflare Workers AI

[Workers AI](https://developers.cloudflare.com/workers-ai/) allows you to run machine learning models, on the Cloudflare network, from your own code, triggered by Inngest.

To use the `@cloudflare/ai` package, you need access to the `env` object passed to a Workers route handler. This argument is usually abstracted away by a serve handler, but middleware can access arguments passed to the request.

Use this along with [mutating function input](/docs-markdown/reference/middleware/typescript#mutating-input) to set a new `ai` property that you can use within functions, like in the following example:

```ts
import { InngestMiddleware } from "inngest";

interface Env {
  // If you set another name in wrangler.toml as the value for 'binding',
  // replace "AI" with the variable name you defined.
  AI: Ai;
}

export const cloudflareMiddleware = new InngestMiddleware({
  name: "Inngest: Workers AI",
  init: () => {
    return {
      onFunctionRun: ({ reqArgs }) => {
        const [ctx] = reqArgs as [Request, Env];
        const ai = ctx.env.AI

        return {
          transformInput: () => {
            return { ctx: { ai } };
          },
        };
      },
    };
  },
});
```

```ts
import { inngest } from "./client";

export default inngest.createFunction(
  { id: "hello-world" },
  { event: "demo/event.sent" },
  async ({ ai }) => {
    // `ai` is typed and can be used directly or within a step
    const response = await ai.run("@cf/meta/llama-2-7b-chat-int8", {
      prompt: "What is the origin of the phrase Hello, World",
    });
  }
);
```

## Common actions for every function

You likely reuse the same steps across many functions - whether it be fetching user data or sending an email, your app is hopefully full of reusable blocks of code.

We could add some middleware to pass these into any Inngest function, automatically wrapping them in `step.run()` and allowing the code inside our function to feel a little bit cleaner.

```ts
/**
 * Pass to a client to provide a set of actions as steps to all functions, or to
 * a function to provide a set of actions as steps only to that function.
 */
const inngest = new Inngest({
  id: "my-app",
  middleware: [
    createActionsMiddleware({
      getUser(id: string) {
        return db.user.get(id);
      },
    }),
  ],
});

inngest.createFunction(
  { id: "user-data-dump" },
  { event: "app/data.requested" },
  async ({ event, action: { getUser } }) => {
    // The first parameter is the step's options or ID
    const user = await getUser("get-user-details", event.data.userId);
  }
);
```

```ts
import { InngestMiddleware, StepOptionsOrId } from "inngest";

/**
 * Create a middleware that wraps a set of functions in step tooling, allowing
 * them to be invoked directly instead of using `step.run()`.
 *
 * This is useful for providing a set of common actions to a particular function
 * or to all functions created by a client.
 */
export const createActionsMiddleware = <T extends Actions>(rawActions: T) => {
  return new InngestMiddleware({
    name: "Inngest: Actions",
    init: () => {
      return {
        onFunctionRun: () => {
          return {
            transformInput: ({ ctx: { step } }) => {
              const action: FilterActions<T> = Object.entries(
                rawActions
              ).reduce((acc, [key, value]) => {
                if (typeof value !== "function") {
                  return acc;
                }

                const action = (
                  idOrOptions: StepOptionsOrId,
                  ...args: unknown[]
                ) => {
                  return step.run(idOrOptions, () => value(...args));
                };

                return {
                  ...acc,
                  [key]: action,
                };
              }, {} as FilterActions<T>);

              return {
                ctx: { action },
              };
            },
          };
        },
      };
    },
  });
};

type Actions = Record<string, unknown>;

/**
 * Filter out all keys from `T` where the associated value does not match type
 * `U`.
 */
type KeysNotOfType<T, U> = {
  [P in keyof T]: T[P] extends U ? never : P;
}[keyof T];

/**
 * Given a set of generic objects, extract any top-level functions and
 * appropriately shim their types.
 *
 * We use this type to allow users to spread a set of functions into the
 * middleware without having to worry about non-function properties.
 */
type FilterActions<Fns extends Record<string, any>> = {
  [K in keyof Omit<Fns, KeysNotOfType<Fns, (...args: any[]) => any>>]: (
    idOrOptions: StepOptionsOrId,
    ...args: Parameters<Fns[K]>
  ) => Promise<Awaited<ReturnType<Fns[K]>>>;
};
```

## Logging

The following shows you how you can create a logger middleware and customize it to your needs.

It is based on the [built-in logger middleware](/docs-markdown/guides/logging) in the SDK, and hope it gives you an idea of what you can do if the built-in logger doesn't meet your needs.

```ts
new InngestMiddleware({
  name: "Inngest: Logger",
  init({ client }) {
    return {
      onFunctionRun(arg) {
        const { ctx } = arg;
        const metadata = {
          runID: ctx.runId,
          eventName: ctx.event.name,
          functionName: arg.fn.name,
        };

        let providedLogger: Logger = client["logger"];
        // create a child logger if the provided logger has child logger implementation
        try {
          if ("child" in providedLogger) {
            type ChildLoggerFn = (
              metadata: Record<string, unknown>
            ) => Logger;
            providedLogger = (providedLogger.child as ChildLoggerFn)(metadata)
          }
        } catch (err) {
          console.error('failed to create "childLogger" with error: ', err);
          // no-op
        }
        const logger = new ProxyLogger(providedLogger);

        return {
          transformInput() {
            return {
              ctx: {
                /**
                 * The passed in logger from the user.
                 * Defaults to a console logger if not provided.
                 */
                logger,
              },
            };
          },
          beforeExecution() {
            logger.enable();
          },
          transformOutput({ result: { error } }) {
            if (error) {
              logger.error(error);
            }
          },
          async beforeResponse() {
            await logger.flush();
          },
        };
      },
    };
  },
})
```

***

## Prisma in function context

The following is an example of adding a [Prisma](https://www.prisma.io/?ref=inngest) client to all Inngest functions, allowing them immediate access without needing to create the client themselves.

While this example uses Prisma, it serves as a good example of using the [onFunctionRun -> input](/docs-markdown/reference/middleware/lifecycle#on-function-run-lifecycle) hook to mutate function input to perform crucial setup for your functions and keep them to just business logic.

> **Callout:** üí° Types are inferred from middleware outputs, so your Inngest functions will see an appropriately-typed prisma property in their input.

```ts
inngest.createFunction(
  { name: "Example" },
  { event: "app/user.loggedin" },
  async ({ prisma }) => {
    await prisma.auditTrail.create(/* ... */);
  }
);
```

```ts
import { PrismaClient } from "@prisma/client";

const prismaMiddleware = new InngestMiddleware({
  name: "Prisma Middleware",
  init() {
    const prisma = new PrismaClient();

    return {
      onFunctionRun(ctx) {
        return {
          transformInput(ctx) {
            return {
              // Anything passed via `ctx` will be merged with the function's arguments
              ctx: {
                prisma,
              },
            };
          },
        };
      },
    };
  },
});
```

Check out [Common actions for every function](/docs-markdown/reference/middleware/examples#common-actions-for-every-function) to see how this technique can be used to create steps for all of your unique logic.

## Other examples

**Cloudflare Workers & Hono middleware**: [Access environment variables within Inngest functions.]('/docs-markdown/examples/middleware/cloudflare-workers-environment-variables')


--------------------------------------------------------------------------------
title: "Middleware lifecycle&#x20;"
source: "https://www.inngest.com/docs/reference/middleware/lifecycle"
--------------------------------------------------------------------------------

# Middleware lifecycle&#x20;

## Hook reference

The `init()` function can return functions for two separate lifecycles to hook into.

> **Callout:** üí° All lifecycle and hook functions can be synchronous or async functions - the SDK will always wait until a middleware's function has resolved before continuing to the next one.

### `onFunctionRun` lifecycle

Triggered when a function is going to be executed.

- `ctx` (object): The input data for the function. Only event and runId are available at this point.

* `steps` (array): An array of previously-completed step objects.The serialized data for this step if it was successful.The serialized error for this step if it failed.

- `fn` (InngestFunction): The function that is about to be executed.

* `reqArgs` (array): Arguments passed to the framework's request handler, which are used by the SDK's serve handler.

- `transformInput` (function): Called once the input for the function has been set up. This is where you can modify the input before the function starts.Has the same input as the containing onFunctionRun() lifecycle function, but with a complete ctx object, including step tooling.An object that will be merged with the existing function input to create a new input.An array of modified step data to use in place of the current step data.

* `beforeMemoization` (function): Called before the function starts to memoize state (running over previously-seen code).

- `afterMemoization` (function): Called after the function has finished memoizing state (running over previously-seen code).

* `beforeExecution` (function): Called before any step or code executes.

- `afterExecution` (function): Called after any step or code has finished executing.

* `transformOutput` (function): Called after the function has finished executing and before the response is sent back to Inngest. This is where you can modify the output.An object containing the data to be sent back to Inngest in the data key, and an original error (if any) that threw\.If this execution ran a step, will be a step that ran.An object containing a data key to overwrite the data that will be sent back to Inngest for this step or function.

- `finished` (function): Called when execution is complete and a final response is returned (success or an error), which will end the run.This function is not guaranteed to be called on every execution. It may be called multiple times if there are many parallel executions or during retries.An object that contains either the successful data ending the run or the error that has been thrown. Both outputs have already been affected by transformOutput.

* `beforeResponse` (function): Called after the output has been set and before the response has been sent back to Inngest. Use this to perform any final actions before the request closes.

```ts
const myMiddleware = new InngestMiddleware({
  name: "My Middleware",
  init({ client, fn }) {
    return {
      onFunctionRun({ ctx, fn, steps }) {
        return {
          transformInput({ ctx, fn, steps }) {
            // ...
            return {
              // All returns are optional
              ctx: { /* extend fn input */ },
              steps: steps.map(({ data }) => { /* transform step data */ })
            }
          },
          beforeMemoization() {
            // ...
          },
          afterMemoization() {
            // ...
          },
          beforeExecution() {
            // ...
          },
          afterExecution() {
            // ...
          },
          transformOutput({ result, step }) {
            // ...
            return {
              // All returns are optional
              result: {
                // Transform data before it goes back to Inngest
                data: transformData(result.data)
              }
            }
          },
          finished({ result }) {
            // ...
          },
          beforeResponse() {
            // ...
          },
        };
      },
    };
  },
});
```

***

### `onSendEvent` lifecycle

Triggered when an event is going to be sent via `inngest.send()`, `step.sendEvent()`, or `step.invoke()`.

- `transformInput` (function): Called before the events are sent to Inngest. This is where you can modify the events before they're sent.

* `transformOutput` (function): Called after events are sent to Inngest. This is where you can perform any final actions and modify the output from inngest.send().

```ts
const myMiddleware = new InngestMiddleware({
  name: "My Middleware",
  init: ({ client, fn }) => {
    return {
      onSendEvent() {
        return {
          transformInput({ payloads }) {
            // ...
          },
          transformOutput() {
            // ...
          },
        };
      },
    };
  },
});
```


--------------------------------------------------------------------------------
title: "REST API"
source: "https://www.inngest.com/docs/reference/rest-api"
--------------------------------------------------------------------------------

# REST API

You can view our REST API docs at our API reference portal: [https://api-docs.inngest.com/docs-markdown/inngest-api](https://api-docs.inngest.com/docs/inngest-api).


--------------------------------------------------------------------------------
title: "Serve"
source: "https://www.inngest.com/docs/reference/serve"
--------------------------------------------------------------------------------

# Serve

The `serve()` API handler is used to serve your application's [functions](/docs-markdown/reference/functions/create) via HTTP. This handler enables Inngest to remotely and securely read your functions' configuration and invoke your function code. This enables you to host your function code on any platform.

```ts {{ title: "v3" }}
import { serve } from "inngest/next"; // or your preferred framework
import { inngest } from "./client";
import {
  importProductImages,
  sendSignupEmail,
  summarizeText,
} from "./functions";

serve({
  client: inngest,
  functions: [sendSignupEmail, summarizeText, importProductImages],
});
```

```ts {{ title: "v2" }}
import { serve } from "inngest/next"; // or your preferred framework
import { inngest } from "./client";
import {
  importProductImages,
  sendSignupEmail,
  summarizeText,
} from "./functions";

serve(inngest, [sendSignupEmail, summarizeText, importProductImages]);
```

`serve` handlers are imported from convenient framework-specific packages like `"inngest/next"`, `"inngest/express"`, or `"inngest/lambda"`. [Click here for a full list of officially supported frameworks](/docs-markdown/learn/serving-inngest-functions). For any framework that is not support, you can [create a custom handler](#custom-frameworks).

***

## `serve(options)`

- `client` (Inngest client): An Inngest client (reference).

* `functions` (InngestFunctions\[]): An array of Inngest functions defined using inngest.createFunction() (reference).

- `signingKey` (string): The Inngest Signing Key for your selected environment. We recommend setting the INNGEST\_SIGNING\_KEY environment variable instead of passing the signingKey option. You can find this in the Inngest dashboard.

* `serveHost` (string): The domain host of your application, including protocol, e.g. https\://myapp.com. The SDK attempts to infer this via HTTP headers at runtime, but this may be required when using platforms like AWS Lambda or when using a reverse proxy. See also INNGEST\_SERVE\_HOST.

- `servePath` (string): The path where your serve handler is hosted. The SDK attempts to infer this via HTTP headers at runtime. We recommend /api/inngest. See also INNGEST\_SERVE\_PATH.

* `streaming` (\`"allow" | "force" | false\`): Enables streaming responses back to Inngest which can enable maximum serverless function timeouts. See reference for more information on the configuration.  See also INNGEST\_SERVE\_HOST.

- `logLevel` (\`"fatal" | "error" | "warn" | "info" | "debug" | "silent"\`): The minimum level to log from the Inngest serve endpoint. Defaults to "info". See also INNGEST\_LOG\_LEVEL.

* `baseUrl` (string): The URL used to communicate with Inngest. This can be useful in testing environments when using the Inngest Dev Server. Defaults to: "https\://api.inngest.com/". See also INNGEST\_BASE\_URL.

- `fetch` (Fetch API compatible interface): Override the default fetch implementation. Defaults to the runtime's native Fetch API.

* `id` (string): The ID to use to represent this application instead of the client's ID. Useful for creating many Inngest endpoints in a single application.

> **Callout:** We always recommend setting the INNGEST\_SIGNING\_KEY over using the signingKey option. As with any secret, it's not a good practice to hard-code the signing key in your codebase.

## How the `serve` API handler works

The API works by exposing a single endpoint at `/api/inngest` which handles different actions utilizing HTTP request methods:

- `GET`: Return function metadata and render a debug page in in **development only**. See [`landingPage`](#landingPage).
- `POST`: Invoke functions with the request body as incoming function state.
- `PUT`: Trigger the SDK to register all functions with Inngest using the signing key.


--------------------------------------------------------------------------------
title: "`inngest/function.cancelled`&#x20;"
source: "https://www.inngest.com/docs/reference/system-events/inngest-function-cancelled"
--------------------------------------------------------------------------------

# `inngest/function.cancelled`&#x20;

The `inngest/function.cancelled` event is sent whenever any single function is cancelled in your [Inngest environment](/docs-markdown/platform/environments). The event will be sent if the event is cancelled via [`cancelOn` event](/docs-markdown/features/inngest-functions/cancellation/cancel-on-events), [function timeouts](/docs-markdown/features/inngest-functions/cancellation/cancel-on-timeouts),  [REST API](/docs-markdown/guides/cancel-running-functions) or [bulk cancellation](/docs-markdown/platform/manage/bulk-cancellation).

This event can be used to handle cleanup or similar for a single function or handle some sort of tracking function cancellations in some external system like Datadog.

> **Callout:** You can write a function that uses the "inngest/function.cancelled" event with the optional if parameter to filter to specifically handle a single function by function\_id.

## The event payload

- `name` (\`string: "inngest/function.cancelled"\`): The inngest/ event prefix is reserved for system events in each environment.

* `data` (object): The event payload data.Data about the error payload as returned from the cancelled function.The cancellation error, always "function cancelled"The name of the error, defaulting to "Error".The cancelled function's original event payload.The cancelled function's id.The cancelled function's run ID.

- `ts` (number): The timestamp integer in milliseconds at which the cancellation occurred.

```json {{ title: "Example payload" }}
{
  "name": "inngest/function.cancelled",
  "data": {
    "error": {
      "error": "function cancelled",
      "message": "function cancelled",
      "name": "Error"
    },
    "event": {
      "data": {
        "content": "Yost LLC explicabo eos",
        "transcript": "s3://product-ideas/carber-vac-release.txt",
        "userId": "bdce1b1b-6e3a-43e6-84c2-2deb559cdde6"
      },
      "id": "01JDJK451Y9KFGE5TTM2FHDEDN",
      "name": "integrations/export.requested",
      "ts": 1732558407003,
      "user": {}
    },
    "events": [
      {
        "data": {
          "content": "Yost LLC explicabo eos",
          "transcript": "s3://product-ideas/carber-vac-release.txt",
          "userId": "bdce1b1b-6e3a-43e6-84c2-2deb559cdde6"
        },
        "id": "01JDJK451Y9KFGE5TTM2FHDEDN",
        "name": "integrations/export.requested",
        "ts": 1732558407003
      }
    ],
    "function_id": "demo-app-export",
    "run_id": "01JDJKGTGDVV4DTXHY6XYB7BKK"
  },
  "id": "01JDJKH1S5P2YER8PKXPZJ1YZJ",
  "ts": 1732570023717
}
```

## Related resources

- [Example: Cleanup after function cancellation](/docs-markdown/examples/cleanup-after-function-cancellation)


--------------------------------------------------------------------------------
title: "`inngest/function.failed`&#x20;"
source: "https://www.inngest.com/docs/reference/system-events/inngest-function-failed"
--------------------------------------------------------------------------------

# `inngest/function.failed`&#x20;

The `inngest/function.failed` event is sent whenever any single function fails in your [Inngest environment](/docs-markdown/platform/environments).

This event can be used to track all function failures in a single place, enabling you to send metrics, alerts, or events to [external systems like Datadog or Sentry](/docs-markdown/examples/track-failures-in-datadog) for all of your Inngest functions.

Our SDKs offer shorthand ["on failure"](#related-resources) handler options that can be used to handle this event for a specific function.

## The event payload

- `name` (\`string: "inngest/function.failed"\`): The inngest/ event prefix is reserved for system events in each environment.

* `data` (object): The event payload data.Data about the error payload as returned from the failed function.The error message when an error is caught.The name of the error, defaulting to "Error" if unspecified.The stack trace of the error, if supported by the language SDK.The failed function's original event payload.The failed function's id.The failed function's run ID.

- `ts` (number): The timestamp integer in milliseconds at which the failure occurred.

```json {{ title: "Example payload" }}
  {
    "name": "inngest/function.failed",
    "data": {
      "error": {
        "__serialized": true,
        "error": "invalid status code: 500",
        "message": "taylor@ok.com is already a list member. Use PUT to insert or update list members.",
        "name": "Error",
        "stack": "Error: taylor@ok.com is already a list member. Use PUT to insert or update list members.\n    at /var/task/.next/server/pages/api/inngest.js:2430:23\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async InngestFunction.runFn (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/components/InngestFunction.js:378:32)\n    at async InngestCommHandler.runStep (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/components/InngestCommHandler.js:459:25)\n    at async InngestCommHandler.handleAction (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/components/InngestCommHandler.js:359:33)\n    at async ServerTiming.wrap (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/helpers/ServerTiming.js:69:21)\n    at async ServerTiming.wrap (/var/task/node_modules/.pnpm/inngest@2.6.0_typescript@5.1.6/node_modules/inngest/helpers/ServerTiming.js:69:21)"
      },
      "event": {
        "data": { "billingPlan": "pro" },
        "id": "01H0TPSHZTVFF6SFVTR6E25MTC",
        "name": "user.signup",
        "ts": 1684523501562,
        "user": { "external_id": "6463da8211cdbbcb191dd7da" }
      },
      "function_id": "my-gcp-cloud-functions-app-hello-inngest",
      "run_id": "01H0TPSJ576QY54R6JJ8MEX6JH"
    },
    "id": "01H0TPW7KB4KCR739TG2J3FTHT",
    "ts": 1684523589227
  }
```

## Related resources

- [TypeScript SDK: onFailure handler](/docs-markdown/reference/functions/handling-failures)
- [Python SDK: on\_failure handler](/docs-markdown/reference/python/functions/create#on_failure)
- [Example: Track all function failures in Datadog](/docs-markdown/examples/track-failures-in-datadog)


--------------------------------------------------------------------------------
title: "Testing"
source: "https://www.inngest.com/docs/reference/testing"
--------------------------------------------------------------------------------

# Testing

To test your Inngest functions programmatically, use the `@inngest/test`
library, available on [npm](https://www.npmjs.com/package/@inngest/test) and [JSR](https://jsr.io/@inngest/test).

This allows you to mock function state, step tooling, and inputs with a
Jest-compatible API supporting all major testing frameworks, runtimes, and
libraries:

- `jest`
- `vitest`
- `bun:test` (Bun)
- `@std/expect` (Deno)
- `chai`/`expect`

## Installation

The `@inngest/test` package requires `inngest@>=3.22.12`.

```shell {{ title: "npm" }}
npm install -D @inngest/test
```

```shell {{ title: "Yarn" }}
yarn add -D @inngest/test
```

```shell {{ title: "pnpm" }}
pnpm add -D @inngest/test
```

```shell {{ title: "Bun" }}
bun add -d @inngest/test
```

```shell {{ title: "Deno" }}
deno add --dev @inngest/test
# or with JSR...
deno add --dev jsr:@inngest/test
```

## Unit tests

Use whichever supported testing framework; `@inngest/test` is unopinionated
about how your tests are run. We'll demonstrate here using `jest`.

Import `InngestTestEngine`, our function to test, and create a new
`InngestTestEngine` instance.

```ts
import { InngestTestEngine } from "@inngest/test";
import { helloWorld } from "./helloWorld";

describe("helloWorld function", () => {
  const t = new InngestTestEngine({
    function: helloWorld,
  });
});
```

Now we can use the primary API for testing, `t.execute()`:

```ts
test("returns a greeting", async () => {
  const { result } = await t.execute();
  expect(result).toEqual("Hello World!");
});
```

This will run the entire function (steps and all) to completion, then return the
response from the function, where we assert that it was the string `"Hello
World!"`.

A serialized `error` will be returned instead of `result` if the function threw:

```ts
test("throws an error", async () => {
  const { error } = await t.execute();
  expect(error).toContain("Some specific error");
});
```

> **Tip:** When using steps that delay execution, like step.sleep or step.waitForEvent, you will need to mock them. Learn more about mocking steps.

### Running an individual step

`t.executeStep()` can be used to run the function until a particular step has
been executed.

This is useful to test a single step within a function or to see that a
non-runnable step such as `step.waitForEvent()` has been registered with the
correct options.

```ts
test("runs the price calculations", async () => {
  const { result } = await t.executeStep("calculate-price");
  expect(result).toEqual(123);
});
```

Assertions can also be made on steps in any part of a run, regardless of if
that's the checkpoint we've waited for. See [Assertions -> State](#assertions).

### Assertions

`@inngest/test` adds Jest-compatible mocks by default that can help you assert
function and step input and output. You can assert:

- Function input
- Function output
- Step output
- Step tool usage

All of these values are returned from both `t.execute()` and `t.executeStep()`;
we'll only show one for simplicity here.

The `result` is returned, which is the output of the run or step:

```ts
const { result } = await t.execute();
expect(result).toEqual("Hello World!");
```

`ctx` is the input used for the function run. This can be used to assert outputs
that are based on input data such as `event` or `runId`, or to confirm that
middleware is working correctly and affecting input arguments.

```ts
const { ctx, result } = await t.execute();
expect(result).toEqual(`Run ID was: "${ctx.runId}"`);
```

The step tooling at `ctx.step` are all Jest-compatible spy functions, so you can
use them to assert that they've been called and used correctly:

```ts
const { ctx } = await t.execute();
expect(ctx.step.run).toHaveBeenCalledWith("my-step", expect.any(Function));
```

`state` is also returned, which is a view into the outputs of all steps in the
run. This allows you to test each individual step output for any given input:

```ts
const { state } = await t.execute();
expect(state["my-step"]).resolves.toEqual("some successful output");
expect(state["dangerous-step"]).rejects.toThrowError("something failed");
```

### Mocking

Some mocking is done automatically by `@inngest/test`, but can be overwritten if
needed.

All mocks detailed below can be specified either when creating an
`InngestTestEngine` instance or for each individual execution:

```ts
// Set the events for every execution
const t = new InngestTestEngine({
  function: helloWorld,
  // mocks here
});

// Or for just one, which will overwrite any current event mocks
t.execute({
  // mocks here
});

t.executeStep("my-step", {
  // mocks here
})
```

You can also clone an existing `InngestTestEngine` instance to encourage re-use
of complex mocks:

```ts
// Make a direct clone, which includes any mocks
const otherT = t.clone();

// Provide some more mocks in addition to any existing ones
const anotherT = t.clone({
  // mocks here
});
```

For simplicity, the following examples will show usage of `t.execute()`, but the
mocks can be placed in any of these locations.

#### Events

The incoming event data can be mocked. They are always specified as an array of
events to allow also mocking batches.

```ts
t.execute({
  events: [{ name: "demo/event.sent", data: { message: "Hi!" } }],
});
```

> **Callout:** If no event mocks are given at all (or events: undefined is explicitly set),
> an inngest/function.invoked event will be mocked for you.

#### Steps

Mocking steps can help you model different paths and situations within your
function. To do so, any step can be mocked by providing the `steps` option. You should always mock `sleep` and `waitForEvent` steps - [learn more here](#sleep-and-wait-for-event).

Here we mock two steps, one that will run successfully and another that will
model a failure and throw an error:

```ts
t.execute({
  steps: [
    {
      id: "successful-step",
      handler() {
        return "We did it!";
      },
    },
    {
      id: "dangerous-step",
      handler() {
        throw new Error("Oh no!");
      },
    },
  ],
});
```

These handlers will run lazily when they are found during a function's execution.
This means you can write complex mocks that respond to other information:

```ts
let message = "";

t.execute({
  steps: [
    {
      id: "build-greeting",
      handler() {
        message = "Hello, ";
        return message;
      },
    },
    {
      id: "build-name",
      handler() {
        return message + " World!";
      },
    },
  ],
});
```

#### Sleep and waitForEvent

Steps that pause the function, `step.sleep`, `step.sleepUntil`, and `step.waitForEvent` should always be mocked.

```ts {{ title: 'step.sleep' }}
// Given the following function that sleeps
const myFunction = inngest.createFunction(
  { id: "my-function" },
  { event: "user.created" },
  async ({ event, step }) => {
    await step.sleep("one-day-delay", "1d");
    return { message: "success" };
  }
)
// Mock the step to execute a no-op handler to return immediately
t.execute({
  steps: [
    {
      id: "one-day-delay",
      handler() {}, // no return value necessary
    },
  ],
});
```

```ts {{ title: "step.waitForEvent" }}
// Given the following function that sleeps
const myFunction = inngest.createFunction(
  { id: "my-function" },
  { event: "time_off.requested" },
  async ({ event, step }) => {
    const evt = await step.waitForEvent("wait-for-approval", {
      event: "manager.approved",
      timeout: "1d",
    });
    return { message: evt?.data.message };
  }
)
// Mock the step to return null to simulate a timeout
t.execute({
  steps: [
    {
      id: "wait-for-approval",
      handler() {
        // A timeout will return null
        return null;
      },
    },
  ],
});
// Mock the step to return an event
t.execute({
  steps: [
    {
      id: "wait-for-approval",
      handler() {
        // If the event is approved, it will be returned
        return {
          name: 'manager.approved',
          data: {
            message: 'This looks great!'
          }
        };
      },
    },
  ],
});
```

#### Modules and imports

Any mocking of modules or imports outside of Inngest which your functions may
rely on should be done outside of Inngest with the testing framework you're
using.

Here are some links to the major supported frameworks and their guidance for
mocking imports:

- [`jest`](https://jestjs.io/docs-markdown/mock-functions#mocking-modules)
- [`vitest`](https://vitest.dev/guide/mocking#modules)
- [`bun:test` (Bun)](https://bun.sh/docs-markdown/test/mocks#module-mocks-with-mock-module)
- [`@std/testing` (Deno)](https://jsr.io/@std/testing/doc/mock/~)

#### Custom

You can also provide your own custom mocks for the function input.

When instantiating a new `InngestTestEngine` or starting an execution, provide a
`transformCtx` function that will add these mocks every time the function is
run:

```ts
const t = new InngestTestEngine({
  function: helloWorld,
  transformCtx: (ctx) => {
    return {
      ...ctx,
      event: someCustomThing,
    };
  },
});
```

If you wish to still add the automatic mocking from `@inngest/test` (such as the
spies on `ctx.step.*`), you can import and use the automatic transforms as part
of your own:

```ts
import { InngestTestEngine, mockCtx } from "@inngest/test";

const t = new InngestTestEngine({
  function: helloWorld,
  transformCtx: (ctx) => {
    return {
      ...mockCtx(ctx),
      event: someCustomThing,
    };
  },
});
```


--------------------------------------------------------------------------------
title: "TypeScript SDK"
source: "https://www.inngest.com/docs/reference/typescript"
--------------------------------------------------------------------------------

# TypeScript SDK

## Installing

```shell {{ title: "npm" }}
npm install inngest
```

```shell {{ title: "pnpm" }}
pnpm add inngest
```

```shell {{ title: "yarn" }}
yarn add inngest
```

## Source code

Our TypeScript SDK and its related packages are open source and available on Github: [ inngest/inngest-js](https://github.com/inngest/inngest-js).

## Supported Versions

All versions `>=v0.5.0` (released [October 5th 2022](https://github.com/inngest/inngest-js/releases/tag/v0.5.0)) are supported.

If you'd like to upgrade, see the [migration guide](/docs-markdown/sdk/migration).

## Official libraries

- [inngest](https://www.npmjs.com/package/inngest) - the Inngest SDK
- [@inngest/eslint-plugin](https://www.npmjs.com/package/@inngest/eslint-plugin) - specific ESLint rules for Inngest
- [@inngest/middleware-encryption](https://www.npmjs.com/package/@inngest/middleware-encryption) - middleware providing E2E encryption

## Examples

### Frameworks

- [Astro](https://github.com/inngest/inngest-js/tree/main/examples/framework-astro)
- [Bun.serve()](https://github.com/inngest/inngest-js/tree/main/examples/bun)
- [Fastify](https://github.com/inngest/inngest-js/tree/main/examples/framework-fastify)
- [Koa](https://github.com/inngest/inngest-js/tree/main/examples/framework-koa)
- [NestJS](https://github.com/inngest/inngest-js/tree/main/examples/framework-nestjs)
- [Next.js (app router)](https://github.com/inngest/inngest-js/tree/main/examples/framework-nextjs-app-router)
- [Next.js (pages router)](https://github.com/inngest/inngest-js/tree/main/examples/framework-nextjs-pages-router)
- [Nuxt](https://github.com/inngest/inngest-js/tree/main/examples/framework-nuxt)
- [Remix](https://github.com/inngest/inngest-js/tree/main/examples/framework-remix)
- [SvelteKit](https://github.com/inngest/inngest-js/tree/main/examples/framework-sveltekit)

### Middleware

- [E2E Encryption](https://github.com/inngest/inngest-js/tree/main/examples/middleware-e2e-encryption)

## Community libraries

Explore our collection of community-created libraries, offering unofficial but valuable extensions and integrations to enhance Inngest's functionality with various frameworks and systems.

Want to be added to the list? [Contact us!](https://app.inngest.com/support)

- [nest-inngest](https://github.com/thawankeane/nest-inngest) - strongly typed Inngest module for NestJS projects
- [nuxt-inngest](https://www.npmjs.com/package/nuxt-inngest) - Inngest integration for Nuxt


--------------------------------------------------------------------------------
title: "Durable Endpoints&#x20;"
source: "https://www.inngest.com/docs/reference/typescript/durable-endpoints"
--------------------------------------------------------------------------------

# Durable Endpoints&#x20;

Create durable HTTP endpoints using `inngest.endpoint()`. Each step within the handler is checkpointed, allowing automatic recovery from failures.

```ts
import { Inngest, step } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({ id: "my-app", endpointAdapter });

export const handler = inngest.endpoint(async (req: Request): Promise<Response> => {
  const data = await step.run("fetch-data", async () => {
    return await fetchExternalAPI();
  });

  return Response.json({ data });
});
```

***

## Setup

### `endpointAdapter`

The `endpointAdapter` must be passed to the Inngest client constructor to enable Durable Endpoints.

```ts
import { Inngest } from "inngest";
import { endpointAdapter } from "inngest/edge";

const inngest = new Inngest({
  id: "my-app",
  endpointAdapter,
});
```

> **Callout:** The endpointAdapter is imported from inngest/edge and is required for Durable Endpoints to function. Without it, inngest.endpoint() will not be available.

***

## `inngest.endpoint(handler): Handler`

Creates a durable endpoint handler that can use step primitives for checkpointing.

- `handler` ((req: Request) => Promise\<Response>): An async function that receives a standard Request object and must return a Response object.Within this handler, you can use all step primitives (step.run(), step.sleep(), step.waitForEvent()) for durable execution.

**Returns:** A handler function compatible with edge runtimes and most HTTP frameworks.

```ts
export const handler = inngest.endpoint(
  async (req: Request): Promise<Response> => {
    const url = new URL(req.url);
    const id = url.searchParams.get("id");

    const result = await step.run("process", async () => {
      return await processItem(id);
    });

    return Response.json({ result });
  }
);
```

***

## Available Step Primitives

Within a Durable Endpoint handler, you have access to all step primitives:

### `step.run(id, fn)`

Execute and checkpoint a function. If the endpoint is retried, completed steps return their cached result instantly.

```ts
const user = await step.run("fetch-user", async () => {
  return await db.users.findOne({ id: userId });
});
```

See [step.run() reference](/docs-markdown/reference/functions/step-run) for full documentation.

### `step.sleep(id, duration)`

Pause execution for a specified duration. The endpoint will be resumed after the sleep completes.

```ts
await step.sleep("rate-limit-pause", "30s");
```

See [step.sleep() reference](/docs-markdown/reference/functions/step-sleep) for full documentation.

### `step.waitForEvent(id, options)`

Wait for an external event before continuing. Useful for human-in-the-loop workflows.

```ts
const approval = await step.waitForEvent("wait-for-approval", {
  event: "approval/received",
  match: "data.requestId",
  timeout: "24h",
});
```

See [step.waitForEvent() reference](/docs-markdown/reference/functions/step-wait-for-event) for full documentation.

***

## Passing Data to Endpoints

> **Callout:** POST body is not yet supported. Use query string parameters to pass data to Durable Endpoints. POST body support is coming soon.

```ts
export const handler = inngest.endpoint(async (req: Request): Promise<Response> => {
  const url = new URL(req.url);

  // Read data from query parameters
  const userId = url.searchParams.get("userId");
  const action = url.searchParams.get("action");

  // Process with durable steps
  const result = await step.run("process", async () => {
    return await processAction(userId, action);
  });

  return Response.json({ result });
});
```

***

## Returning Responses

Durable Endpoints should return a standard HTTP `Response` object. SSE streams are not supported.

```ts
// JSON response
return Response.json({ success: true, data: result });

// Text response
return new Response("OK", { status: 200 });

// Error response
return new Response(JSON.stringify({ error: "Not found" }), {
  status: 404,
  headers: { "Content-Type": "application/json" },
});
```

***

## Error Handling

Errors thrown within `step.run()` will trigger automatic retries. Use standard try/catch for custom error handling:

```ts
export const handler = inngest.endpoint(async (req: Request): Promise<Response> => {
  try {
    const result = await step.run("risky-operation", async () => {
      return await riskyAPICall();
    });

    return Response.json({ result });
  } catch (error) {
    // All retries exhausted, handle gracefully
    return Response.json(
      { error: "Operation failed after retries" },
      { status: 500 }
    );
  }
});
```

***

## Framework Integration

Durable Endpoints is only available for Bun and Next.js API endpoints.

[Reach out on Discord](/discord) to ask support for additional frameworks.

***

## Requesting a Durable Endpoint

Durable Endpoints behave like regular API endpoints upon a success path. You can request them from your front-end (*or back-end*) using `fetch()` or your favorite query or http library:

However, when failures trigger some retries, a Durable Endpoint is returning a redirect to a dedicated endpoint on the Inngest Cloud to poll the final result.

Here is a snippet handling both the direct result and redirected result upon retries:

```typescript
function handleError(error) {
  // ...
}

async function handleResult(result) {
  const result = await res.json()
  // ...
}

fetch(`/api/your-durable-endpoint`)
  .then((res) => {
    if (res.redirected) {
      // follow the redirect
      fetch(res.url)
        .then(handleResult)
        .catch(handleError);
    } else {
      handleResult(res)
    }
  })
  .catch(handleError);
```

> **Callout:** As the Durable Endpoint redirects the request to a dedicated endpoint on Inngest's Cloud, fetch() cannot simply follow this redirect for you (CORS policy).
> Instead, you need to get the redirect URL (res.url) and trigger a new fetch() request.


--------------------------------------------------------------------------------
title: "Usage"
source: "https://www.inngest.com/docs/reference/typescript/extended-traces"
--------------------------------------------------------------------------------

# Usage

Inngest supports OpenTelemetry for distributed tracing and observability across your functions. The `extendedTracesMiddleware` automatically instruments your Inngest functions and integrates with your existing OpenTelemetry providers, giving you deep insights into function execution, step timing, and performance. It includes [automatic instrumentation](#instrumentation) for many popular libraries.

## Basic Usage

> **Callout:** Import and run the extendedTracesMiddleware() before any other code.This ensures that the tracer
> provider
> and any
> instrumentation has
> time to patch code in order to collect traces and spans from all parts of your
> application. Loading running extendedTracesMiddleware() after any other code risks not
> instrumenting it.

For example,

```ts
// Import this first
import { extendedTracesMiddleware } from "inngest/experimental";
const extendedTraces = extendedTracesMiddleware();

// Then everything else
import { Inngest } from "inngest";

const inngest = new Inngest({
  id: "my-app",
  middleware: [extendedTraces],
});
```

## Advanced Usage

**'Setup an OpenTelemetry client with Inngest or create custom spans'**: [Follow this guide to learn how to add Inngest Extended Traces to an existing OpenTelemetry configuration or to create custom spans.]("/docs-markdown/examples/open-telemetry")

### Serverless

If you're using serverless, the entrypoint of your app will likely be the file
for a particular endpoint, for example `/api/inngest`.

If you have your client set up as in the example above, make sure you import
that first so that the provider has a chance to initialize.

```ts
// Import the client first
import { inngest } from "@/inngest";

// Then import everything else
import { serve } from "inngest/next";
import { myFn } from "@/inngest/functions";

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [myFn],
});
```

### Extending existing providers

A JavaScript process can only have a single OpenTelemetry Provider. Some
libraries such as Sentry also create their own provider.

`extendedTracesMiddleware()` will first try to *extend* an existing provider and will only
create one if none has been found. If an existing provider is extended, we won't
contribute any automatic [instrumentation](#instrumentation).

In the case of Sentry, `extendedTracesMiddleware()` will extend Sentry's provider as long
as it's run after `Sentry.init()`.

> **Note:** This extension should also work for OpenTelemetry providers that originate
> within the runtime, like Deno's OpenTelemetry.

This behaviour can be changed:

```ts
extendedTracesMiddleware({
  behaviour: "auto",
});
```

The options are:

- `"auto"` (default): Attempt to extend a provider if one exists, else create one, fails
  if neither worked
- `"extendProvider"`: Only attempt to extend a provider and fails if none exists
- `"createProvider"`: Only attempt to create a provider and fails if we couldn't
- `"off"`: Do nothing

If you're intending to only use `extendedTracesMiddleware()` to extend an existing
provider, you no longer need to ensure that it is called before any other code.

### Manually extend

If you're already manually creating your own trace provider and import ordering
is an issue, you may want to manually add Inngest's `InngestSpanProcessor` to
your existing setup.

Add an `InngestSpanExporter` to your provider:

```ts
// Create your client the same as you would normally
import { Inngest } from "inngest";
import { extendedTracesMiddleware } from "inngest/experimental";

export const inngest = new Inngest({
  id: "my-app",
  middleware: [
    extendedTracesMiddleware({
      // Make sure the middleware doesn't try to automatically instrument
      behaviour: "off",
    }),
  ],
});

// Then when you create your provider, pass the client to it
import { inngest } from "@/inngest";
import { BasicTracerProvider } from "@opentelemetry/sdk-trace-base";
import { InngestSpanProcessor } from "inngest/experimental";

const provider = new BasicTracerProvider({
  // Add the span processor when creating your provider
  spanProcessors: [new InngestSpanProcessor(inngest)],
});

// Register the provider globally
provider.register();
```

## Instrumentation

`extendedTracesMiddleware()` will automatically instrument common code for you if it's
used to create your provider.

Here's a list of automatic supported instrumentation:

- [amqplib](https://www.npmjs.com/package/amqplib)
- [AWS Lambda](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html)
- [AWS SDK for JavaScript v3](https://github.com/aws/aws-sdk-js-v3)
- [bunyan](https://www.npmjs.com/package/bunyan)
- [cassandra-driver](https://www.npmjs.com/package/cassandra-driver)
- [connect](https://github.com/senchalabs/connect)
- [@cucumber/cucumber](https://www.npmjs.com/package/@cucumber/cucumber)
- [dataloader](https://www.npmjs.com/package/dataloader)
- [dns](http://nodejs.org/dist/latest/docs-markdown/api/dns.html)
- [express](https://github.com/expressjs/express)
- [fs](http://nodejs.org/dist/latest/docs-markdown/api/fs.html)
- [generic-pool](https://github.com/coopernurse/node-pool)
- [graphql](https://www.npmjs.com/package/graphql)
- [@grpc/grpc-js](https://grpc.io/blog/grpc-js-1.0/)
- [Hapi framework](https://www.npmjs.com/package/@hapi/hapi)
- [http](https://nodejs.org/api/http.html) and
  [https](https://nodejs.org/api/https.html)
- [ioredis](https://github.com/luin/ioredis)
- [kafkajs](https://www.npmjs.com/package/kafkajs)
- [knex](https://github.com/knex/knex)
- [Koa](https://github.com/koajs/koa)
- [lru-memoizer](https://github.com/jfromaniello/lru-memoizer)
- [memcached](https://www.npmjs.com/package/memcached)
- [mongodb](https://github.com/mongodb/node-mongodb-native)
- [mongoose](https://github.com/Automattic/mongoose)
- [mysql](https://www.npmjs.com/package/mysql)
- [mysql2](https://github.com/sidorares/node-mysql2)
- [NestJS framework](https://nestjs.com/)
- [net](http://nodejs.org/dist/latest/docs-markdown/api/net.html)
- [pg](https://github.com/brianc/node-postgres)
- [pino](https://www.npmjs.com/package/pino)
- [redis](https://github.com/NodeRedis/node_redis)
- [restify](https://github.com/restify/node-restify)
- [socket.io](https://github.com/socketio/socket.io)
- [undici](https://undici.nodejs.org/) (Node.js global
  [fetch](https://nodejs.org/docs-markdown/latest/api/globals.html#fetch) API)
- [winston](https://www.npmjs.com/package/winston)

### Custom instrumentation

You can add additional custom instrumentations to gain more insight into your
stack.

For example, here's an example of adding [Prisma
OpenTelemetry](https://www.prisma.io/docs-markdown/orm/prisma-client/observability-and-logging/opentelemetry-tracing):

```ts
import { PrismaInstrumentation } from "@prisma/instrumentation";
import { extendedTracesMiddleware } from "inngest/experimental";

const extendedTraces = extendedTracesMiddleware({
  instrumentations: [new PrismaInstrumentation()],
});
```


--------------------------------------------------------------------------------
title: "Cancel on"
source: "https://www.inngest.com/docs/reference/typescript/functions/cancel-on"
--------------------------------------------------------------------------------

# Cancel on

Stop the execution of a running function when a specific event is received using `cancelOn`.

```ts
inngest.createFunction(
  {
    id: "sync-contacts",
    cancelOn: [
      {
        event: "app/user.deleted",
        // ensure the async (future) event's userId matches the trigger userId
        if: "async.data.userId == event.data.userId",
      },
    ],
  }
  // ...
);
```

Using `cancelOn` is very useful for handling scenarios where a long-running function should be terminated early due to changes elsewhere in your system.

The API for this is similar to the [`step.waitForEvent()`](/docs-markdown/guides/multi-step-functions#wait-for-event) tool, allowing you to specify the incoming event and different methods for matching pieces of data within.

***

## How to use `cancelOn`

The most common use case for cancellation is to cancel a function's execution if a specific field in the incoming event matches the same field in the triggering event. For example, you might want to cancel a sync event for a user if that user is deleted. For this, you need to specify a `match` [expression](/docs-markdown/guides/writing-expressions). Let's look at an example function and two events.

This function specifies it will `cancelOn` the `"app/user.deleted"` event only when it and the original `"app/user.created"` event have the same `data.userId` value:

```ts
inngest.createFunction(
  {
    id: "sync-contacts",
    cancelOn: [
      {
        event: "app/user.deleted",
        // ensure the async (future) event's userId matches the trigger userId
        if: "async.data.userId == event.data.userId",
      },
    ],
  },
  { event: "app/user.created" },
  // ...
);
```

For the given function, this is an example of an event that would trigger the function:

```json
{
  "name": "app/user.created",
  "data": {
    "userId": "123",
    "name": "John Doe"
  }
}
```

And this is an example of an event that would cancel the function as it and the original event have the same `data.userId` value of `"123"`:

```json
{
  "name": "app/user.deleted",
  "data": {
    "userId": "123"
  }
}
```

Match expressions can be simple equalities or be more complex. Read [our guide to writing expressions](/docs-markdown/guides/writing-expressions) for more info.

> **Callout:** Functions are cancelled between steps, meaning that if there is a step.run currently executing, it will finish before the function is cancelled.Inngest does this to ensure that steps are treated like atomic operations and each step either completes or does not run at all.

## Configuration

- `cancelOn` (array of objects): Define events that can be used to cancel a running or sleeping functionThe event name which will be used to cancelThe property to match the event trigger and the cancelling event, using dot-notation, for example, data.userId. Read our guide to writing expressions for more info.An expression on which to conditionally match the original event trigger (event) and the wait event (async). Cannot be combined with match.Expressions are defined using the Common Expression Language (CEL) with the events accessible using dot-notation. Read our guide to writing expressions for more info. Examples:event.data.userId == async.data.userId && async.data.billing\_plan == 'pro'The amount of time to wait to receive the cancelling event. A time string compatible with the ms package, e.g. "30m", "3 hours", or "2.5d"

## Examples

### With a timeout window

Cancel a function's execution if a matching event is received within a given amount of time from the function being triggered.

```ts {{ title: "v3" }}
inngest.createFunction(
  {
    id: "sync-contacts",
    cancelOn: [{ event: "app/user.deleted", match: "data.userId", timeout: "1h" }],
  }
  // ...
);
```

```ts {{ title: "v2" }}
inngest.createFunction(
  {
    name: "Sync contacts",
    cancelOn: [{ event: "app/user.deleted", match: "data.userId", timeout: "1h" }],
  }
  // ...
);
```

This is useful when you want to limit the time window for cancellation, ensuring that the function will continue to execute if no matching event is received within the specified time frame.


--------------------------------------------------------------------------------
title: "Workflow Kit"
source: "https://www.inngest.com/docs/reference/workflow-kit"
--------------------------------------------------------------------------------

# Workflow Kit

Workflow Kit enables you to build [user-defined workflows](/docs-markdown/guides/user-defined-workflows) with Inngest by providing a set of workflow actions to the **[Workflow Engine](/docs-markdown/reference/workflow-kit/engine)** while using the **[pre-built React components](/docs-markdown/reference/workflow-kit/components-api)** to build your Workflow Editor UI.

## Installing

```shell {{ title: "npm" }}
npm install @inngest/workflow-kit inngest
```

```shell {{ title: "pnpm" }}
pnpm add @inngest/workflow-kit inngest
```

```shell {{ title: "yarn" }}
yarn add @inngest/workflow-kit inngest
```

> **Callout:** PrerequisitesThe Workflow Kit integrates with our TypeScript SDK.To use it, you'll need an application with Inngest set up, ready to serve Inngest functions.

## Source code

Our Workflow Kit is open source and available on Github: [**inngest/workflow-kit**](https://github.com/inngest/workflow-kit/)

## Guides and examples

Get started with Worflow Kit by exploring our guide or cloning our Next.js template:

**"Guide: Build workflows configurable by your users"**: [Follow this step-by-step tutorial to learn how to use Workflow Kit to add automations to a CMS Next.js application.]("/docs-markdown/guides/user-defined-workflows")

**"Next.js template: CMS AI automation demo"**: [This Next.js template features AI workflows helping with grammar fixes, generating Table of Contents or Tweets.]('https://github.com/inngest/workflow-kit/tree/main/examples/nextjs-blog-cms#readme')


--------------------------------------------------------------------------------
title: "Creating workflow actions"
source: "https://www.inngest.com/docs/reference/workflow-kit/actions"
--------------------------------------------------------------------------------

# Creating workflow actions

The [`@inngest/workflow-kit`](https://npmjs.com/package/@inngest/workflow-kit) package provides a [workflow engine](/docs-markdown/reference/workflow-kit/engine), enabling you to create workflow actions on the back end. These actions are later provided to the front end so end-users can build their own workflow instance using the [`<Editor />`](/docs-markdown/reference/workflow-kit/components-api).

Workflow actions are defined as two objects using the [`EngineAction`](#passing-actions-to-the-workflow-engine-engine-action) (for the back-end) and [`PublicEngineAction`](#passing-actions-to-the-react-components-public-engine-action) (for the front-end) types.

```ts {{ title: "src/inngest/actions-definition.ts" }}
import { type PublicEngineAction } from "@inngest/workflow-kit";

export const actionsDefinition: PublicEngineAction[] = [
  {
    kind: "grammar_review",
    name: "Perform a grammar review",
    description: "Use OpenAI for grammar fixes",
  },
];

```

```tsx {{ title: "src/inngest/actions.ts" }}
import { type EngineAction } from "@inngest/workflow-kit";

import { actionsDefinition } from "./actions-definition";

export const actions: EngineAction[] = [
  {
    // Add a Table of Contents
    ...actionsDefinition[0],
    handler: async ({ event, step, workflowAction }) => {
	      // implementation...
    }
  },
];
```

In the example above, the `actionsDefinition` array would be passed via props to the [`<Provider />`](/docs-markdown/reference/workflow-kit/components-api) while the `actions` are passed to the [`Engine`](/docs-markdown/reference/workflow-kit/engine).

> **Callout:** Why do I need two types of actions?The actions need to be separated into 2 distinct objects to avoid leaking the action handler implementations and dependencies into the front end:

## Passing actions to the React components: `PublicEngineAction[]`

- `kind` (string): Kind is an enum representing the action's ID.  This is not named as "id" so that we can keep consistency with the WorkflowAction type.

* `name` (string): Name is the human-readable name of the action.

- `description` (string): Description is a short description of the action.

* `icon` (string): Icon is the name of the icon to use for the action.  This may be an URL, or an SVG directly.

## Passing actions to the Workflow Engine: `EngineAction[]`

> **Callout:** Note: Inherits PublicEngineAction properties.

- `handler` (function): The handler is your code that runs whenever the action occurs. Every function handler receives a single object argument which can be deconstructed. The key arguments are event and step.

```ts {{ title: "src/inngest/actions.ts" }}
import { type EngineAction } from "@inngest/workflow-kit";

import { actionsDefinition } from "./actions-definition";

export const actions: EngineAction[] = [
{
    // Add a Table of Contents
    ...actionsDefinition[0],
    handler: async ({ event, step, workflow, workflowAction, state }) => {
        // ...
    }
},
];
```

The details of the `handler()` **unique argument's properties** can be found below:

### `handler()` function argument properties

- `event` (TriggerEvent): See the Inngest Function handler event argument property definition.

* `step` (Step): See the Inngest Function handler step argument property definition.

- `workflow` (Workflow): See the Workflow instance format.

* `workflowAction` (WorkflowAction): WorkflowAction is the action being executed, with fully interpolated inputs.Key properties are:id: string:  The ID of the action within the workflow instance.kind: string: The action kind, as provided in the PublicEngineAction.name?: string: The name, as provided in the PublicEngineAction.description?: string: The description, as provided in the PublicEngineAction.inputs?: string: The record key is the key of the EngineAction input name, and the value is the variable's value.

- `state` (object): State represents the current state of the workflow, with previous action's outputs recorded as key-value pairs.


--------------------------------------------------------------------------------
title: "Components API (React)"
source: "https://www.inngest.com/docs/reference/workflow-kit/components-api"
--------------------------------------------------------------------------------

# Components API (React)

The [`@inngest/workflow-kit`](https://npmjs.com/package/@inngest/workflow-kit) package provides a set of React components, enabling you to build a workflow editor UI in no time!

![workflow-kit-announcement-video-loop.gif](/assets/docs-markdown/reference/workflow-kit/workflow-demo.gif)

## Usage

```tsx {{ title: "src/components/my-workflow-editor.ts" }}
import { useState } from "react";
import { Editor, Provider, Sidebar, type Workflow } from "@inngest/workflow-kit/ui";

// import `PublicEngineAction[]`
import { actionsDefinitions } from "@/inngest/actions-definitions";

// NOTE - Importing CSS from JavaScript requires a bundler plugin like PostCSS or CSS Modules
import "@inngest/workflow-kit/ui/ui.css";
import "@xyflow/react/dist/style.css";

export const MyWorkflowEditor = ({ workflow }: { workflow: Workflow }) => {
  const [workflowDraft, updateWorkflowDraft] =
    useState<typeof workflow>(workflow);

  return (
    <Provider
      workflow={workflowDraft}
      trigger={{ event: { name: 'blog-post.updated' } }}
      availableActions={actionsDefinitions}
      onChange={updateWorkflowDraft}
    >
      <Editor>
        <Sidebar position="right"></Sidebar>
      </Editor>
    </Provider>
  );
};
```

## Reference

### `<Provider>`

> **Callout:** \<Provider> is a Controlled Component, watching the workflow=\{} to update.Make sure to updated workflow=\{} based on the updates received via onChange=\{}.

- `workflow` (Workflow): A Workflow instance object.

* `trigger` (object): An object with a name: string property representing an event name.

- `availableActions` (PublicEngineAction\[]): See the PublicEngineActionEngineAction\[] reference.

* `onChange` (function): A callback function, called after each workflow changes.

- `{children}` (React.ReactNode): The \<Provider> component should always get the following tree as children:

```tsx
<Editor>
  <Sidebar position="right"></Sidebar>
</Editor>
```


--------------------------------------------------------------------------------
title: "Using the workflow engine"
source: "https://www.inngest.com/docs/reference/workflow-kit/engine"
--------------------------------------------------------------------------------

# Using the workflow engine

The workflow `Engine` is used to run a given [workflow instance](/docs-markdown/reference/workflow-kit/workflow-instance) within an Inngest Function:

```tsx {{ title: "src/inngest/workflow.ts" }}
import { Engine, type Workflow } from "@inngest/workflow-kit";

import { inngest } from "./client";
import { actions } from "./actions";
import { loadWorkflowInstanceFromEvent } from "./loaders";

const workflowEngine = new Engine({
  actions: actionsWithHandlers,
  loader: (event) => {
    return loadWorkflowInstanceFromEvent(event);
  },
});

export default inngest.createFunction(
  { id: "blog-post-workflow" },
  { event: "blog-post.updated" },
  async ({ event, step }) => {
    // When `run` is called,
    //  the loader function is called with access to the event
    await workflowEngine.run({ event, step });
  }
);

```

## Configure

- `actions` (EngineAction\[]): See the EngineAction\[] reference.

* `loader` (function): An async function receiving the event as unique argument and returning a valid Workflow instance object.

- `disableBuiltinActions` (boolean): For selectively adding built-in actions, set this to true and expose the actions you want via the \<Provider> availableActions prop.


--------------------------------------------------------------------------------
title: "Workflow instance"
source: "https://www.inngest.com/docs/reference/workflow-kit/workflow-instance"
--------------------------------------------------------------------------------

# Workflow instance

A workflow instance represents a user configuration of a sequence of [workflow actions](/docs-markdown/reference/workflow-kit/actions), later provided to the [workflow engine](/docs-markdown/reference/workflow-kit/engine) for execution.

Example of a workflow instance object:

```json
{
  "name": "Generate social posts",
  "edges": [
    {
      "to": "1",
      "from": "$source"
    },
    {
      "to": "2",
      "from": "1"
    }
  ],
  "actions": [
    {
      "id": "1",
      "kind": "generate_tweet_posts",
      "name": "Generate Twitter posts"
    },
    {
      "id": "2",
      "kind": "generate_linkedin_posts",
      "name": "Generate LinkedIn posts"
    }
  ]
}
```

> **Callout:** How to use the workflow instance objectWorkflow instance objects are meant to be retrieved from the \<Provider> Editor, stored in database and loaded into the Workflow Engine using a loader.Use this reference if you need to update the workflow instance between these steps.

## `Workflow`

A Workflow instance in an object with the following properties:

- `name` (string): Name of the worklow configuration, provided by the end-user.

* `description` (string): description of the worklow configuration, provided by the end-user.

- `actions` (WorkflowAction\[]): See the WorkflowAction reference below.

* `edges` (WorkflowEdge\[]): See the WorkflowEdge reference below.

## `WorkflowAction`

`WorkflowAction` represent a step of the workflow instance linked to an defined [`EngineAction`](/docs-markdown/reference/workflow-kit/actions).

- `id` (string): The ID of the action within the workflow instance.  This is used as a reference and must be unique within the Instance itself.

* `kind` (string): The action kind, used to look up the EngineAction definition.

- `name` (string): Name is the human-readable name of the action.

* `description` (string): Description is a short description of the action.

- `inputs` (object): Inputs is a list of configured inputs for the EngineAction.The record key is the key of the EngineAction input name, and
  the value is the variable's value.This will be type checked to match the EngineAction type before
  save and before execution.Ref inputs for interpolation are "!ref($.\<path>)", eg. "!ref($.event.data.email)"

## `WorkflowEdge`

A `WorkflowEdge` represents the link between two `WorkflowAction`.

- `from` (string): The WorkflowAction.id of the source action."$source" is a reserved value used as the starting point of the worklow instance.

* `to` (string): The WorkflowAction.id of the next action.


--------------------------------------------------------------------------------
title: "Release Phases for Inngest"
source: "https://www.inngest.com/docs/release-phases"
--------------------------------------------------------------------------------

# Release Phases for Inngest

This pages outlines how Inngest features and products are released through 3 distinct phases of development maturity and availability to users.

The release flow varies depending on the security or scalability requirements of the newly available feature or product:

Releases can follow a non-linear flow to GA, the above graphic is not strict, but an idea of how features may flow from internal development to GA.
Additionally (*not pictured*), small features might go from internal development directly to GA for a launch.

You will find below the details of each release phase.

## Release Phases

### Developer Preview

Products or features released as a Developer Preview are still under development, made available to early users for feedback.
This implies that the new APIs or methods made available via our APIs or SDKs are flagged as experimental and might change without strict version control or notice.

Developer preview features or products cheat sheet:

| Aspect         | Details                                                                                                                 |
| -------------- | ----------------------------------------------------------------------------------------------------------------------- |
| APIs           | **Exposes non-final APIs that might change without strict version control or notice**                                   |
| Documentation  | Provides limited documentation that will evolve with users' feedback                                                    |
| Production Use | **Not recommended for production use and not covered by the Service Level Agreement applicable to the Enterprise plan** |
| Limitations    | May come with limitations specific to the feature, such as plan-based or usage-based restrictions                       |
| Pricing        | Limited free availability during preview phase                                                                          |

Features or products currently in developer preview:

- [Realtime](/docs-markdown/features/realtime)
- [Connect](/docs-markdown/setup/connect)
- [AgentKit](https://agentkit.inngest.com/)

### Private/Public Beta

Product or features in private or public beta are nearing GA, but still require some work to meet our desired quality standards (ex, reliability improvements, scalability stress tests).  In this phase, most products or features will be almost complete and should handle workloads correctly, but may exhibit issues we were unaware of during early access.

Beta features or products cheat sheet:

| Aspect         | Details                                                                                                                     |
| -------------- | --------------------------------------------------------------------------------------------------------------------------- |
| APIs           | Provide almost final APIs that may change following strict version control and communications                               |
| Documentation  | Provide extended documentation covering a getting-started guide, references, and an edge cases FAQ                          |
| Production Use | **Not recommended for production use and are not covered by the Service Level Agreement applicable to the Enterprise plan** |
| Support        | Grants access to a channel to share feedback (*in case of private beta*)                                                    |
| Limitations    | May come with limitations specific to the feature, such as plan-based or usage-based restrictions                           |
| Pricing        | Limited free availability during preview phase                                                                              |

> **Callout:** Private beta vs. public betaFeatures or products that require scalability stress tests, security considerations, or early customer feedback are good candidates for a private beta, ensuring a positive experience for all participants.
> Other features might be a good fit for public beta (ex, SDKs features, Inngest Dev Server improvements)

### General Availability

A product or feature in general availability is considered secure, scalable, and stable, and is ready for use by users and customers across all plans.

General availability features or products cheat sheet:

| Aspect         | Details                                                                                                                                                     |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| APIs           | **Exposes final APIs that may evolve following strict version control and an associated changelog**                                                         |
| Documentation  | Provide complete documentation from quickstarts, examples, and demos                                                                                        |
| Production Use | **Ready to be used in production by users and customers across all plans and are covered by the Service Level Agreement applicable to the Enterprise plan** |
| Limitations    | Limitations are properly documented (*if any*)                                                                                                              |
| Pricing        | Pricing is moved into an entitlement                                                                                                                        |

### Deprecated

The deprecation of features or products follows the following agenda over multiple months:

1. Addition of deprecated mentions in the relevant documentation pages
   1. Publishing of migration guides (if applicable)
2. Communication with users and customers over emails, Discord, and private support Slack channels
3. Update of SDKs to highlight the deprecated APIs (if applicable)
4. Targeted email reminders weeks before the target sunset date

## FAQ

### How feedback are collected during the developer preview phase?

During the Developer Preview and Public beta phases, we collect feedback from users and customers over our Discord channel.

Feedback from GA and private beta phases are collected over our private support Slack channel, our Discord channel and our [support portal](https://app.inngest.com/support).

### How can I stay updated on the release of new features and products?

You can follow us on [Twitter](https://x.com/inngest) or [Discord](https://discord.gg/inngest) to get notified when new features and products are released.

You can also subscribe to our [newsletter](https://inngest.com/newsletter) to get notified when new features and products are released.


--------------------------------------------------------------------------------
title: "Environment Variables"
source: "https://www.inngest.com/docs/sdk/environment-variables"
--------------------------------------------------------------------------------

# Environment Variables

You can set environment variables to change various parts of Inngest's configuration.

We'll look at all available environment variables here, what to set them to, and what our recommendations are for their use.

- [INNGEST\_BASE\_URL](#inngest-base-url)
- [INNGEST\_DEV](#inngest-dev)
- [INNGEST\_ENV](#inngest-env)
- [INNGEST\_EVENT\_KEY](#inngest-event-key)
- [INNGEST\_LOG\_LEVEL](#inngest-log-level)
- [INNGEST\_SERVE\_HOST](#inngest-serve-host)
- [INNGEST\_SERVE\_PATH](#inngest-serve-path)
- [INNGEST\_SIGNING\_KEY](#inngest-signing-key)
- [INNGEST\_STREAMING](#inngest-streaming)

Within some frameworks and platforms such as Cloudflare Workers, environment
variables are not available in the global scope and are instead passed as
runtime arguments to your handler. In this case, you can use
`inngest.setEnvVars()` to ensure your client has the correct configuration
before communicating with Inngest.

```ts
// For example, in Hono on Cloudflare Workers
app.on("POST", "/my-api/send-some-event", async (c) => {
  inngest.setEnvVars(c.env);

  await inngest.send({ name: "test/event" });

  return c.json({ message: "Done!" });
});

// You can also chain the call to be succinct
await inngest.setEnvVars(c.env).send({ name: "test/event" });
```

***

## INNGEST\_BASE\_URL

Use this to tell an SDK the host to use to communicate with Inngest.

If set, it should be the host including the protocol and port, e.g. `http://localhost:8288` or `https://my.tunnel.com`. Can be overwritten by manually specifying `baseUrl` in `new Inngest()` or `serve()`.

In most cases we recommend keeping this unset. A common case, though, is wanting
to force a production build of your app to use the Inngest Dev Server instead of
Inngest Cloud for local integration testing or similar.

In this case, prefer using [INNGEST\_DEV=1](#inngest-dev). For Docker, it may be
appropriate to also set `INNGEST_BASE_URL=http://host.docker.internal:8288`. Learn more in our [Docker guide](/docs-markdown/guides/development-with-docker).

***

## INNGEST\_DEV

Use this to force an SDK to be in Dev Mode with `INNGEST_DEV=1`, or Cloud mode
with `INNGEST_DEV=0`. A URL for the dev server can be set at the same time with `INNGEST_DEV=http://localhost:8288`.

Can be overwritten by manually specifying `isDev` in `new Inngest()`.

Explicitly setting either mode will change the URLs used to communicate with
Inngest, as well as turning **off** signature verification in Dev mode, or **on** in
Cloud mode.

If neither the environment variable nor config option are specified, the SDK will
attempt to infer which mode it should be in based on environment variables such
as `NODE_ENV`.

***

## INNGEST\_ENV

Use this to tell Inngest which [Inngest Environment](/docs-markdown/platform/environments?ref=environment-variables) you're wanting to send and receive events from.

Can be overwritten by manually specifying `env` in `new Inngest()`.

This is detected and set automatically for some platforms, but others will need manual action. See [Configuring branch environments](/docs-markdown/platform/environments#configuring-branch-environments?ref=environment-variables) to see if you need this.

***

## INNGEST\_EVENT\_KEY

The key to use to send events to Inngest. See [Creating an Event Key](/docs-markdown/events/creating-an-event-key?ref=environment-variables) for more information.

Can be overwritten by manually specifying `eventKey` in `new Inngest()`.

***

## INNGEST\_LOG\_LEVEL

The log level to use for the SDK. Can be one of `fatal`, `error`, `warn`, `info`, `debug`, or `silent`.

Defaults to `info`.

***

## INNGEST\_SERVE\_HOST

The host used to access this application from Inngest Cloud.

If set, it should be the host including the protocol and port, e.g. `http://localhost:8288` or `https://my.tunnel.com`. Can be overwritten by manually specifying `serveHost` in `serve()`.

By default, an SDK will try to infer this using request details such as the `Host` header, but sometimes this isn't possible (e.g. when running in a more controlled environment such as AWS Lambda or when dealing with proxies/redirects).

***

## INNGEST\_SERVE\_PATH

The path used to access this application from Inngest Cloud.

If set, it should be a valid URL path with a leading `/`, e.g. `/api/inngest`.

By default, an SDK will try to infer this using request details, but sometimes this isn't possible (e.g. when running in a more controlled environment such as AWS Lambda or when dealing with proxies/redirects).

***

## INNGEST\_SIGNING\_KEY

The key used to sign requests to and from Inngest to ensure secure communication. See [Serve - Signing Key](/docs-markdown/learn/serving-inngest-functions#signing-key?ref=environment-variables) for more information.

Can be overwritten by manually specifying `signingKey` in `serve()`.

***

## INNGEST\_SIGNING\_KEY\_FALLBACK

Only used during signing key rotation. When it's specified, the SDK will automatically retry signing key auth failures with the fallback key.

Available in version `3.18.0` and above.

***

## INNGEST\_STREAMING

Sets an SDK's streaming support, potentially circumventing restrictive request timeouts and other limitations. See [Streaming](/docs-markdown/streaming?ref=environment-variables) for more information.

Can be one of `allow`, `force`, or `false`.

By default, this is `false`, disabling streaming. It can also be overwritten by setting `streaming` in `serve()` with the same values.


--------------------------------------------------------------------------------
title: "ESLint Plugin"
source: "https://www.inngest.com/docs/sdk/eslint"
--------------------------------------------------------------------------------

# ESLint Plugin

An ESLint plugin is available at [@inngest/eslint-plugin](https://www.npmjs.com/package/@inngest/eslint-plugin), providing rules to enforce best practices when writing Inngest functions.

## Getting started

Install the package using whichever package manager you'd prefer as a [dev dependency](https://docs.npmjs.com/cli/v10/configuring-npm/package-json#devdependencies).

```sh
npm install -D @inngest/eslint-plugin
```

Add the plugin to your ESLint configuration file with the recommended config.

```json
{
  "plugins": ["@inngest"],
  "extends": ["plugin:@inngest/recommended"]
}
```

You can also manually configure each rule instead of using the `plugin:@inngest/recommend` config.

```json
{
  "plugins": ["@inngest"],
  "rules": {
    "@inngest/await-inngest-send": "warn"
  }
}
```

See below for a list of all rules available to configure.

## Rules

- [@inngest/await-inngest-send](#inngest-await-inngest-send)
- [@inngest/no-nested-steps](#inngest-no-nested-steps)
- [@inngest/no-variable-mutation-in-step](#inngest-no-variable-mutation-in-step)

### @inngest/await-inngest-send

You should use `await` or `return` before \`inngest.send().

```json
"@inngest/await-inngest-send": "warn" // recommended
```

In serverless environments, it's common that runtimes are forcibly killed once a request handler has resolved, meaning any pending promises that are not performed before that handler ends may be cancelled.

```ts
// ‚ùå Bad
inngest.send({ name: "some.event" });
```

```ts
// ‚úÖ Good
await inngest.send({ name: "some.event" });
```

#### When not to use it

There are cases where you have deeper control of the runtime or when you'll safely `await` the send at a later time, in which case it's okay to turn this rule off.

### @inngest/no-nested-steps

Use of `step.*` within a `step.run()` function is not allowed.

```json
"@inngest/no-nested-steps": "error" // recommended
```

Nesting `step.run()` calls is not supported and will result in an error at runtime. If your steps are nested, they're probably reliant on each other in some way. If this is the case, extract them into a separate function that runs them in sequence instead.

```ts
// ‚ùå Bad
await step.run("a", async () => {
  const someValue = "...";
  await step.run("b", () => {
    return use(someValue);
  });
});
```

```ts
// ‚úÖ Good
const aThenB = async () => {
  const someValue = await step.run("a", async () => {
    return "...";
  });

  return step.run("b", async () => {
    return use(someValue);
  });
};

await aThenB();
```

### @inngest/no-variable-mutation-in-step

Do not mutate variables inside `step.run()`, return the result instead.

```json
"@inngest/no-variable-mutation-in-step": "error" // recommended
```

Inngest executes your function multiple times over the course of a single run, memoizing state as it goes. This means that code within calls to `step.run()` is not called on every execution.

This can be confusing if you're using steps to update variables within the function's closure, like so:

```ts
// ‚ùå Bad
// THIS IS WRONG!  step.run only runs once and is skipped for future
// steps, so userID will not be defined.
let userId;

// Do NOT do this!  Instead, return data from step.run.
await step.run("get-user", async () => {
  userId = await getRandomUserId();
});

console.log(userId); // undefined
```

Instead, make sure that any variables needed for the overall function are *returned* from calls to `step.run()`.

```ts
// ‚úÖ Good
// This is the right way to set variables within step.run :)
const userId = await step.run("get-user", () => getRandomUserId());

console.log(userId); // 123
```


--------------------------------------------------------------------------------
title: "Upgrading from Inngest SDK v2 to v3"
source: "https://www.inngest.com/docs/sdk/migration"
--------------------------------------------------------------------------------

# Upgrading from Inngest SDK v2 to v3

This guide walks through migrating your code from v2 to v3 of the Inngest TS SDK.

Upgrading from an earlier version? See further down the page:

- [Upgrading from v1 to v2](#breaking-changes-in-v2)
- [Upgrading from v0 to v1](#migrating-from-inngest-sdk-v0-to-v1)

## Breaking changes in v3

Listed below are all breaking changes made in v3, potentially requiring code changes for you to upgrade.

- [Clients and functions now require IDs](#clients-and-functions-require-ids)
- [Steps now require IDs](#all-steps-require-ids)
- [Refactored serve handlers](#serve-handlers-refactored)
- [Removed shorthand function creation](#shorthand-function-creation-removed)
- [Refactored environment variables and config](#environment-variables-and-configuration)
- [Advanced: Updating custom framework serve handlers](#advanced-updating-custom-framework-serve-handlers)
- [Removed `fns` option](#fns-removed)

## Removing the guard rails

Aside from some of the breaking changes above, this version also some new features.

- **Versioning and state recovery** - Functions can change over time and even mid-run; our new engine will recover and adapt, even for functions running across huge timespans.
- **Allow mixing step and async logic** - Top-level `await` alongside steps is now supported within Inngest functions, allowing easier reuse of logic and complex use cases like dynamic imports.
- **Sending events returns IDs** - Sending an event now returns the event ID that has created.

See [Introducing Inngest TypeScript SDK v3.0](/blog/releasing-ts-sdk-3?ref=migration) to see what these features unlock for the future of the TS SDK.

## A simple example

The surface-level changes for v3 and mostly small syntactical changes, which TypeScript should be able to guide you through.

Here's a quick view of transitioning a client, function, and serve handler to v3.

> **Callout:** When migrating, you'll want your ID to stay the same to ensure that in-progress runs switch over smoothly. We export a slugify() function you can use to generate an ID from your existing name as we used to do internally.import \{ slugify } from "inngest";
>
> const fn = inngest.createFunction(
> &#x20; \{ id: slugify("Onboarding Example"), name: "Onboarding Example" },
> &#x20; \{ event: "app/user.created" },
> &#x20; async (\{ event, step }) => \{
> &#x20;   // ...
> &#x20; }
> );This is only needed to ensure function runs started on v2 will transition to v3; new functions can specify any ID.

> **Callout:** ‚ö†Ô∏è slugify() should only be applied to function IDs, not application IDs. Changing the application ID will result new app, archiving the existing one.

```ts
import { Inngest, slugify } from "inngest";
import { serve } from "inngest/next";

const inngest = new Inngest({
  id: "My App",
});

const fn = inngest.createFunction(
  // NOTE: You can manually slug IDs or import slugify to convert names to IDs automatically.
  // { id: "onboarding-example", name: "Onboarding example" },
  { id: slugify("Onboarding example"), name: "Onboarding example" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    await step.run("send-welcome-email", () =>
      sendEmail(event.user.email, "Welcome!")
    );

    const profileCompleted = await step.waitForEvent(
      "wait-for-profile-completion",
      {
        event: "app/user.profile.completed",
        timeout: "1d",
        match: "data.userId",
      }
    );

    await step.sleep("wait-a-moment", "5m");

    if (!profileCompleted) {
      await step.run("send-profile-reminder", () =>
        sendEmail(event.user.email, "Complete your profile!")
      );
    }
  }
);

export default serve({
  client: inngest,
  functions: [fn],
});
```

```ts
import { Inngest } from "inngest";
import { serve } from "inngest/next";

// Clients only previously required a `name`, but we want to be
// explicit that this is used to identify your application and manage
// concepts such as deployments.
const inngest = new Inngest({ name: "My App" });

const fn = inngest.createFunction(
  // Similarly, functions now require an `id` and `name` is optional.
  { name: "Onboarding Example" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    // `step.run()` stays the same.
    await step.run("send-welcome-email", () =>
      sendEmail(event.user.email, "Welcome!")
    );

    // The shape of `waitForEvent` has changed; all steps now require
    // an ID.
    const profileCompleted = await step.waitForEvent(
      "app/user.profile.completed",
      {
        timeout: "1d",
        match: "data.userId",
      }
    );

    // All steps, even sleeps, require IDs.
    await step.sleep("5m");

    if (!profileCompleted) {
      await step.run("send-profile-reminder", () =>
        sendEmail(event.user.email, "Complete your profile!")
      );
    }
  }
);

// Serving now uses a single object parameter for better readability.
export default serve(inngest, [fn]);
```

If during migration your function ID is not the same, you'll see duplicated functions in your function list. In that case, the recommended approach is to archive the old function using the dashboard.

## Clients and functions require IDs

When instantiating a client using `new Inngest()` or creating a function via `inngest.createFunction()`, it's now required to pass an `id` instead of a `name`. We recommend changing the property name and wrapping the value in `slugify()` to ensure you don't redeploy any functions.

#### Creating a client

```ts
import { Inngest } from "inngest";

export const inngest = new Inngest({
  id: "My App",
});
```

```ts
import { Inngest } from "inngest";

export const inngest = new Inngest({
  name: "My App",
});
```

#### Creating a function

```ts
inngest.createFunction(
  { id: "send-welcome-email", name: "Send welcome email" },
  { event: "app/user.created" },
  async ({ event }) => {
    // ...
  }
);
```

```ts
inngest.createFunction(
  { name: "Send welcome email" },
  { event: "app/user.created" },
  async ({ event }) => {
    // ...
  }
);
```

Previously, only `name` was required, but this implied that the value was safe to change. Internally, we used this name to produce an ID which was used during deployments and executions.

## All steps require IDs

When using any `step.*` tool, an ID is now required to ensure that determinism across changes to a function is easier to reason about for the user and the underlying engine.

The addition of these IDs allows you to deploy hotfixes and logic changes to long-running functions without fear of errors, failures, or panics. Beforehand, any changes to a function resulted in an irrecoverable error if step definitions changed. With this, changes to a function are smartly applied by default.

Every step tool now takes a new option, `StepOptionsOrId`, as its first argument. Either a `string`, indicating the ID for that step, or an object that can also include a friendly `name`.

```ts
type StepOptionsOrId =
  | string
  | {
      id: string;
      name?: string;
    };
```

#### `step.run()`

This tool shouldn't require any changes. We'd still recommend changing the ID to something that's more obviously an identifier, like `send-welcome-email`, but you should wait for all existing v2 runs to complete before doing so.

See [Handling in-progress runs triggered from v2](#handling-in-progress-runs-triggered-from-v2) for more information.

#### `step.sendEvent()`

```ts
step.sendEvent("broadcast-user-creation", {
  name: "app/user.created",
  data: {
    /* ... */
  },
});
```

```ts
step.sendEvent({
  name: "app/user.created",
  data: {
    /* ... */
  },
});
```

#### `step.sleep()`

```ts
step.sleep("wait-before-poll", "1m");
```

```ts
step.sleep("1m");
```

#### `step.sleepUntil()`

```ts
step.sleepUntil("wait-for-user-birthday", specialDate);
```

```ts
step.sleepUntil(specialDate);
```

#### `step.waitForEvent()`

```ts
step.waitForEvent("wait-for-user-login", {
  event: " app/user.login",
  timeout: "1h ",
});
```

```ts
step.waitForEvent("app/user.login", {
  timeout: "1h ",
});
```

## Serve handlers refactored

Serving functions could become a bit unwieldy with the format we had, so we've slightly altered how you serve your functions to ensure proper discoverability of options and aid in readability when revisiting the code.

> **Callout:** In v2, serve() would always return any, to ensure compatibility with any version of any framework. If you're experiencing issues, you can return to this - though we don't recommend it - by using a type assertion such as serve() as any.

Also see the [Environment variables and config](#environment-variables-and-configuration) section.

```ts
import { serve } from "inngest/next";
import { inngest, functions } from "~/inngest";

export default serve({
  client: inngest,
  functions,
  // ...options
});
```

```ts
import { serve } from "inngest/next";
import { inngest, functions } from "~/inngest";

export default serve(inngest, functions, {
  // ...options
});
```

## Shorthand function creation removed

`inngest.createFunction()` can no longer take a `string` as the first or second arguments; an object is now required to aid in the discoverability of options and configuration.

```ts
inngest.createFunction(
  { id: "send-welcome-email", name: "Send welcome email" },
  { event: "app/user.created" },
  async () => {
    // ...
  }
);
```

```ts
inngest.createFunction(
  "Send welcome email",
  "app/user.created",
  async () => {
    // ...
  }
);
```

## Environment variables and configuration

The arrangement of environment variables available has shifted a lot over the course of v2, so in v3 we've streamlined what's available and how they're used.

We've refactored some environment variables for setting URLs for communicating with Inngest.

- **‚úÖ Added `INNGEST_BASE_URL`** - Sets the URL to communicate with Inngest in one place, e.g. `http://localhost:8288`.
- **üõë Removed `INNGEST_API_BASE_URL`** - Set `INNGEST_BASE_URL` instead.
- **üõë Removed `INNGEST_DEVSERVER_URL`** - Set `INNGEST_BASE_URL` instead.

> **Callout:** If you were using INNGEST\_DEVSERVER\_URL to test a production build against a local dev server, set INNGEST\_BASE\_URL to your dev server's address instead.

We've also added some new environment variables based on config options available when serving Inngest functions.

- **‚úÖ Added `INNGEST_SERVE_HOST`** - Sets the `serveHost` serve option, e.g. `https://www.example.com`.
- **‚úÖ Added `INNGEST_SERVE_PATH`** - Sets the `servePath` serve option, e.g. `/api/inngest`.
- **‚úÖ Added `INNGEST_LOG_LEVEL`** - One of `"fatal" | "error" | "warn" | "info" | "debug" | "silent"`. Setting to `"debug"` will also set `DEBUG=inngest:*`.
- **‚úÖ Added `INNGEST_STREAMING`** - One of `"allow" | "force" | "false"`.

Check out the [Environment variables](/docs-markdown/sdk/environment-variables?ref=migration) page for information on all current environment variables.

In this same vein, we've also refactored some configuration options when creating an Inngest client and serving functions.

- `new Inngest()`
  - **‚úÖ Added `baseUrl`** - Sets the URL to communicate with Inngest in one place, e.g. `"http://localhost:8288"`. Synonymous with setting the `INNGEST_BASE_URL` environment variable above.
  - **üõë Removed `inngestBaseUrl`** - Set `baseUrl` instead.
- `serve()`
  - **‚úÖ Added `baseUrl`** - Sets the URL to communicate with Inngest in one place, e.g. `"http://localhost:8288"`. Synonymous with setting the `INNGEST_BASE_URL` environment variable above or using `baseUrl` when creating the client.
  - **üõë Removed `inngestBaseUrl`** - Set `baseUrl` instead.
  - **üõë Removed `landingPage`** - The landing page for the SDK was deprecated in v2. Use the Inngest Dev Server instead via `npx --ignore-scripts=false inngest-cli@latest dev`.

## Handling in-progress runs triggered from v2

When upgrading to v3, there may be function runs in progress that were started using v2. For this reason, v3's engine changes are backwards compatible with v2 runs.

> **Callout:** step.run() should require no changes from v2 to v3. To ensure runs are backwards-compatible, make sure to keep the ID the same while in-progress v2 runs complete.

## Advanced: Updating custom framework serve handlers

We found that writing custom serve handlers could be a confusing experience, focusing heavily on Inngest concepts. With v3, we've changed these handlers to now focus almost exclusively on shared concepts around how to parse requests and send responses.

A handler is now defined by telling Inngest how to access certain pieces of the request and how to send a response. Handlers are also now correctly typed, meaning the output of `serve()` will be a function signature compatible with your framework.

See the simple handler below that uses the native `Request` and `Response` objects to see the comparison between v2 and v3.

As with custom handlers previously, check out our [custom framework handlers](/docs-markdown/learn/serving-inngest-functions#custom-frameworks?ref=migration) section to see how to define your own.

```ts
export const serve = (options: ServeHandlerOptions) => {
  const handler = new InngestCommHandler({
    frameworkName,
    ...options,
    handler: (req: Request) => {
      return {
        body: () => req.json(),
        headers: (key) => req.headers.get(key),
        method: () => req.method,
        url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
        transformResponse: ({ body, status, headers }) => {
          return new Response(body, { status, headers });
        },
      };
    },
  });

  return handler.createHandler();
};
```

```ts
export const serve: ServeHandler = (inngest, fns, opts) => {
  const handler = new InngestCommHandler(
    name,
    inngest,
    fns,
    {
      fetch: fetch.bind(globalThis),
      ...opts,
    },
    (req: Request) => {
      const url = new URL(req.url, `https://${req.headers.get("host") || ""}`);

      return {
        url,
        register: () => {
          if (req.method === "PUT") {
            return {
              deployId: url.searchParams.get(queryKeys.DeployId) as string,
            };
          }
        },
        run: async () => {
          if (req.method === "POST") {
            return {
              data: (await req.json()) as Record<string, unknown>,
              fnId: url.searchParams.get(queryKeys.FnId) as string,
              stepId: url.searchParams.get(queryKeys.StepId) as string,
              signature: req.headers.get(headerKeys.Signature) as string,
            };
          }
        },
        view: () => {
          if (req.method === "GET") {
            return {
              isIntrospection: url.searchParams.has(queryKeys.Introspect),
            };
          }
        },
      };
    },
    ({ body, status, headers }): Response => {
      return new Response(body, { status, headers });
    }
  );

  return handler.createHandler();
};
```

## Function `fns` option removed

In v2, providing a `fns` option when creating a function -- an object of functions -- would wrap those passed functions in `step.run()`, meaning you can run code inside your function without the `step.run()` boilerplate.

This wasn't a very well advertised feature and had some drawbacks, so we're instead replacing it with some optional middleware.

Check out the [Common Actions Middleware Example](/docs-markdown/reference/middleware/examples#common-actions-for-every-function?ref=migration) for the code.

```ts
import * as actions from "./actions";
import { createActionsMiddleware } from "./middleware";

const inngest = new Inngest({
  id: "my-app",
  name: "My App",
  middleware: [createActionsMiddleware(actions)],
});

inngest.createFunction(
  { name: "Send welcome email" },
  { event: "app/user.created" },
  async ({ event, action }) => {
    const user = await action.getUserFromDb(event.data.userId);
    await action.sendWelcomeEmail(user.email);
  }
);
```

```ts
import * as actions from "./actions";

const inngest = new Inngest({ name: "My App" });

inngest.createFunction(
  {
    name: "Send welcome email",
    fns: actions,
  },
  { event: "app/user.created" },
  async ({ event, fns }) => {
    const user = await fns.getUserFromDb(event.data.userId);
    await fns.sendWelcomeEmail(user.email);
  }
);
```

***

# Upgrading from Inngest SDK v1 to v2

This guide walks through migrating your code from v1 to v2 of the Inngest TS SDK.

## Breaking changes in v2

Listed below are all breaking changes made in v2, potentially requiring code changes for you to upgrade.

- &#x20;[Better event schemas](#better-event-schemas) - create and maintain your event types with a variety of native tools and third-party libraries
- [Clearer event sending](#clearer-event-sending) - we removed some alternate methods of sending events to settle on a common standard
- [Removed `tools` parameter](#removed-tools-parameter) - use `step` instead of `tools` for step functions
- [Removed ability to `serve()` without a client](#removed-ability-to-serve-without-a-client) - everything is specified with a client, so it makes sense for this to be the same
- [Renamed `throttle` to `rateLimit`](#renamed-throttle-to-ratelimit) - the concept didn't quite match the naming

## New features in v2

Aside from some of the breaking features above, this version also adds some new features that aren't breaking changes.

- [Middleware](/docs-markdown/reference/middleware/overview?ref=migration) - specify functions to run at various points in an Inngest client's lifecycle
- **Logging** - use a default console logger or specify your own to log during your workflows

## Better event schemas

Typing events is now done using a new `EventSchemas` class to create a guided, consistent, and extensible experience for declaring an event's data. This helps us achieve a few goals:

- Reduced duplication (no more `name`!)
- Allow many different methods of defining payloads to suit your codebase
- Easy to add support for third-party libraries like Zod and TypeBox
- Much clearer messaging when an event type doesn't satisfy what's required
- Allows the library to infer more data itself, which allows us to add even more powerful type inference

```ts
// ‚ùå Invalid in v2
type Events = {
  "app/user.created": {
    name: "app/user.created";
    data: { id: string };
  };
  "app/user.deleted": {
    name: "app/user.deleted";
    data: { id: string };
  };
};

new Inngest<Events>();
```

Instead, in v2, we use a new `EventSchemas` class and its methods to show current event typing support clearly. All we have to do is create a `new EventSchemas()` instance and pass it into our `new Inngest()` instance.

```ts
import { Inngest, EventSchemas } from "inngest";
//                ‚¨ÜÔ∏è New "EventSchemas" class

// ‚úÖ Valid in v2 - `fromRecord()`
type Events = {
  "app/user.created": {
    data: { id: string };
  };
  "app/user.deleted": {
    data: { id: string };
  };
};

new Inngest({
  schemas: new EventSchemas().fromRecord<Events>(),
});
```

Notice we've reduced the duplication of `name` slightly too; a common annoyance we've been seeing for a while!

We use `fromRecord()` above to match the current event typing quite closely, but we now have some more options to define events without having to shim, like `fromUnion()`:

```ts
// ‚úÖ Valid in v2 - `fromUnion()`
type AppUserCreated = {
  name: "app/user.created";
  data: { id: string };
};

type AppUserDeleted = {
  name: "app/user.deleted";
  data: { id: string };
};

new EventSchemas().fromUnion<AppUserCreated | AppUserDeleted>();
```

This approach also gives us scope to add explicit support for third-party libraries, like Zod:

```ts
// ‚úÖ Valid in v2 - `fromZod()`
const userDataSchema = z.object({
  id: z.string(),
});

new EventSchemas().fromZod({
  "app/user.created": { data: userDataSchema },
  "app/user.deleted": { data: userDataSchema },
});
```

Stacking multiple event sources was technically supported in v1, but was a bit shaky. In v2, providing multiple event sources and optionally overriding previous ones is built in:

```ts
// ‚úÖ Valid in v2 - stacking
new EventSchemas()
  .fromRecord<Events>()
  .fromUnion<Custom1 | Custom2>()
  .fromZod(zodEventSchemas);
```

Finally, we've added the ability to pull these built types out of Inngest for creating reusable logic without having to create an Inngest function. Inngest will append relevant fields and context to the events you input, so this is a great type to use for quickly understanding the resulting shape of data.

```ts
import { Inngest, type GetEvents } from "inngest";

const inngest = new Inngest({ name: "My App" });
type Events = GetEvents<typeof inngest>;
```

For more information, see [Defining Event Payload Types](/docs-markdown/reference/client/create#defining-event-payload-types?ref=migration).

## Clearer event sending

v1 had two different methods of sending events that shared the same function. This "overload" resulted in autocomplete typing for TypeScript users appear more complex than it needed to be.

In addition, using a particular signature meant that you're locked in to sending a particular named event, meaning sending two different events in a batch required refactoring your call.

For these reasons, we've removed a couple of the event-sending signatures and settled on a single standard.

```ts
// ‚ùå Invalid in v2
inngest.send("app/user.created", { data: { userId: "123" } });
inngest.send("app/user.created", [
  { data: { userId: "123" } },
  { data: { userId: "456" } },
]);

// ‚úÖ Valid in v1 and v2
inngest.send({ name: "app/user.created", data: { userId: "123" } });
inngest.send([
  { name: "app/user.created", data: { userId: "123" } },
  { name: "app/user.created", data: { userId: "456" } },
]);
```

## Removed `tools` parameter

The `tools` parameter in a function was marked as deprecated in v1 and is now being fully removed in v2.

You can swap out `tools` with `step` in every case.

```ts
inngest.createFunction(
  { name: "Example" },
  { event: "app/user.created" },
  async ({ tools, step }) => {
    // ‚ùå Invalid in v2
    await tools.run("Foo", () => {});

    // ‚úÖ Valid in v1 and v2
    await step.run("Foo", () => {});
  }
);
```

## Removed ability to `serve()` without a client

In v1, serving Inngest functions could be done without a client via `serve("My App Name", ...)`. This limits our ability to do some clever TypeScript inference in places as we don't have access to the client that the functions have been created with.

We're shifting to ensure the client is the place where everything is defined and created, so we're removing the ability to `serve()` with a string name.

```ts
// ‚ùå Invalid in v2
serve("My App", [...fns]);

// ‚úÖ Valid in v1 and v2
import { inngest } from "./client";
serve(inngest, [...fns]);
```

As is the case already in v1, the app's name will be the name of the client passed to serve. To preserve the ability to explicitly name a serve handler, you can now pass a `name` option when serving to use the passed string instead of the client's name.

```ts
serve(inngest, [...fns], {
  name: "My Custom App Name",
});
```

## Renamed `throttle` to `rateLimit`

Specifying a rate limit for a function in v1 meant specifying a `throttle` option when creating the function. The term "throttle" was confusing here, as the definition of throttling can change depending on the context, but usually implies that "throttled" events are still eventually used to trigger an event, which was not the case.

To be clearer about the functionality of this option, we're renaming it to `rateLimit` instead.

```ts
inngest.createFunction(
  {
    name: "Example",
    throttle: { count: 5 }, // ‚ùå Invalid in v2
    rateLimit: { limit: 5 }, // ‚úÖ Valid in v2
  },
  { event: "app/user.created" },
  async ({ tools, step }) => {
    // ...
  }
);
```

***

## Migrating from Inngest SDK v0 to v1

This guide walks through migrating to the Inngest TS SDK v1 from previous versions.

## What's new in v1

- **Step functions and tools are now async** - create your flow however you'd express yourself with JavaScript Promises.
- **`inngest.createFunction` for everything** - all functions are now step functions; just use step tools within any function.
- **Unified client instantiation and handling of schemas via `new Inngest()`** - removed legacy helpers that required manual types.
- **A foundation for continuous improvement:**
  - Better type inference and schemas
  - Better error handling
  - Clearer patterns and tooling
  - Advanced function configuration

## Replacing function creation helpers

Creating any Inngest function now uses `inngest.createFunction()` to create a consistent experience.

- All helpers have been removed
- `inngest.createScheduledFunction()` has been removed
- `inngest.createStepFunction()` has been removed

```ts
// ‚ùå Removed in v1
import {
  createFunction,
  createScheduledFunction,
  createStepFunction,
} from "inngest";

// ‚ùå Removed in v1
inngest.createScheduledFunction(...);
inngest.createStepFunction(...);
```

The following is how we would always create functions without the v0 helpers.

```ts
// ‚úÖ Valid in v1
import { Inngest } from "inngest";

// We recommend exporting this from ./src/inngest/client.ts, giving you a
// singleton across your entire app.
export const inngest = new Inngest({ name: "My App" });

const singleStepFn = inngest.createFunction(
  { name: "Single step" },
  { event: "example/single.step" },
  async ({ event, step }) => "..."
);

const scheduledFn = inngest.createFunction(
  { name: "Scheduled" },
  { cron: "0 9 * * MON" },
  async ({ event, step }) => "..."
);

const stepFn = inngest.createFunction(
  { name: "Step function" },
  { event: "example/step.function" },
  async ({ event, step }) => "..."
);
```

This helps ensure that important pieces such as type inference of events has a central place to reside.

As such, each of the following examples requries an Inngest Client (`new Inngest()`) is used to create the function.

```ts
import { Inngest } from "inngest";

// We recommend exporting your client from a separate file so that it can be
// reused across the codebase.
export const inngest = new Inngest({ name: "My App" });
```

See the specific examples below of how to transition from a helper to the new signatures.

`createFunction()`

```ts
// ‚ùå Removed in v1
const singleStepFn = createFunction(
  "Single step",
  "example/single.step",
  async ({ event }) => "..."
);
```

```ts
// ‚úÖ Valid in v1
const inngest = new Inngest({ name: "My App" });

const singleStepFn = inngest.createFunction(
  { name: "Single step" },
  { event: "example/single.step" },
  async ({ event, step }) => "..."
);
```

`createScheduledFunction()` or `inngest.createScheduledFunction()`

```ts
// ‚ùå Removed in v1
const scheduledFn = createScheduledFunction( // or inngest.createScheduledFunction
  "Scheduled",
  "0 9 * * MON",
  async ({ event }) => "..."
);
```

```ts
// ‚úÖ Valid in v1
const inngest = new Inngest({ name: "My App" });

const scheduledFn = inngest.createFunction(
  { name: "Scheduled" },
  { cron: "0 9 * * MON" },
  async ({ event, step }) => "..."
);
```

`createStepFunction` or `inngest.createStepFunction`

```ts
// ‚ùå Removed in v1
const stepFn = createStepFunction(
  "Step function",
  "example/step.function",
  ({ event, tools }) => "..."
);
```

```ts
// ‚úÖ Valid in v1
const inngest = new Inngest({ name: "My App" });

const stepFn = inngest.createFunction(
  { name: "Step function" },
  { event: "example/step.function" },
  async ({ event, step }) => "..."
);
```

## Updating to async step functions

The signature of a step function is changing.

- **`tools` is now `step`** - We renamed this to be easier to reason about billing and make the code more readable.
- **Always `async`** - Every Inngest function is now an async function with access to async `step` tooling.
- **Steps now return promises** - To align with the async patterns that developers are used to and to enable more flexibility, make sure to `await` steps.

Step functions in v0 were synchronous, meaning steps had to run sequentially, one after the other.

v1 brings the full power of asynchronous JavaScript to those functions, meaning you can use any and all async tooling at your disposal; `Promise.all()`, `Promise.race()`, loops, etc.

```ts
await Promise.all([
  step.run("Send email", () => sendEmail(user.email, "Welcome!")),
  step.run("Send alert to staff", () => sendAlert("New user created!")),
]);
```

Here we look at an example of a step function in v0 and compare it with the new v1.

```ts
// ‚ö†Ô∏è v0 step function
import { createStepFunction } from "inngest";
import { getUser } from "./db";
import { sendAlert, sendEmail } from "./email";

export default createStepFunction(
  "Example",
  "app/user.created",
  ({ event, tools }) => {
    const user = tools.run("Get user email", () => getUser(event.userId));

    tools.run("Send email", () => sendEmail(user.email, "Welcome!"));
    tools.run("Send alert to staff", () => sendAlert("New user created!"));
  }
);

```

```ts
// ‚úÖ v1 step function
import { inngest } from "./client";
import { getUser } from "./db";
import { sendAlert, sendEmail } from "./email";

export default inngest.createFunction(
  { name: "Example" },
  { event: "app/user.created" },
  async ({ event, step }) => {
    // The step must now be awaited!
    const user = await step.run("Get user email", () => getUser(event.userId));

    await step.run("Send email", () => sendEmail(user.email, "Welcome!"));
    await step.run("Send alert to staff", () => sendAlert("New user created!"));
  }
);
```

These two examples have the exact same functionality. As above, there are a few key changes that were required.

- Using `createFunction()` on the client to create the step function
- Awaiting step tooling to ensure they run in order
- Using `step` instead of `tools`

> **Callout:** When translating code to v1, be aware that not awaiting a step tool will mean it happens in the background, in parallel to the tools that follow. Just like a regular JavaScript async function, await halts progress, which is sometimes just what you want!

Async step functions with v1 of the Inngest TS SDK unlocks a huge `Array<Possibility>`. To explore these further, check out the [multi-step functions](/docs-markdown/guides/multi-step-functions?ref=migration) docs.

## Advanced: Updating custom framework serve handlers

If you're using a custom serve handler and are creating your own `InngestCommHandler` instance, a `stepId` must be provided when returning arguments for the `run` command.

This can be accessed via the query string using the exported `queryKeys.StepId` enum.

```ts
run: async () => {
  if (req.method === "POST") {
    return {
      fnId: url.searchParams.get(queryKeys.FnId) as string,
      // üÜï stepId is now required
      stepId: url.searchParams.get(queryKeys.StepId) as string,
```


--------------------------------------------------------------------------------
title: "Installing the SDK"
source: "https://www.inngest.com/docs/sdk/overview"
--------------------------------------------------------------------------------

# Installing the SDK

The Inngest SDK allows you to write reliable, durable functions in your existing projects incrementally. Functions can be automatically triggered by events or run on a schedule without infrastructure, and can be fully serverless or added to your existing HTTP server.

- It works with any framework and platform by using HTTP to call your functions
- It supports serverless providers, without any additional infrastructure
- It fully supports TypeScript out of the box
- You can locally test your code without any extra setup

## Getting started

#### TypeScript

### Installation

To get started, install the SDK via your favorite package manager:

```shell {{ title: "npm" }}
npm install inngest
```

```shell {{ title: "yarn" }}
yarn add inngest
```

```shell {{ title: "pnpm" }}
pnpm add inngest
```

```shell {{ title: "bun" }}
bun add inngest
```

### Setup

Once Inngest is installed, create an Inngest client, later used to define your functions and trigger events:

```typescript
import { Inngest } from "inngest";

export const inngest = new Inngest({
  id: "my-app",
});
```

#### Go

To get started, install the SDK via `go get`:

```shell
go get github.com/inngest/inngestgo
```

#### Python

### Installation

To get started, install the SDK via `pip`:

```shell
pip install inngest
```

### Setup

Once Inngest is installed, create an Inngest client, later used to define your functions and trigger events:

```python
import inngest
import logging

# Create an Inngest client
inngest_client = inngest.Inngest(
    app_id="app_example",
    logger=logging.getLogger("uvicorn"),
)
```

Your project is now ready to start writing Inngest functions:

1. [Define and write your functions](/docs-markdown/functions)
2. [Trigger functions with events](/docs-markdown/events)
3. [Set up and serve the Inngest API for your framework](/docs-markdown/learn/serving-inngest-functions)


--------------------------------------------------------------------------------
title: "Self-hosting"
source: "https://www.inngest.com/docs/self-hosting"
--------------------------------------------------------------------------------

# Self-hosting

Self-hosting support for Inngest is supported as of the 1.0 release.

- [Why self-host Inngest?](#why-self-host-inngest)
- [Inngest system architecture](#inngest-system-architecture)
- [How to self-host Inngest](#how-to-self-host-inngest)

## Why self-host Inngest?

While the easiest way to get started with Inngest is using our hosted platform, including our generous [free tier](/pricing?ref=docs-self-hosting), we understand that developers may want to self-host for a variety of reasons. If security or data privacy are concerns, review our [security documentation](/docs-markdown/learn/security?ref=docs-self-hosting) for more information including details about [end-to-end encryption](/docs-markdown/features/middleware/encryption-middleware?ref=docs-self-hosting).

## Inngest system architecture

To best understand how to self-host Inngest, it's important to understand the system architecture and components.

![Inngest system architecture diagram](/assets/docs-markdown/self-hosting/system-architecture-2024-09-23.png)

The system is composed of the following services:

- **Event API** - Receives events from SDKs via HTTP requests. Authenticates client requests via [Event Keys](/docs-markdown/events/creating-an-event-key?ref=docs-self-hosting). The Event API publishes event payloads to an internal event stream.
- **Event stream** - Acts as a buffer between the *Event API* and the *Runner*.
- **Runner** - Consumes incoming events and performs several actions:
  - Scheduling of new ‚Äúfunction runs‚Äù (aka jobs) given the event type, creating initial run state in the *State store* database. Runs are added to queues given the function's flow control configuration.
  - Resumes functions paused via [`waitForEvent`](/docs-markdown/features/inngest-functions/steps-workflows/wait-for-event?ref=docs-self-hosting) with matching expressions.
  - Cancels running functions with matching [`cancelOn`](/docs-markdown/features/inngest-functions/cancellation/cancel-on-events?ref=docs-self-hosting) expressions.
  - Writes ingested events to a database for historical record and future replay.
- **Queue** - A multitenant-aware, multitier queue designed for fairness and various [flow control](/docs-markdown/guides/flow-control?ref=docs-self-hosting) methods (concurrency, throttling, prioritization, debouncing, rate limiting) and [batching](/docs-markdown/guides/batching?ref=docs-self-hosting).
- **Executor** - Responsible for executing functions, from initial execution, step execution, writing incremental function run state to the *State store*, and retries after failures.
- **State store (database)** - Persists data for pending and ongoing function runs. Data includes initial triggering event(s), step output and step errors.
- **Database** - Persists system data and history including Apps, Functions, Events, Function run results.
- **API** - GraphQL and REST APIs for programmatic access and management of system resources.
- **Dashboard UI** - The UI to manage apps, functions and view function run history.

The source code for Inngest and all services is [available on GitHub](https://github.com/inngest/inngest).

## How to self-host Inngest

To begin self-hosting Inngest, you only need to install the Inngest CLI. The Inngest CLI is a single binary that includes all Inngest services and can be run in any environment. Alternatively, you can download the binary directly from [GitHub releases](https://github.com/inngest/inngest/releases).

```plaintext {{ title: "npm" }}
npm install -g inngest-cli
```

```plaintext {{ title: "Docker" }}
docker pull inngest/inngest
```

```plaintext {{ title: "curl" }}
curl -sfL https://cli.inngest.com/install.sh
```

Now that you have the CLI installed, you can start the Inngest server using the `inngest start` command.

```plaintext {{ title: "shell" }}
inngest start --event-key abcd --signing-key 1234
```

```plaintext {{ title: "Docker" }}
docker run -p 8288:8288 -p 8289:8289 -e INNGEST_EVENT_KEY=abcd -e INNGEST_SIGNING_KEY=1234 inngest/inngest inngest start
```

This will start the Inngest server on the default port `8288` and use the default configuration, including SQLite for persistence. Additionally, the Connect gateway will be available on port `8289`.

### Configuration

Configuring the server can be done via command-line flags, environment variables, or a configuration file.

By default, the server will:

- Run on `localhost:8288` to serve the Event API, API, and Dashboard UI. `localhost:8289` is used for `connect` workers ([see docs for more connect-specific configuration](/docs-markdown/setup/connect#self-hosted-inngest)).
- Use an in-memory Redis server for the queue and state store. (See [Using external services](#using-external-services) for more information.)
- Use SQLite for persistence. The default database is located at `./.inngest/main.db`. Queue and state store snapshots are periodically saved to the SQLite database, including prior to shutdown.
- Disable app sync polling to check for new functions or updated configurations (see `--poll-interval` flag).

To securely configure your server, create your event and signing keys using whatever format you choose and start the Inngest server using them. You can also pass them via environment variable (see below):

> **Callout:** The signing key must be a valid hexadecimal string with an even number of characters. You can generate a secure signing key using:openssl rand -hex 32

```plaintext
inngest start --event-key <YOUR_EVENT_KEY> --signing-key <YOUR_SIGNING_KEY>
```

Then you can use these same keys as environment variables when starting your application (`INNGEST_EVENT_KEY` and `INNGEST_SIGNING_KEY`). [See below](#configuring-inngest-sdks-to-use-self-hosted-server) for an example Node.js startup command.

To see all the available options, run `inngest start --help`:

```plaintext
$ inngest start --help
NAME:
   inngest start - [Beta] Run Inngest as a single-node service.

USAGE:
   inngest start [options]

DESCRIPTION:
   Example: inngest start

OPTIONS:
   --config string                                              Path to an Inngest configuration file
   --host string                                                Inngest server hostname
   --port string, -p string                                     Inngest server port (default: "8288")
   --sdk-url string, -u string [ --sdk-url string, -u string ]  App serve URLs to sync (ex. http://localhost:3000/api/inngest)
   --signing-key string                                         Signing key used to sign and validate data between the server and apps.
   --event-key string [ --event-key string ]                    Event key(s) that will be used by apps to send events to the server.
   --sqlite-dir string                                          Directory for where to write SQLite database.
   --redis-uri string                                           Redis server URI for external queue and run state. Defaults to self-contained, in-memory Redis server with periodic snapshot backups.
   --postgres-uri string                                        PostgreSQL database URI for configuration and history persistence. Defaults to SQLite database.
   --postgres-max-idle-conns int                                Sets the maximum number of idle database connections in the PostgreSQL connection pool. (default: 10)
   --postgres-max-open-conns int                                Sets the maximum number of open database connections allowed in the PostgreSQL connection pool. (default: 100)
   --postgres-conn-max-idle-time int                            Sets the maximum amount of time, in minutes, a PostgreSQL connection may be idle. (default: 5)
   --postgres-conn-max-lifetime int                             Sets the maximum amount of time, in minutes, a PostgreSQL connection may be reused. (default: 30)
   --poll-interval int                                          Interval in seconds between polling for updates to apps (default: 0)
   --retry-interval int                                         Retry interval in seconds for linear backoff when retrying functions - must be 1 or above (default: 0)
   --queue-workers int                                          Number of executor workers to execute steps from the queue (default: 100)
   --tick int                                                   The interval (in milliseconds) at which the executor polls the queue (default: 150)
   --connect-gateway-port int                                   Port to expose connect gateway endpoint (default: 8289)
   --no-ui                                                      Disable the web UI and GraphQL API endpoint (default: false)
   --help, -h                                                   show help

GLOBAL OPTIONS:
   --json                         Output logs as JSON.  Set to true if stdout is not a TTY. (default: false)
   --verbose                      Enable verbose logging. (default: false)
   --log-level string, -l string  Set the log level.  One of: trace, debug, info, warn, error. (default: "info")
```

**Environment variables**

Any CLI option can be set via environment variable by converting the flag to uppercase, replacing hyphens with underscores, and prefixing it with `INNGEST_`. For example, `--port 8288` can be set with the `INNGEST_PORT` environment variable.

**Configuration file** (`inngest.yaml`, `inngest.json`, etc.)

A configuration file can be specified with the `--config` flag. The file can be in YAML, JSON, TOML, or any other format supported by [Viper](https://github.com/spf13/viper). `urls` is used instead of `sdk-url` to specify your application's Inngest serve endpoints. An example configuration file is shown below:

```yaml {{ title: "inngest.yaml" }}
urls:
  - http://localhost:3000/api/inngest
poll-interval: 60
redis-uri: redis://localhost:6379
sqlite-dir: /app/data
```

```json {{ title: "inngest.json" }}
{
  "urls": [
    "http://localhost:3000/api/inngest"
  ],
  "poll-interval": 60,
  "redis-uri": "redis://localhost:6379",
  "sqlite-dir": "/app/data"
}
```

### Configuring Inngest SDKs to use self-hosted server

By default, the Inngest SDK will use URLs of the managed Inngest platform. To connect to a self-hosted server, set the [`INNGEST_DEV`](/docs-markdown/sdk/environment-variables#inngest-dev) and [`INNGEST_BASE_URL`](/docs-markdown/sdk/environment-variables#inngest-base-url) environment variables. As mentioned above, you'll also need to set the `INNGEST_EVENT_KEY` and `INNGEST_SIGNING_KEY` environment variables for securely connecting your application to the Inngest server.

For example, to connect to a self-hosted server running on `localhost:8288` for a Node.js app, set the following environment variables:

```plaintext
INNGEST_EVENT_KEY=<YOUR_EVENT_KEY> \
  INNGEST_SIGNING_KEY=<YOUR_SIGNING_KEY> \
  INNGEST_DEV=0 \
  INNGEST_BASE_URL=http://localhost:8288 \
  node ./server.js
```

### Using external services

Inngest can be configured to use external services for the queue and state store, and soon, the database.

**External Redis server**

With the goal of simplifying the initial setup, the Inngest server will run an in-memory Redis server for the queue and state store. As this is running within the same process as the Inngest server, running your own Redis server can improve performance and reliability of the system. You may choose to run your own Redis server or use a cloud-based Redis service like AWS ElastiCache, Redis Cloud, etc.

To use an external Redis server, set the `redis-uri` flag to the Redis server URI.

**External Postgres database**

By default, the Inngest server uses SQLite for persistence. This is convenient for zero-dependency deployments, but does not support scaling beyond a single node. You may choose to run your own Postgres database or use a cloud-based Postgres service like AWS RDS, Neon, Supabase, etc.

To use an external Postgres database, set the `postgres-uri` flag to your Postgres connection string URI.

## Docker compose example

```yaml
services:
  inngest:
    image: inngest/inngest
    command: "inngest start"
    ports:
      - "8288:8288" # APIs and Dashboard
      - "8289:8289" # Connect WebSocket gateway
    environment:
      - INNGEST_EVENT_KEY=your_event_key_here # Must be hex string with even number of chars
      - INNGEST_SIGNING_KEY=your_signing_key_here # Must be hex string with even number of chars
      - INNGEST_POSTGRES_URI=postgres://inngest:password@postgres:5432/inngest
      - INNGEST_REDIS_URI=redis://redis:6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - inngest-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8288/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  postgres:
    image: postgres:17
    environment:
      - POSTGRES_DB=inngest
      - POSTGRES_USER=inngest
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - inngest-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U inngest -d inngest"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - inngest-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

volumes:
  postgres_data:
  redis_data:

networks:
  inngest-network:
    driver: bridge

```

## Helm chart

Inngest provides a Helm chart for production-ready Kubernetes deployments. Key features include:

**Quick Setup & Production Ready**

- Supports Kubernetes 1.20+ and Helm 3.0+ with simple installation
- Bundled PostgreSQL and Redis for easy setup, with support for external databases
- Consistent resource naming across all environments regardless of Helm release name
- Deployment examples for development, production, and hybrid scenarios

**Autoscaling & Performance**

- KEDA-based autoscaling using Inngest's Prometheus metrics
- Configurable replica counts, resource limits, and queue worker settings
- Horizontal pod autoscaling based on queue depth

**Security & Access**

- Security-first design with non-root execution and read-only filesystem
- Database credentials stored securely in Kubernetes Secrets
- Network policy support for additional cluster isolation
- Built-in ingress support with SSL certificate provisioning via cert-manager
- Let's Encrypt integration for production HTTPS endpoints

You can find the chart, documentation, and configuration examples here:

[ inngest/inngest-helm](https://github.com/inngest/inngest-helm)

## Roadmap & feature requests

Planned features for self-hosting include:

- Improved health checks.
- Backlog monitoring endpoints for auto-scaling.
- High availability guide.
- Helm chart for easy deployment to Kubernetes.
- Data retention guides and recommendations.
- Event key and signing key management via API and UI.

To suggest additional features, please submit feedback on our [public roadmap](https://roadmap.inngest.com/roadmap).

Check out [the source code on GitHub](https://github.com/inngest/inngest) to file issues or submit pull requests.


--------------------------------------------------------------------------------
title: "Checkpointing"
source: "https://www.inngest.com/docs/setup/checkpointing"
--------------------------------------------------------------------------------

# Checkpointing

Checkpointing is a performance optimization for Inngest functions that executes steps eagerly rather than waiting on internal orchestration. The result is dramatically lower latency ‚Äî ideal for real-time AI workflows.

## Minimum Requirements

### Language

- **TypeScript**: SDK `3.51.0` or higher.
- **Go**: SDK version `v0.15.0`.

## Getting Started

#### TypeScript

To enable checkpointing:

1. Install `inngest@3.51.0` or higher
2. Set `checkpointing: true` on your Inngest client or on individual functions

**For all functions:**

```ts
import { Inngest } from "inngest";

export const inngest = new Inngest({
  id: "my-app",
  checkpointing: true,
});
```

**Per-function:**

```ts
export const myFunction = inngest.createFunction(
  {
    id: "my-function",
    checkpointing: true,
  },
  { event: "app/my.event" },
  async ({ step }) => {
    // steps here will be checkpointed
  }
);
```

### Configuration

Configure how checkpointing behaves with these options:

- `maxRuntime` - default: `0` (unlimited): The maximum amount of time the function should continuously execute and checkpoint steps before returning the request response. Configure this to be slightly less than the maximum allowed request timeout for your platform or server. For example, if your platform allows `900s`, you might set `maxRuntime` to `800s`.
- `bufferedSteps` - default: `1` (no buffering): The number of steps to buffer together before checkpointing. This can help reduce the number of requests made to Inngest when running many steps in sequence. Consider that buffered steps that are not checkpointed may be lost if your server is not gracefully terminated.
- `maxInterval`: The maximum interval to wait before checkpointing, even if the `bufferedSteps` count has not been reached.

```ts {{ title: "Example configuration" }}
checkpointing: {
  maxRuntime: '300s',
  bufferedSteps: 2,
  maxInterval: "10s",
}
```

#### Go

To enable checkpointing:

1. Install the checkpoint package:

```shell
go get github.com/inngest/inngestgo/pkg/checkpoint
```

2. Set `Checkpoint` on your function options:

```go
import (
  "github.com/inngest/inngestgo"
  "github.com/inngest/inngestgo/pkg/checkpoint"
)

_, err := inngestgo.CreateFunction(
  client,
  inngestgo.FunctionOpts{
    ID:         "my-function",
    Name:       "My Function",
    Checkpoint: checkpoint.ConfigSafe,
  },
  // ... triggers and handler
)
```

## How Does It Work?

The [Inngest default execution model](/docs-markdown/learn/how-functions-are-executed) is a complete handoff to the Inngest Platform, where an HTTP request is performed to store the execution state upon each step completion, leading to inter-step latency.

![With and Without Checkpointing](/assets/docs-markdown/checkpointing/checkpointing_with_without.png)

Checkpointing uses the SDK orchestrates steps on the client-side (*on your server*) and executes them immediately. As steps complete, checkpoint messages are sent to Inngest to track progress. The result is dramatically lower latency ‚Äî ideal for real-time AI workflows.

![Inngest Workflow Execution](/assets/docs-markdown/checkpointing/checkpointing_inngest_workflow.jpg)

### Failures and Retries

What happens when something goes wrong? If a step fails and needs to retry, the execution engine falls back to standard orchestration to handle it properly. You get speed when things work, and safety when they don't.

## Beta

Checkpointing is currently in beta, here are some notes and limitations to be aware of:

- **Parallel step execution** ‚Äî When a function branches into parallel steps, execution switches to standard orchestration for the remainder of the run. Checkpointing does not resume after parallel execution.
- **Middleware fixes (TypeScript `>=3.51.0`)** - If using an older TypeScript beta for checkpointing (`<3.51.0`), please upgrade to at least `3.51.0` to ensure that all middleware transforms are running correctly.

| Feature             | Supported |
| ------------------- | --------- |
| Local development   | ‚úÖ         |
| Self-hosted Inngest | ‚úÖ         |
| Inngest Cloud       | ‚úÖ         |

Read the [release phases](/docs-markdown/release-phases) for more details.


--------------------------------------------------------------------------------
title: "Connect"
source: "https://www.inngest.com/docs/setup/connect"
--------------------------------------------------------------------------------

# Connect

> **Info:** These docs are part of a developer preview for Inngest's connect API. Learn more about the developer preview here.

The `connect` API allows your app to create an outbound persistent connection to Inngest. Each app can establish multiple connections to Inngest, which enable you to scale horizontally across multiple workers. The key benefits of using `connect` compared to [`serve`](/docs-markdown/learn/serving-inngest-functions) are:

- **Lowest latency** - Persistent connections enable the lowest latency between your app and Inngest.
- **Elastic horizontal scaling** - Easily add more capacity by running additional workers.
- **Ideal for container runtimes** -  Deploy on Kubernetes or ECS without the need of a load balancer for inbound traffic
- **Simpler long running steps** - Step execution is not bound by platform http timeouts.

## Minimum requirements

### Language

- **TypeScript**: SDK `3.34.1` or higher.
- **Go**: SDK `0.11.2` or higher.
- **Python**: SDK `0.5.0` or higher.
  - Install the SDK with `pip install inngest[connect]` since there are additional dependencies required.
  - We also recommend the following constraints:
    - `protobuf>=5.29.4,<6.0.0`
    - `psutil>=6.0.0,<7.0.0`
    - `websockets>=15.0.0,<16.0.0`

### Runtime

You must use a long running server (Render, Fly.io, Kubernetes, etc.). Serverless runtimes (AWS Lambda, Vercel, etc.) are not supported.

If using TypeScript, your runtime must support built-in WebSocket support (Node `22.4.0` or higher, Deno `1.4` or higher, Bun `1.1` or higher).

## Getting started

Using `connect` with your app is simple. Using each SDK's "connect" method only requires a list of functions that are available to be executed. (Note: Python support is in beta; [upvote on our roadmap](https://roadmap.inngest.com/roadmap?id=2bac8d74-288f-47c7-8afc-3fd1a0e94654))

Here is a one-file example of a fully-functioning app that connects to Inngest.

```ts
import { Inngest } from "inngest";
import { connect } from "inngest/connect";

const inngest = new Inngest({
  id: "my-app",
});

const handleSignupFunction = inngest.createFunction(
  { id: "handle-signup" },
  { event: "user.created" },
  async ({ event, step }) => {
    console.log("Function called", event);
  },
);

(async () => {
  const connection = await connect({
    apps: [{ client: inngest, functions: [handleSignupFunction] }],
  });

  console.log("Worker: connected", connection);
})();
```

```go
type UserCreatedEvent struct {
	Name string
	Data struct {
		UserID string `json:"user_id"`
	}
}

func main() {
	ctx := context.Background()

	client, err := inngestgo.NewClient(inngestgo.ClientOpts{
		AppID:      "my-app",
		Logger:     logger.StdlibLogger(ctx),
		AppVersion: nil, // Optional, defaults to the git commit SHA
	})
	if err != nil {
		panic(err)
	}

	_, err = inngestgo.CreateFunction(
		client,
		inngestgo.FunctionOpts{ID: "handle-signup", Name: "Handle signup"},
		inngestgo.EventTrigger("user.created", nil),
		func(ctx context.Context, input inngestgo.Input[UserCreatedEvent]) (any, error) {
			fmt.Println("Function called")
			return map[string]any{"success": true}, nil
		},
	)
	if err != nil {
		panic(err)
	}

	fmt.Println("Worker: connecting")

	conn, err := inngestgo.Connect(ctx, inngestgo.ConnectOpts{
		InstanceID: inngestgo.Ptr("example-worker"),
		Apps:       []inngestgo.Client{client},
	})
	if err != nil {
		fmt.Printf("ERROR: %#v\n", err)
		os.Exit(1)
	}

  defer func(conn connect.WorkerConnection) {
		<-ctx.Done()
		err := conn.Close()
		if err != nil {
			fmt.Printf("could not close connection: %s\n", err)
		}
	}(conn)
}
```

```python
import asyncio
import inngest
from inngest.connect import connect

client = inngest.Inngest(app_id="my-app")

@client.create_function(
    fn_id="handle-signup",
    trigger=inngest.TriggerEvent(event="user.created"),
)
async def fn_1(ctx: inngest.Context) -> None:
    print("Function called")

functions = [fn_1]

asyncio.run(
    connect(
        apps=[(client, functions)],
    ).start()
)
```

## How does it work?

The `connect` API establishes a persistent WebSocket connection to Inngest. Each connection can handle executing multiple functions and steps concurrently. Each app can create multiple connections to Inngest enabling horizontal scaling. Additionally, connect has the following features:

- **Automatic re-connections** - The connection will automatically reconnect if it is closed.
- **Graceful shutdown** - The connection will gracefully shutdown when the app receives a signal to terminate (`SIGTERM`). New steps will not be accepted after the connection is closed, and existing steps will be allowed to complete.
- **Worker-level maximum concurrency (Coming soon)** - Each worker can configure the maximum number of concurrent steps it can handle. This allows Inngest to distribute load across multiple workers and not overload a single worker.

## Local development

During local development, set the `INNGEST_DEV=1` environment variable to enable local development mode. This will cause the SDK to connect to [the Inngest dev server](/docs-markdown/dev-server). When your worker process is running it will automatically connect to the dev server and sync your functions' configurations.

No signing or event keys are required in local development mode.

## Deploying to production

> **Warning:** The connect API is currently in developer preview and is not yet recommended for critical production workloads. We recommend deploying to a staging environment first prior to deploying to production.

### Set signing and event keys

To enable your application to securely connect to Inngest, you must set the `INNGEST_SIGNING_KEY` and `INNGEST_EVENT_KEY` environment variables.

These keys can be found in the Inngest Dashboard. Learn more about [Event keys](/docs-markdown/events/creating-an-event-key) and [Signing Keys](/docs-markdown/platform/signing-keys).

### Set your app version

The `appVersion` is used to identify the version of your app that is connected to Inngest. This allows Inngest to support rolling deploys where multiple versions of your app may be connected to Inngest.

When a new version of your app is connected to Inngest, the functions' configurations are synced to Inngest. When a new version is connected, Inngest update the function configuration in your environment and starts routing new function runs to the latest version.

You can set the `appVersion` to whatever you want, but we recommend using something that automatically changes with each deploy, like a git commit sha or Docker image tag.

```ts {{ title: "Any platform" }}
// You can set the app version to any environment variable, you might use
// a build number ('v2025.02.12.01'), git commit sha ('f5a40ff'), or
// a custom value ('my-app-v1').
const inngest = new Inngest({
  id: 'my-app',
  appVersion: process.env.MY_APP_VERSION, // Use any environment variable you choose
})
```

```ts {{ title: "GitHub Actions" }}
// If you're using Github Actions to build your app, you can set the
// app version to the GITHUB_SHA environment variable during build time
// or inject into the build of a Docker image.
const inngest = new Inngest({
  id: 'my-app',
  appVersion: process.env.GITHUB_SHA,
})
```

```ts {{ title: "Render" }}
// Render includes the RENDER_GIT_COMMIT env var at build and runtime.
// https://render.com/docs-markdown/environment-variables
const inngest = new Inngest({
  id: 'my-app',
  appVersion: process.env.RENDER_GIT_COMMIT,
})
```

```ts {{ title: "Fly.io" }}
// Fly includes a machine version env var at runtime.
// https://fly.io/docs-markdown/machines/runtime-environment/
const inngest = new Inngest({
  id: 'my-app',
  appVersion: process.env.FLY_MACHINE_VERSION,
})
```

### Set the instance id (recommended)

The `instanceId` is used to identify the worker instance of your app that is connected to Inngest. This allows Inngest to support multiple instances (workers) of your app connected to Inngest.

By default, Inngest will attempt to use the hostname of the worker as the instance id. If you're running your app in a containerized environment, you can set the `instanceId` to the container id.

```ts {{ title: "Any platform" }}
// Set the instance ID to any environment variable that is unique to the worker
await connect({
  apps: [...],
  instanceId: process.env.MY_CONTAINER_ID,
})
```

```ts {{ title: "Kubernetes + Docker" }}
// instanceId defaults to the HOSTNAME environment variable.
// By default, Kubernetes and Docker set the HOSTNAME environment variable to the pod name
// so it is automatically set for you.
await connect({
  apps: [...],
  // This is what happens under the hood if you don't set instanceId
  // instanceId: process.env.HOSTNAME,
})
```

```ts {{ title: "Render" }}
// Render includes the RENDER_INSTANCE_ID env var at runtime.
// https://render.com/docs-markdown/environment-variables
await connect({
  apps: [...],
  instanceId: process.env.RENDER_INSTANCE_ID,
})
```

```ts {{ title: "Fly.io" }}
// Fly includes the FLY_MACHINE_ID env var at runtime.
// https://fly.io/docs-markdown/machines/runtime-environment/
await connect({
  apps: [...],
  instanceId: process.env.FLY_MACHINE_ID,
})
```

### Set the max concurrency (recommended)

The `maxWorkerConcurrency` option is used to limit the number of concurrent steps that can be executed by the worker instance.
This allows Inngest to distribute load across multiple workers and not overload a single worker.

```ts
await connect({
  apps: [...],
  maxWorkerConcurrency: 10,
})
```

## Lifecycle

As a connect worker is a long-running process, it's important to understand the lifecycle of the worker and how it relates to the deployment of a new version of your app. Here is an overview of the lifecycle of a connect worker and where you can hook into it to handle graceful shutdowns and other lifecycle events.

`CONNECTING` - The worker is establishing a connection to Inngest. This starts when `connect()` is called.

First, the worker sends a request to the Inngest API via HTTP to get connection information. The response includes the WebSocket gateway URL. The worker then connects to the WebSocket gateway.

`ACTIVE` - The worker is connected to Inngest and ready to execute functions.

- The new `appVersion` is synced including the latest function configurations.
- The worker begins sending and receiving "heartbeat" messages to Inngest to ensure the connection is still active.
- The worker will automatically reconnect if the connection is lost.

```ts {{ title: "TypeScript" }}
// The connect promise will resolve when the connection is ACTIVE
const connection = await connect({
  apps: [...],
})
console.log(`The worker connection is: ${connection.state}`)
// The worker connection is: ACTIVE
```

`RECONNECTING` - The worker is reconnecting to Inngest after a connection was lost.

The worker will automatically flush any in-flight steps via the HTTP API when the WebSocket connection is lost.

By default, the worker will attempt to reconnect to Inngest an infinite number of times. See the [developer preview limitations](#limitations) for more details.

`CLOSING` - The worker is beginning the shutdown process.

- New steps will not be accepted after this state is entered.
- Existing steps will be allowed to complete. The worker will flush any in-flight steps via the HTTP API after the WebSocket connection is closed.

By default, the SDK listens for `SIGTERM` and `SIGINT` signals and begins the shutdown process. You can customize this behavior by in each SDK:

```ts
// You can explicitly configure which signals the SDK should
// listen for by an array of signals to `handleShutdownSignals`:
const connection = await connect({
  apps: [...],
  // ex. Only listen for SIGTERM, or pass an empty array to listen to no signals
  handleShutdownSignals: ['SIGTERM'],
})
```

```go
// The Go SDK must receive a Context object that will be notified
// when the correct signals are received. Use signal.NotifyContext:
ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
defer cancel()

// Later in your function - pass the context to the connect function:
ws, err := inngestgo.Connect(ctx, inngestgo.ConnectOpts{
    InstanceID: inngestgo.Ptr("example-worker"),
    Apps:       []inngestgo.Client{client},
})
```

You can manually close the connection with the `close` method on the connection object:

```ts
await connection.close()
// Connection is now closed
```

`CLOSED` - The worker's WebSocket connection has closed.

By this stage, all in-flight steps will be flushed via the HTTP API as the WebSocket connection is closed, ensuring that no in-progress steps are lost.

```ts {{ title: "TypeScript" }}
// The `closed` promise will resolve when the connection is "CLOSED"
await connection.closed
// Connection is now closed
```

> **Info:** WebSocket connection and HTTP fallback - While a WebSocket connection is open, the worker will receive and send all step results via the WebSocket connection. When the connection closes, the worker will fallback to the HTTP API to send any remaining step results.

## Worker observability

In the Inngest Cloud dashboard, you can view the connection status of each of your workers. At a glance, you can see each worker's instance id, connection status, connected at timestamp, last heartbeat, the app version, and app version.

This view is helpful for debugging connection issues or verifying rolling deploys of new app versions.

![App worker observability](/assets/docs-markdown/connect/cloud-app-workers.png)

## Syncing and Rollbacks

[//]: <> "TODO: Create diagram to explain syncing"

Inngest keeps track of the version your workers are running on. This internal representation changes when you update your function configuration, provide a new app version identifier to the client configuration, or change the SDK version or language.

When you deploy a new version of your application, the first worker to connect to Inngest will automatically sync your app. This will update function configurations to the desired state configured in your code.

`connect` supports rolling releases: During a deployment of your app, Inngest will run functions on all connected workers, regardless of the version, as long as they are able to process a request for a given function. This prevents traffic from concentrating on a single instance during rollouts and causing a thundering herd issue.

Once all old workers have terminated after a deployment, you can roll back to an old version by bringing back an old worker. Similar to the deployment process, this will update the function configuration to the previous state and gradually allow you to shift traffic to the old version by bringing up more old workers while terminating workers running the newer version.

## Health checks

If you are running your app in a containerized environment, we recommend using a health check to ensure that your app is running and ready to accept connections. This is key for graceful rollouts of new app versions. If you are using Kubernetes, we recommend using the `readinessProbe` to check that the app is ready to accept connections.

The simplest way to implement a health check is to create an http endpoint that listens for health check requests. As connect is an outbound WebSocket connection, you'll need to create a small http server that listens for health check requests and returns a 200 status code when the connection to Inngest is active.

Here is an example of using `connect` with a basic Node.js http server to listen for health check requests and return a 200 status code when the connection to Inngest is active.

```ts {{ title: "Node.js" }}
import { createServer } from "http";
import { connect, ConnectionState } from "inngest/connect";
import { inngest, functions } from "./src/inngest";

(async () => {
  const connection = await connect({
    apps: [{ client: inngest, functions }],
  });

  console.log("Worker: connected", connection);

  // This is a basic web server that only listens for the /ready endpoint
  // and returns a 200 status code when the connection to Inngest is active.
  const httpServer = createServer((req, res) => {
    if (req.url === "/ready") {
      if (connection.state === ConnectionState.ACTIVE) {
        res.writeHead(200, { "Content-Type": "text/plain" });
        res.end("OK");
      } else {
        res.writeHead(500, { "Content-Type": "text/plain" });
        res.end("NOT OK");
      }
      return;
    }
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("NOT FOUND");
  });

  // Start the server on a port of your choice
  httpServer.listen(8080, () => {
    console.log("Worker: HTTP server listening on port 8080");
  });

  // When the Inngest connection has gracefully closed,
  // this will resolve and the app will exit.
  await connection.closed;
  console.log("Worker: Shut down");

  // Stop the HTTP server
  httpServer.close();
})();
```

```ts {{ title: "Bun (JavaScript)" }}
import { connect, ConnectionState } from "inngest/connect";
import { inngest, functions } from "./src/inngest";

const connection = await connect({
  apps: [{ client: inngest, functions }],
});

console.log("Worker: connected", connection);

// Start a basic web server that only listens for the /ready endpoint
// and returns a 200 status code when the connection to Inngest is active.
const server = Bun.serve({
  port: 8080,
  routes: {
    "/ready": async () => {
      return connection.state === ConnectionState.ACTIVE
        ? new Response("OK")
        : new Response("Not Ready", { status: 500 });
    },
  },
  fetch(req) {
    return new Response("Not Found", { status: 404 });
  },
});

console.log("Worker: HTTP server listening on port 8080");

// When the Inngest connection has gracefully closed,
// this will resolve and the app will exit.
await connection.closed;
console.log("Worker: Shut down");

// Stop the HTTP server
await server.stop();
```

### Kubernetes readiness probe

If you are running your app in Kubernetes, you can use the `readinessProbe` to check that the app is ready to accept connections. For the above example running on port 8080, the readiness probe would look like this:

```yaml
readinessProbe:
  httpGet:
    path: /ready
  initialDelaySeconds: 3
  periodSeconds: 10
  successThreshold: 3
  failureThreshold: 3
```

## Worker concurrency

Worker concurrency is supported in the following versions of the SDK:

- **TypeScript**: SDK `3.45.1` or higher.
- **Go**: SDK `0.14.3` or higher.
- **Python**: SDK `0.5.12` or higher.

Each worker can configure the maximum number of concurrent steps it can execute simultaneously using the `maxWorkerConcurrency` option.
This allows you to control resource usage and prevent a single worker from being overwhelmed with too many concurrent requests.

By default, there is no limit on concurrent step execution. The worker will accept as many steps as Inngest sends to it.

When you set `maxWorkerConcurrency`, Inngest will distribute load across multiple workers based on their available capacity.
Workers with available capacity will receive more work, while workers at their limit will not receive additional steps until capacity becomes available.

Inngest uses the `instanceId` to track the `maxWorkerConcurrency` for each worker.
This means that if you have multiple workers with the same `instanceId`, they will share the same `maxWorkerConcurrency` limit.

Inngest considers the `maxWorkerConcurrency` from the latest connection request.
This means that if you update the `maxWorkerConcurrency` after a worker is connected and create a new connection, the worker's `maxWorkerConcurrency` will be updated to the new limit.

**Benefits:**

- Prevents worker resource exhaustion (CPU, memory, connections)
- Enables predictable resource allocation per worker
- Helps with horizontal scaling over both homogeneous and heterogenous workers

```ts
await connect({
  apps: [{ client: inngest, functions }],
  instanceId: "example-worker",
  maxWorkerConcurrency: 10, // Max 10 concurrent steps on this worker
})
```

```go
conn, err := inngestgo.Connect(ctx, inngestgo.ConnectOpts{
  InstanceID:           inngestgo.Ptr("example-worker"),
  MaxWorkerConcurrency: inngestgo.Ptr(int64(10)), // Max 10 concurrent steps
  Apps:                 []inngestgo.Client{client},
})
```

```python
asyncio.run(
    connect(
        apps=[(client, functions)],
        instance_id="example-worker",
        max_worker_concurrency=10,  # Max 10 concurrent steps
    ).start()
)
```

**Environment variable:**

You can also set the maximum worker concurrency via the `INNGEST_CONNECT_MAX_WORKER_CONCURRENCY` environment variable.
This is useful for configuring concurrency without changing code.

```bash
INNGEST_CONNECT_MAX_WORKER_CONCURRENCY=100
```

If both the option and environment variable are set, the option takes precedence.

**Default behavior:**

If `maxWorkerConcurrency` is not set (or set to `0`), there is no limit on concurrent step execution.
Inngest will send as many steps as limited by your account's concurrency limit.

### Connection-level concurrency

You can set a different `maxWorkerConcurrency` for each connection from the same worker by specifying a unique `instanceId` for each connection.
This will allow you to have different `maxWorkerConcurrency` limits for different connections.

Due to different `instanceId` value, Inngest will consider each connection as a separate worker and will not share the same `maxWorkerConcurrency` limit.

```ts
// Connection 1 with different concurrency limit
await connect({
  apps: [{ client: inngest, functions }],
  instanceId: "worker-1-conn-1",
  maxWorkerConcurrency: 50,
})

// Connection 2 with different concurrency limit
await connect({
  apps: [{ client: inngest, functions }],
  instanceId: "worker-1-conn-2",
  maxWorkerConcurrency: 20,
})
```

```go
// Connection 1 with different concurrency limit
conn1, err := inngestgo.Connect(ctx, inngestgo.ConnectOpts{
  InstanceID:           inngestgo.Ptr("worker-1-conn-1"),
  MaxWorkerConcurrency: inngestgo.Ptr(int64(50)),
  Apps:                 []inngestgo.Client{client},
})

// Connection 2 with different concurrency limit
conn2, err := inngestgo.Connect(ctx, inngestgo.ConnectOpts{
  InstanceID:           inngestgo.Ptr("worker-1-conn-2"),
  MaxWorkerConcurrency: inngestgo.Ptr(int64(20)),
  Apps:                 []inngestgo.Client{client},
})
```

```python
# Connection 1 with different concurrency limit
asyncio.run(
    connect(
        apps=[(client, functions)],
        instance_id="worker-1-conn-1",
        max_worker_concurrency=50,
    ).start()
)

# Connection 2 with different concurrency limit
asyncio.run(
    connect(
        apps=[(client, functions)],
        instance_id="worker-1-conn-2",
        max_worker_concurrency=20,
    ).start()
)
```

## Self hosted Inngest

> **Info:** Self-hosting support for connect is in development. Please contact us for more info.

If you are [self-hosting](/docs-markdown/self-hosting?ref=docs-connect) Inngest, you need to ensure that the Inngest WebSocket gateway is accessible within your network. The Inngest WebSocket gateway is available at port `8289`.

Depending on your network configuration, you may need to dynamically re-write the gateway URL that the SDK uses to connect.

```ts
const connection = await connect({
  apps: [...],
  rewriteGatewayEndpoint: (url) => { // ex. "wss://gw2.connect.inngest.com/v0/connect"
    // If not running in dev mode, return
    if (!process.env.INNGEST_DEV) {
      const clusterUrl = new URL(url);
      clusterUrl.host = 'my-cluster-host:8289';
      return clusterUrl.toString();
    }
    return url;
  },
})
```

## Migrating from serve

> **Info:** We are working on enabling more fine-grained function and app migrations from existing serve apps to connect.

During the Inngest developer preview, we recommend setting up a new app for trying out `connect`. We will support gradually migrating your existing `serve` apps in a future release.

## Developer preview

The `connect` API is currently in developer preview. This means that the API is not yet recommended for critical production workloads and is subject to breaking changes.

During the developer preview, the `connect` API is available to all Inngest accounts with the following plan-limits:

- Free plan: 3 concurrent worker connections
- All paid plans: 20 concurrent worker connections
- Max apps per connection: 10

Final plan limitations will be announced prior to general availability. Please [contact us](https://app.inngest.com/support) if you need to increase these limits.

Read the [release phases](/docs-markdown/release-phases) for more details.

### Limitations

During the developer preview, there are some limitations to using `connect` to be aware of. Please [contact us](https://app.inngest.com/support) if you'd like clarity on any of the following:

- **Reconnection policy is not configurable** - The SDK will attempt to reconnect to Inngest an infinite number of times. We will expose a configurable reconnection policy in the future.


--------------------------------------------------------------------------------
title: "Streaming"
source: "https://www.inngest.com/docs/streaming"
--------------------------------------------------------------------------------

# Streaming

In select environments, the SDK allows streaming responses back to Inngest, hugely increasing maximum timeouts on many serverless platforms up to 15 minutes.

While we add wider support for streaming to other platforms, we currently support the following:

- [Cloudflare Workers](/docs-markdown/learn/serving-inngest-functions#framework-cloudflare-workers)
- [Express](/docs-markdown/learn/serving-inngest-functions#framework-express)
- [Next.js on Vercel Fluid Compute or Edge Functions](/docs-markdown/learn/serving-inngest-functions#framework-next-js)
- [Remix on Vercel Edge Functions](/docs-markdown/learn/serving-inngest-functions#framework-remix)

## Enabling streaming

Select your platform above and follow the relevant "Streaming" section to enable streaming for your application.

Every Inngest serve handler provides a `streaming` option, for example:

```ts
serve({
  client: inngest,
  functions: [...fns],
  streaming: "allow",
});
```

This can be one of the following values:

- `false` - Streaming will never be used. This is the default.
- `"allow"` - Streaming will be used if we can confidently detect support for it by verifying that the platform, environment, and serve handler support streaming.

> **Callout:** ‚ö†Ô∏è We also allow "force", where streaming will be used if the serve handler supports it, but completely overrides the SDK's attempts to verify if the platform supports streaming.This is not recommended, but is an escape hatch if you know that streaming is supported and you're in a restricted environment that has little or no access to the environment.


--------------------------------------------------------------------------------
title: "TypeScript"
source: "https://www.inngest.com/docs/typescript"
--------------------------------------------------------------------------------

# TypeScript

The Inngest SDK leverages the full power of TypeScript, providing you with some awesome benefits when handling events:

- üìë **Autocomplete**
  Tab ‚Üπ your way to victory with inferred types for every event.
- **Instant feedback**
  Understand exactly where your code might error before you even save the file.

All of this comes together to provide some awesome type inference based on your actual production data.

## Using types

Once your types are generated, there are a few ways we can use them to ensure our functions are protected.

### `new Inngest()` client

We can use these when creating a new Inngest client via `new Inngest()`.

This comes with powerful inference; we autocomplete your event names when selecting what to react to, without you having to dig for the name and data.

```ts {{ title: "v3" }}
import { EventSchemas, Inngest } from "inngest";

type UserSignup = {
  data: {
    email: string;
    name: string;
  };
};
type Events = {
  "user/new.signup": UserSignup;
};

export const inngest = new Inngest({
  id: "my-app",
  schemas: new EventSchemas().fromRecord<Events>(),
});
```

```ts {{ title: "v2" }}
import { EventSchemas, Inngest } from "inngest";

type UserSignup = {
  data: {
    email: string;
    name: string;
  };
};
type Events = {
  "user/new.signup": UserSignup;
};

export const inngest = new Inngest({
  name: "My App",
  schemas: new EventSchemas().fromRecord<Events>(),
});
```

```ts {{ filename: "inngest/sendWelcomeEmail.ts" }}
import { inngest } from "./client";

export default inngest.createFunction(
  { id: "send-welcome-email" },
  { event: "user/new.signup" },
  async ({ event }) => {
    // "event" is fully typed to provide typesafety within this function
    return await email.send("welcome", event.data.email);
  }
);
```

### Sending events

TypeScript will also enforce your custom events being the right shape - see [Event Format](/docs-markdown/reference/events/send) for more details.

We recommend putting your `new Inngest()` client and types in a single file, i.e. `/inngest/client.ts` so you can use it anywhere that you send an event.

Here's an example of sending an event within a Next.js API handler:

```ts {{ filename: "pages/api/signup.ts" }}
import type { NextApiRequest, NextApiResponse } from "next";
import { inngest } from "../../inngest/client";

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const user = createNewUser(req.body.email, req.body.password, req.body.name);

  // TypeScript will now warn you if types do not match for the event payload
  // and the user object's properties:
  await inngest.send({
    name: "user/new.signup",
    data: {
      email: user.email,
      name: user.name,
    }
  });
  res.status(200).json({ success: true });
}
```

### Using with `waitForEvent`

When writing step functions, you can use `waitForEvent` to pause the current function until another event is received or the timeout expires - whichever happens first. When you declare your types using the `Inngest` constructor, `waitForEvent` leverages any types that you have:

```ts {{ title: "v3" }}
import { EventSchemas, Inngest } from "inngest";

type UserSignup = {
  data: {
    email: string;
    user_id: string;
    name: string;
  };
};
type UserAccountSetupCompleted = {
  data: {
    user_id: string;
  };
};
type Events = {
  "user/new.signup": UserSignup;
  "user/account.setup.completed": UserAccountSetupCompleted;
};

export const inngest = new Inngest({
  id: "my-app",
  schemas: new EventSchemas().fromRecord<Events>(),
});
```

```ts {{ title: "v2" }}
import { EventSchemas, Inngest } from "inngest";

type UserSignup = {
  data: {
    email: string;
    user_id: string;
    name: string;
  };
};
type UserAccountSetupCompleted = {
  data: {
    user_id: string;
  };
};
type Events = {
  "user/new.signup": UserSignup;
  "user/account.setup.completed": UserAccountSetupCompleted;
};

export const inngest = new Inngest({
  name: "My App",
  schemas: new EventSchemas().fromRecord<Events>(),
});
```

```ts {{ title: "v3" }}
import { inngest } from "./client";

export default inngest.createFunction(
  { id: "onboarding-drip-campaign" },
  { event: "user/new.signup" },
  async ({ event, step }) => {
    await step.run("send-welcome-email", async () => {
      // "event" will be fully typed provide typesafety within this function
      return await email.send("welcome", event.data.email);
    });

    // We wait up to 2 days for the user to set up their account
    const accountSetupCompleted = await step.waitForEvent(
      "wait-for-setup-complete",
      {
        event: "user/account.setup.completed",
        timeout: "2d",
        // ‚¨áÔ∏è This matches both events using the same property
        // Since both events types are registered above, this is match is typesafe
        match: "data.user_id",
      }
    );

    if (!accountSetupCompleted) {
      await step.run("send-setup-account-guide", async () => {
        return await email.send("account_setup_guide", event.data.email);
      });
    }
  }
);
```

```ts {{ title: "v2" }}
import { inngest } from "./client";

export default inngest.createFunction(
  { id: "Onboarding drip campaign" },
  { event: "user/new.signup" },
  async ({ event, step }) => {
    await step.run("Send welcome email", async () => {
      // "event" will be fully typed provide typesafety within this function
      return await email.send("welcome", event.data.email);
    });

    // We wait up to 2 days for the user to set up their account
    const accountSetupCompleted = await step.waitForEvent(
      "user/account.setup.completed",
      {
        timeout: "2d",
        // ‚¨áÔ∏è This matches both events using the same property
        // Since both events types are registered above, this is match is typesafe
        match: "data.user_id",
      }
    );

    if (!accountSetupCompleted) {
      await step.run("Send setup account guide", async () => {
        return await email.send("account_setup_guide", event.data.email);
      });
    }
  }
);
```

## Helpers

The TS SDK exports some helper types to allow you to access the type of particular Inngest internals outside of an Inngest function.

### GetEvents&#x20;

Get a record of all available events given an Inngest client.

It's recommended to use this instead of directly reusing your own event types, as Inngest will add extra properties and internal events such as `ts` and `inngest/function.failed`.

```ts
import { type GetEvents } from "inngest";
import { inngest } from "@/inngest";

type Events = GetEvents<typeof inngest>;
```

By default, the returned events do not include internal events prefixed with
`inngest/`, such as `inngest/function.finished`.

To include these events in
, pass a second `true` generic:

```ts
type Events = GetEvents<typeof inngest, true>;
```

### GetFunctionInput&#x20;

Get the argument passed to Inngest functions given an Inngest client and, optionally, an event trigger.

Useful for building function factories or other such abstractions.

```ts
import { type GetFunctionInput } from "inngest";
import { inngest } from "@/inngest";

type InputArg = GetFunctionInput<typeof inngest>;
type InputArgWithTrigger = GetFunctionInput<typeof inngest, "app/user.created">;
```

### GetStepTools&#x20;

Get the `step` object passed to an Inngest function given an Inngest client and, optionally, an event trigger.

Is a small shim over the top of `GetFunctionInput<...>["step"]`.

```ts
import { type GetStepTools } from "inngest";
import { inngest } from "@/inngest";

type StepTools = GetStepTools<typeof inngest>;
type StepToolsWithTrigger = GetStepTools<typeof inngest, "app/user.created">;
```

### Inngest.Any / InngestFunction.Any&#x20;

Some exported classes have an `Any` type within their namespace that represents any instance of that class without inference or generics.

This is useful for typing lists of functions or factories that create Inngest primitives.

```ts
import { type InngestFunction } from "inngest";

const functionsToServe: InngestFunction.Any[] = [];
```


--------------------------------------------------------------------------------
title: "Usage Limits"
source: "https://www.inngest.com/docs/usage-limits/inngest"
--------------------------------------------------------------------------------

# Usage Limits

We have put some limits on the service to make sure we provide you a good default to start with, while also keeping it a good experience for all other users using Inngest.

Some of these limits are customizable, so if you need more than what the current limits provide, please [contact us][contact] and we can update the limits for you.

## Functions

The following applies to `step` usage.

### Sleep duration

Sleep (with `step.sleep()` and `step.sleepUntil()`) up to a year, and for free plan up to seven days. Check the [pricing page](/pricing) for more information.

### Timeout

Each step has a timeout depending on the hosting provider of your choice ([see more info][provider-docs]), but Inngest supports up to `2 hours` at the maximum.

### Concurrency Upgradable

Check your concurrency limits on the [billing page](https://app.inngest.com/billing). See the [pricing page](https://www.inngest.com/pricing) for more info about the concurrency limits in all plans.

### Payload Size

The limit for data returned by a step is `4MB`.

### Function run state size

Function run state cannot exceed `32MB`. Its state includes:

- Event data (multiple events if using batching)
- Step-returned data
- Function-returned data
- Internal metadata (*small - around a few bytes*)

### Number of Steps per Function

The maximum number of steps allowed per function is `1000`.

> **Callout:** ‚ö†Ô∏è
> This limit is easily reached if you're using step on each item in a loop.
> Instead we recommend one or both of the following:Process the loop within a step and return that dataUtilize the fan out feature to process each item in a separate function

## Events

### Name length

The maximum length allowed for an event name is `256` characters.

### Request Body Size Upgradable

The maximum event payload size is dependent on your billing plan. The default on the Free Tier is `256KB` and is upgradable to `3MB`. See [the pricing page](/pricing?ref=docs-usage-limits) for additional detail.

### Number of events per request Customizable

Maximum number of events you can send in one request is `5000`.
If you're doing fan out, you'll need to be aware of this limitation when you run `step.sendEvent(events)`.

```ts {{ title: "TypeScript" }}
// this `events` list will need to be <= 5000
const events = [{name: "<event-name>", data: {}}, ...];

await step.sendEvent("send-example-events", events);
// or
await inngest.send(events);
```

```go {{ title: "Go" }}
// this `events` list will need to be <= 5000
events := []inngestgo.Event{{Name: "<event-name>", Data: {}}}

ids, err := client.SendMany(ctx, events)
```

```python {{ title: "Python" }}
# this `events` list will need to be <= 5000
events = [{'name': '<event-name>', 'data': {}}, ...]

await step.send_event('send-example-events', events)
# or
await inngest.send(events)
```

### Batch size

The hard limit of a batch size is 10 MiB regardless of the `timeout` or `maxSize` limit.
Meaning the batch will be started if that limit is crossed even if the batch is not full or has not reached the timeout duration configured.

[provider-docs]: /docs-markdown/usage-limits/providers

[fanout-guide]: /docs/guides/fan-out-jobs

[contact]: /contact


--------------------------------------------------------------------------------
title: "Providers' Usage Limits"
source: "https://www.inngest.com/docs/usage-limits/providers"
--------------------------------------------------------------------------------

# Providers' Usage Limits

As your functions' code runs on the hosting provider of your choice, you will be subject to provider or billing plan
limits separate from [Inngest's own limits](/docs-markdown/usage-limits/inngest).

Here are the known usage limits for each provider we support based on their documentation.

|                                         | Payload size  | Concurrency                     | Timeout                    |
| --------------------------------------- | :------------ | ------------------------------- | -------------------------- |
| [AWS Lambda][aws-quota]                 | 6MB - 20MB    | 1000                            | 15m                        |
| [Google Cloud Functions][gcp-quota]     | 512KB - 32MB  | 3000 (1st gen only)             | 10m - 60m                  |
| [Cloudflare Workers][cf-workers-limits] | 100MB - 500MB | 100 - 500                       | [N/A][cf-workers-duration] |
| [Vercel][vercel-limits]                 | 4MB - 4.5MB   | 1000                            | 10s - 900s, N/A (Edge Fn)  |
| [Netlify][netlify-limits]               | 256KB - 6MB   | Undocumented                    | 10s - 15m                  |
| [DigitalOcean][digitalocean-limits]     | 1MB           | 120                             | 15m                        |
| Fly.io                                  | Undocumented  | [User configured][flyio-limits] | Undocumented               |

For more details tailored to your plan, please check each provider's website.

[aws-quota]: https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html

[gcp-quota]: https://cloud.google.com/functions/quotas

[cf-workers-limits]: https://developers.cloudflare.com/workers/platform/limits/

[cf-workers-duration]: https://developers.cloudflare.com/workers/platform/limits/#worker-limits

[vercel-limits]: https://vercel.com/docs-markdown/concepts/limits/overview

[netlify-limits]: https://docs.netlify.com/functions/overview/#default-deployment-options

[digitalocean-limits]: https://docs.digitalocean.com/products/functions/details/limits/

[flyio-limits]: https://fly.io/docs/reference/configuration/#http_service-concurrency
